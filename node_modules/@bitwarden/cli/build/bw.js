#!/usr/bin/env node
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 21);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = require("commander");

/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = require("path");

/***/ }),
/* 2 */
/***/ (function(module, exports) {

module.exports = require("node-forge");

/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = require("fs");

/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = require("node-fetch");

/***/ }),
/* 5 */
/***/ (function(module, exports) {

module.exports = require("inquirer");

/***/ }),
/* 6 */
/***/ (function(module, exports) {

module.exports = require("crypto");

/***/ }),
/* 7 */
/***/ (function(module, exports) {

module.exports = require("tldjs");

/***/ }),
/* 8 */
/***/ (function(module, exports) {

module.exports = require("papaparse");

/***/ }),
/* 9 */
/***/ (function(module, exports) {

module.exports = require("lunr");

/***/ }),
/* 10 */
/***/ (function(module, exports) {

module.exports = require("chalk");

/***/ }),
/* 11 */
/***/ (function(module, exports) {

module.exports = require("lowdb");

/***/ }),
/* 12 */
/***/ (function(module, exports) {

module.exports = require("jsdom");

/***/ }),
/* 13 */
/***/ (function(module, exports) {

module.exports = require("big-integer");

/***/ }),
/* 14 */
/***/ (function(module, exports) {

module.exports = require("lowdb/adapters/FileSync");

/***/ }),
/* 15 */
/***/ (function(module, exports) {

module.exports = require("readline");

/***/ }),
/* 16 */
/***/ (function(module, exports) {

module.exports = require("form-data");

/***/ }),
/* 17 */
/***/ (function(module, exports) {

module.exports = require("https-proxy-agent");

/***/ }),
/* 18 */
/***/ (function(module, exports) {

module.exports = require("zxcvbn");

/***/ }),
/* 19 */
/***/ (function(module, exports) {

module.exports = require("url");

/***/ }),
/* 20 */
/***/ (function(module) {

module.exports = {"name":"@bitwarden/cli","description":"A secure and free password manager for all of your devices.","version":"1.10.0","keywords":["bitwarden","password","vault","password manager","cli"],"author":"Bitwarden Inc. <hello@bitwarden.com> (https://bitwarden.com)","homepage":"https://bitwarden.com","repository":{"type":"git","url":"https://github.com/bitwarden/cli"},"license":"GPL-3.0","scripts":{"sub:init":"git submodule update --init --recursive","sub:update":"git submodule update --remote","sub:pull":"git submodule foreach git pull origin master","clean":"rimraf dist/**/*","symlink:win":"rmdir /S /Q ./jslib && cmd /c mklink /J .\\jslib ..\\jslib","symlink:mac":"npm run symlink:lin","symlink:lin":"rm -rf ./jslib && ln -s ../jslib ./jslib","build":"webpack","build:watch":"webpack --watch","build:prod":"cross-env NODE_ENV=production webpack","build:prod:watch":"cross-env NODE_ENV=production webpack --watch","package":"npm run package:win | npm run package:mac | npm run package:lin","package:win":"pkg . --targets win-x64 --output ./dist/windows/bw.exe","package:mac":"pkg . --targets macos-x64 --output ./dist/macos/bw","package:lin":"pkg . --targets linux-x64 --output ./dist/linux/bw","dist":"npm run build:prod && npm run clean && npm run package","dist:win":"npm run build:prod && npm run clean && npm run package:win","dist:mac":"npm run build:prod && npm run clean && npm run package:mac","dist:lin":"npm run build:prod && npm run clean && npm run package:lin","publish:npm":"npm run build:prod && npm publish --access public","lint":"tslint src/**/*.ts spec/**/*.ts || true","lint:fix":"tslint src/**/*.ts spec/**/*.ts --fix"},"bin":{"bw":"./build/bw.js"},"pkg":{"assets":"./build/**/*"},"devDependencies":{"@types/commander":"^2.12.2","@types/form-data":"^2.2.1","@types/inquirer":"^0.0.43","@types/jsdom":"^12.2.1","@types/lowdb":"^1.0.5","@types/lunr":"^2.3.3","@types/node":"^10.9.4","@types/node-fetch":"^2.1.2","@types/node-forge":"^0.7.5","@types/papaparse":"^4.5.3","@types/tldjs":"^2.3.0","@types/zxcvbn":"4.4.0","clean-webpack-plugin":"^0.1.19","copy-webpack-plugin":"^4.5.2","cross-env":"^5.2.0","pkg":"4.3.4","ts-loader":"^5.3.3","tslint":"^5.12.1","tslint-loader":"^3.5.4","typescript":"3.2.4","webpack":"^4.29.0","webpack-cli":"^3.2.1","webpack-node-externals":"^1.7.2"},"dependencies":{"big-integer":"1.6.36","chalk":"2.4.1","commander":"2.18.0","form-data":"2.3.2","https-proxy-agent":"4.0.0","inquirer":"6.2.0","jsdom":"13.2.0","lowdb":"1.0.0","lunr":"2.3.3","node-fetch":"2.2.0","node-forge":"0.7.6","papaparse":"4.6.0","tldjs":"2.3.1","zxcvbn":"4.4.2"}};

/***/ }),
/* 21 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: external "fs"
var external_fs_ = __webpack_require__(3);

// EXTERNAL MODULE: external "jsdom"
var external_jsdom_ = __webpack_require__(12);

// EXTERNAL MODULE: external "path"
var external_path_ = __webpack_require__(1);

// CONCATENATED MODULE: ./jslib/src/enums/twoFactorProviderType.ts
var TwoFactorProviderType;
(function (TwoFactorProviderType) {
    TwoFactorProviderType[TwoFactorProviderType["Authenticator"] = 0] = "Authenticator";
    TwoFactorProviderType[TwoFactorProviderType["Email"] = 1] = "Email";
    TwoFactorProviderType[TwoFactorProviderType["Duo"] = 2] = "Duo";
    TwoFactorProviderType[TwoFactorProviderType["Yubikey"] = 3] = "Yubikey";
    TwoFactorProviderType[TwoFactorProviderType["U2f"] = 4] = "U2f";
    TwoFactorProviderType[TwoFactorProviderType["Remember"] = 5] = "Remember";
    TwoFactorProviderType[TwoFactorProviderType["OrganizationDuo"] = 6] = "OrganizationDuo";
})(TwoFactorProviderType || (TwoFactorProviderType = {}));

// CONCATENATED MODULE: ./jslib/src/models/domain/authResult.ts
class AuthResult {
    constructor() {
        this.twoFactor = false;
        this.twoFactorProviders = null;
    }
}

// CONCATENATED MODULE: ./jslib/src/models/request/deviceRequest.ts
class DeviceRequest {
    constructor(appId, platformUtilsService) {
        this.type = platformUtilsService.getDevice();
        this.name = platformUtilsService.getDeviceString();
        this.identifier = appId;
        this.pushToken = null;
    }
}

// CONCATENATED MODULE: ./jslib/src/models/request/keysRequest.ts
class KeysRequest {
    constructor(publicKey, encryptedPrivateKey) {
        this.publicKey = publicKey;
        this.encryptedPrivateKey = encryptedPrivateKey;
    }
}

// CONCATENATED MODULE: ./jslib/src/models/request/preloginRequest.ts
class PreloginRequest {
    constructor(email) {
        this.email = email;
    }
}

// CONCATENATED MODULE: ./jslib/src/models/request/tokenRequest.ts
class TokenRequest {
    constructor(email, masterPasswordHash, provider, token, remember, device) {
        this.email = email;
        this.masterPasswordHash = masterPasswordHash;
        this.token = token;
        this.provider = provider;
        this.remember = remember;
        this.device = device != null ? device : null;
    }
    toIdentityToken(clientId) {
        const obj = {
            grant_type: 'password',
            username: this.email,
            password: this.masterPasswordHash,
            scope: 'api offline_access',
            client_id: clientId,
        };
        if (this.device) {
            obj.deviceType = this.device.type;
            obj.deviceIdentifier = this.device.identifier;
            obj.deviceName = this.device.name;
            // no push tokens for browser apps yet
            // obj.devicePushToken = this.device.pushToken;
        }
        if (this.token && this.provider != null) {
            obj.twoFactorToken = this.token;
            obj.twoFactorProvider = this.provider;
            obj.twoFactorRemember = this.remember ? '1' : '0';
        }
        return obj;
    }
}

// CONCATENATED MODULE: ./jslib/src/services/auth.service.ts
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};






const TwoFactorProviders = {
    [TwoFactorProviderType.Authenticator]: {
        type: TwoFactorProviderType.Authenticator,
        name: null,
        description: null,
        priority: 1,
        sort: 1,
        premium: false,
    },
    [TwoFactorProviderType.Yubikey]: {
        type: TwoFactorProviderType.Yubikey,
        name: null,
        description: null,
        priority: 3,
        sort: 2,
        premium: true,
    },
    [TwoFactorProviderType.Duo]: {
        type: TwoFactorProviderType.Duo,
        name: 'Duo',
        description: null,
        priority: 2,
        sort: 3,
        premium: true,
    },
    [TwoFactorProviderType.OrganizationDuo]: {
        type: TwoFactorProviderType.OrganizationDuo,
        name: 'Duo (Organization)',
        description: null,
        priority: 10,
        sort: 4,
        premium: false,
    },
    [TwoFactorProviderType.U2f]: {
        type: TwoFactorProviderType.U2f,
        name: null,
        description: null,
        priority: 4,
        sort: 5,
        premium: true,
    },
    [TwoFactorProviderType.Email]: {
        type: TwoFactorProviderType.Email,
        name: null,
        description: null,
        priority: 0,
        sort: 6,
        premium: false,
    },
};
class auth_service_AuthService {
    constructor(cryptoService, apiService, userService, tokenService, appIdService, i18nService, platformUtilsService, messagingService, setCryptoKeys = true) {
        this.cryptoService = cryptoService;
        this.apiService = apiService;
        this.userService = userService;
        this.tokenService = tokenService;
        this.appIdService = appIdService;
        this.i18nService = i18nService;
        this.platformUtilsService = platformUtilsService;
        this.messagingService = messagingService;
        this.setCryptoKeys = setCryptoKeys;
        this.selectedTwoFactorProviderType = null;
    }
    init() {
        TwoFactorProviders[TwoFactorProviderType.Email].name = this.i18nService.t('emailTitle');
        TwoFactorProviders[TwoFactorProviderType.Email].description = this.i18nService.t('emailDesc');
        TwoFactorProviders[TwoFactorProviderType.Authenticator].name = this.i18nService.t('authenticatorAppTitle');
        TwoFactorProviders[TwoFactorProviderType.Authenticator].description =
            this.i18nService.t('authenticatorAppDesc');
        TwoFactorProviders[TwoFactorProviderType.Duo].description = this.i18nService.t('duoDesc');
        TwoFactorProviders[TwoFactorProviderType.OrganizationDuo].name =
            'Duo (' + this.i18nService.t('organization') + ')';
        TwoFactorProviders[TwoFactorProviderType.OrganizationDuo].description =
            this.i18nService.t('duoOrganizationDesc');
        TwoFactorProviders[TwoFactorProviderType.U2f].name = this.i18nService.t('u2fTitle');
        TwoFactorProviders[TwoFactorProviderType.U2f].description = this.i18nService.t('u2fDesc');
        TwoFactorProviders[TwoFactorProviderType.Yubikey].name = this.i18nService.t('yubiKeyTitle');
        TwoFactorProviders[TwoFactorProviderType.Yubikey].description = this.i18nService.t('yubiKeyDesc');
    }
    logIn(email, masterPassword) {
        return __awaiter(this, void 0, void 0, function* () {
            this.selectedTwoFactorProviderType = null;
            const key = yield this.makePreloginKey(masterPassword, email);
            const hashedPassword = yield this.cryptoService.hashPassword(masterPassword, key);
            return yield this.logInHelper(email, hashedPassword, key);
        });
    }
    logInTwoFactor(twoFactorProvider, twoFactorToken, remember) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.logInHelper(this.email, this.masterPasswordHash, this.key, twoFactorProvider, twoFactorToken, remember);
        });
    }
    logInComplete(email, masterPassword, twoFactorProvider, twoFactorToken, remember) {
        return __awaiter(this, void 0, void 0, function* () {
            this.selectedTwoFactorProviderType = null;
            const key = yield this.makePreloginKey(masterPassword, email);
            const hashedPassword = yield this.cryptoService.hashPassword(masterPassword, key);
            return yield this.logInHelper(email, hashedPassword, key, twoFactorProvider, twoFactorToken, remember);
        });
    }
    logOut(callback) {
        callback();
        this.messagingService.send('loggedOut');
    }
    getSupportedTwoFactorProviders(win) {
        const providers = [];
        if (this.twoFactorProvidersData == null) {
            return providers;
        }
        if (this.twoFactorProvidersData.has(TwoFactorProviderType.OrganizationDuo) &&
            this.platformUtilsService.supportsDuo()) {
            providers.push(TwoFactorProviders[TwoFactorProviderType.OrganizationDuo]);
        }
        if (this.twoFactorProvidersData.has(TwoFactorProviderType.Authenticator)) {
            providers.push(TwoFactorProviders[TwoFactorProviderType.Authenticator]);
        }
        if (this.twoFactorProvidersData.has(TwoFactorProviderType.Yubikey)) {
            providers.push(TwoFactorProviders[TwoFactorProviderType.Yubikey]);
        }
        if (this.twoFactorProvidersData.has(TwoFactorProviderType.Duo) && this.platformUtilsService.supportsDuo()) {
            providers.push(TwoFactorProviders[TwoFactorProviderType.Duo]);
        }
        if (this.twoFactorProvidersData.has(TwoFactorProviderType.U2f) && this.platformUtilsService.supportsU2f(win)) {
            providers.push(TwoFactorProviders[TwoFactorProviderType.U2f]);
        }
        if (this.twoFactorProvidersData.has(TwoFactorProviderType.Email)) {
            providers.push(TwoFactorProviders[TwoFactorProviderType.Email]);
        }
        return providers;
    }
    getDefaultTwoFactorProvider(u2fSupported) {
        if (this.twoFactorProvidersData == null) {
            return null;
        }
        if (this.selectedTwoFactorProviderType != null &&
            this.twoFactorProvidersData.has(this.selectedTwoFactorProviderType)) {
            return this.selectedTwoFactorProviderType;
        }
        let providerType = null;
        let providerPriority = -1;
        this.twoFactorProvidersData.forEach((value, type) => {
            const provider = TwoFactorProviders[type];
            if (provider != null && provider.priority > providerPriority) {
                if (type === TwoFactorProviderType.U2f && !u2fSupported) {
                    return;
                }
                providerType = type;
                providerPriority = provider.priority;
            }
        });
        return providerType;
    }
    makePreloginKey(masterPassword, email) {
        return __awaiter(this, void 0, void 0, function* () {
            email = email.trim().toLowerCase();
            this.kdf = null;
            this.kdfIterations = null;
            try {
                const preloginResponse = yield this.apiService.postPrelogin(new PreloginRequest(email));
                if (preloginResponse != null) {
                    this.kdf = preloginResponse.kdf;
                    this.kdfIterations = preloginResponse.kdfIterations;
                }
            }
            catch (e) {
                if (e == null || e.statusCode !== 404) {
                    throw e;
                }
            }
            return this.cryptoService.makeKey(masterPassword, email, this.kdf, this.kdfIterations);
        });
    }
    logInHelper(email, hashedPassword, key, twoFactorProvider, twoFactorToken, remember) {
        return __awaiter(this, void 0, void 0, function* () {
            const storedTwoFactorToken = yield this.tokenService.getTwoFactorToken(email);
            const appId = yield this.appIdService.getAppId();
            const deviceRequest = new DeviceRequest(appId, this.platformUtilsService);
            let request;
            if (twoFactorToken != null && twoFactorProvider != null) {
                request = new TokenRequest(email, hashedPassword, twoFactorProvider, twoFactorToken, remember, deviceRequest);
            }
            else if (storedTwoFactorToken != null) {
                request = new TokenRequest(email, hashedPassword, TwoFactorProviderType.Remember, storedTwoFactorToken, false, deviceRequest);
            }
            else {
                request = new TokenRequest(email, hashedPassword, null, null, false, deviceRequest);
            }
            const response = yield this.apiService.postIdentityToken(request);
            this.clearState();
            const result = new AuthResult();
            result.twoFactor = !response.accessToken;
            if (result.twoFactor) {
                // two factor required
                const twoFactorResponse = response;
                this.email = email;
                this.masterPasswordHash = hashedPassword;
                this.key = this.setCryptoKeys ? key : null;
                this.twoFactorProvidersData = twoFactorResponse.twoFactorProviders2;
                result.twoFactorProviders = twoFactorResponse.twoFactorProviders2;
                return result;
            }
            const tokenResponse = response;
            if (tokenResponse.twoFactorToken != null) {
                yield this.tokenService.setTwoFactorToken(tokenResponse.twoFactorToken, email);
            }
            yield this.tokenService.setTokens(tokenResponse.accessToken, tokenResponse.refreshToken);
            yield this.userService.setInformation(this.tokenService.getUserId(), this.tokenService.getEmail(), this.kdf, this.kdfIterations);
            if (this.setCryptoKeys) {
                yield this.cryptoService.setKey(key);
                yield this.cryptoService.setKeyHash(hashedPassword);
                yield this.cryptoService.setEncKey(tokenResponse.key);
                // User doesn't have a key pair yet (old account), let's generate one for them
                if (tokenResponse.privateKey == null) {
                    try {
                        const keyPair = yield this.cryptoService.makeKeyPair();
                        yield this.apiService.postAccountKeys(new KeysRequest(keyPair[0], keyPair[1].encryptedString));
                        tokenResponse.privateKey = keyPair[1].encryptedString;
                    }
                    catch (e) {
                        // tslint:disable-next-line
                        console.error(e);
                    }
                }
                yield this.cryptoService.setEncPrivateKey(tokenResponse.privateKey);
            }
            this.messagingService.send('loggedIn');
            return result;
        });
    }
    clearState() {
        this.email = null;
        this.masterPasswordHash = null;
        this.twoFactorProvidersData = null;
        this.selectedTwoFactorProviderType = null;
    }
}

// CONCATENATED MODULE: ./jslib/src/services/i18n.service.ts
var i18n_service_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class i18n_service_I18nService {
    constructor(systemLanguage, localesDirectory, getLocalesJson) {
        this.systemLanguage = systemLanguage;
        this.localesDirectory = localesDirectory;
        this.getLocalesJson = getLocalesJson;
        // First locale is the default (English)
        this.supportedTranslationLocales = ['en'];
        this.localeNames = new Map([
            ['af', 'Afrikaans'],
            ['bg', 'български'],
            ['ca', 'català'],
            ['cs', 'čeština'],
            ['da', 'dansk'],
            ['de', 'Deutsch'],
            ['el', 'Ελληνικά'],
            ['en', 'English'],
            ['en-GB', 'English (British)'],
            ['eo', 'Esperanto'],
            ['es', 'español'],
            ['et', 'eesti'],
            ['fa', 'فارسی'],
            ['fi', 'suomi'],
            ['fr', 'français'],
            ['he', 'עברית'],
            ['hi', 'हिन्दी'],
            ['hr', 'hrvatski'],
            ['hu', 'magyar'],
            ['id', 'Bahasa Indonesia'],
            ['it', 'italiano'],
            ['ja', '日本語'],
            ['ko', '한국어'],
            ['nb', 'norsk (bokmål)'],
            ['nl', 'Nederlands'],
            ['pl', 'polski'],
            ['pt-BR', 'português do Brasil'],
            ['pt-PT', 'português'],
            ['ro', 'română'],
            ['ru', 'русский'],
            ['sk', 'slovenčina'],
            ['sv', 'svenska'],
            ['th', 'ไทย'],
            ['tr', 'Türkçe'],
            ['uk', 'українська'],
            ['vi', 'Tiếng Việt'],
            ['zh-CN', '中文（中国大陆）'],
            ['zh-TW', '中文（台灣）'],
        ]);
        this.defaultMessages = {};
        this.localeMessages = {};
        this.systemLanguage = systemLanguage.replace('_', '-');
    }
    init(locale) {
        return i18n_service_awaiter(this, void 0, void 0, function* () {
            if (this.inited) {
                throw new Error('i18n already initialized.');
            }
            if (this.supportedTranslationLocales == null || this.supportedTranslationLocales.length === 0) {
                throw new Error('supportedTranslationLocales not set.');
            }
            this.inited = true;
            this.locale = this.translationLocale = locale != null ? locale : this.systemLanguage;
            try {
                this.collator = new Intl.Collator(this.locale, { numeric: true, sensitivity: 'base' });
            }
            catch (_a) {
                this.collator = null;
            }
            if (this.supportedTranslationLocales.indexOf(this.translationLocale) === -1) {
                this.translationLocale = this.translationLocale.slice(0, 2);
                if (this.supportedTranslationLocales.indexOf(this.translationLocale) === -1) {
                    this.translationLocale = this.supportedTranslationLocales[0];
                }
            }
            if (this.localesDirectory != null) {
                yield this.loadMessages(this.translationLocale, this.localeMessages);
                if (this.translationLocale !== this.supportedTranslationLocales[0]) {
                    yield this.loadMessages(this.supportedTranslationLocales[0], this.defaultMessages);
                }
            }
        });
    }
    t(id, p1, p2, p3) {
        return this.translate(id, p1, p2, p3);
    }
    translate(id, p1, p2, p3) {
        let result;
        if (this.localeMessages.hasOwnProperty(id) && this.localeMessages[id]) {
            result = this.localeMessages[id];
        }
        else if (this.defaultMessages.hasOwnProperty(id) && this.defaultMessages[id]) {
            result = this.defaultMessages[id];
        }
        else {
            result = '';
        }
        if (result !== '') {
            if (p1 != null) {
                result = result.split('__$1__').join(p1);
            }
            if (p2 != null) {
                result = result.split('__$2__').join(p2);
            }
            if (p3 != null) {
                result = result.split('__$3__').join(p3);
            }
        }
        return result;
    }
    loadMessages(locale, messagesObj) {
        return i18n_service_awaiter(this, void 0, void 0, function* () {
            const formattedLocale = locale.replace('-', '_');
            const locales = yield this.getLocalesJson(formattedLocale);
            for (const prop in locales) {
                if (!locales.hasOwnProperty(prop)) {
                    continue;
                }
                messagesObj[prop] = locales[prop].message;
                if (locales[prop].placeholders) {
                    for (const placeProp in locales[prop].placeholders) {
                        if (!locales[prop].placeholders.hasOwnProperty(placeProp) ||
                            !locales[prop].placeholders[placeProp].content) {
                            continue;
                        }
                        const replaceToken = '\\$' + placeProp.toUpperCase() + '\\$';
                        let replaceContent = locales[prop].placeholders[placeProp].content;
                        if (replaceContent === '$1' || replaceContent === '$2' || replaceContent === '$3') {
                            replaceContent = '__$' + replaceContent + '__';
                        }
                        messagesObj[prop] = messagesObj[prop].replace(new RegExp(replaceToken, 'g'), replaceContent);
                    }
                }
            }
        });
    }
}

// CONCATENATED MODULE: ./src/services/i18n.service.ts



class services_i18n_service_I18nService extends i18n_service_I18nService {
    constructor(systemLanguage, localesDirectory) {
        super(systemLanguage, localesDirectory, (formattedLocale) => {
            const filePath = external_path_["join"](__dirname, this.localesDirectory + '/' + formattedLocale + '/messages.json');
            const localesJson = external_fs_["readFileSync"](filePath, 'utf8');
            const locales = JSON.parse(localesJson.replace(/^\uFEFF/, '')); // strip the BOM
            return Promise.resolve(locales);
        });
        this.supportedTranslationLocales = [
            'en',
        ];
    }
}

// CONCATENATED MODULE: ./jslib/src/models/data/attachmentData.ts
class AttachmentData {
    constructor(response) {
        if (response == null) {
            return;
        }
        this.id = response.id;
        this.url = response.url;
        this.fileName = response.fileName;
        this.key = response.key;
        this.size = response.size;
        this.sizeName = response.sizeName;
    }
}

// CONCATENATED MODULE: ./jslib/src/models/view/attachmentView.ts
class AttachmentView {
    constructor(a) {
        this.id = null;
        this.url = null;
        this.size = null;
        this.sizeName = null;
        this.fileName = null;
        this.key = null;
        if (!a) {
            return;
        }
        this.id = a.id;
        this.url = a.url;
        this.size = a.size;
        this.sizeName = a.sizeName;
    }
    get fileSize() {
        try {
            if (this.size != null) {
                return parseInt(this.size, null);
            }
        }
        catch (_a) { }
        return 0;
    }
}

// CONCATENATED MODULE: ./jslib/src/enums/encryptionType.ts
var EncryptionType;
(function (EncryptionType) {
    EncryptionType[EncryptionType["AesCbc256_B64"] = 0] = "AesCbc256_B64";
    EncryptionType[EncryptionType["AesCbc128_HmacSha256_B64"] = 1] = "AesCbc128_HmacSha256_B64";
    EncryptionType[EncryptionType["AesCbc256_HmacSha256_B64"] = 2] = "AesCbc256_HmacSha256_B64";
    EncryptionType[EncryptionType["Rsa2048_OaepSha256_B64"] = 3] = "Rsa2048_OaepSha256_B64";
    EncryptionType[EncryptionType["Rsa2048_OaepSha1_B64"] = 4] = "Rsa2048_OaepSha1_B64";
    EncryptionType[EncryptionType["Rsa2048_OaepSha256_HmacSha256_B64"] = 5] = "Rsa2048_OaepSha256_HmacSha256_B64";
    EncryptionType[EncryptionType["Rsa2048_OaepSha1_HmacSha256_B64"] = 6] = "Rsa2048_OaepSha1_HmacSha256_B64";
})(EncryptionType || (EncryptionType = {}));

// EXTERNAL MODULE: external "tldjs"
var external_tldjs_ = __webpack_require__(7);

// CONCATENATED MODULE: ./jslib/src/misc/utils.ts

// tslint:disable-next-line
const nodeURL = typeof window === 'undefined' ? __webpack_require__(19) : null;
class utils_Utils {
    static init() {
        if (utils_Utils.inited) {
            return;
        }
        utils_Utils.inited = true;
        utils_Utils.isNode = typeof process !== 'undefined' && process.release != null &&
            process.release.name === 'node';
        utils_Utils.isBrowser = typeof window !== 'undefined';
        utils_Utils.isNativeScript = !utils_Utils.isNode && !utils_Utils.isBrowser;
        utils_Utils.isMobileBrowser = utils_Utils.isBrowser && this.isMobile(window);
        utils_Utils.isAppleMobileBrowser = utils_Utils.isBrowser && this.isAppleMobile(window);
        utils_Utils.global = utils_Utils.isNativeScript ? global : (utils_Utils.isNode && !utils_Utils.isBrowser ? global : window);
    }
    static fromB64ToArray(str) {
        if (utils_Utils.isNode || utils_Utils.isNativeScript) {
            return new Uint8Array(Buffer.from(str, 'base64'));
        }
        else {
            const binaryString = window.atob(str);
            const bytes = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes;
        }
    }
    static fromHexToArray(str) {
        if (utils_Utils.isNode || utils_Utils.isNativeScript) {
            return new Uint8Array(Buffer.from(str, 'hex'));
        }
        else {
            const bytes = new Uint8Array(str.length / 2);
            for (let i = 0; i < str.length; i += 2) {
                bytes[i / 2] = parseInt(str.substr(i, 2), 16);
            }
            return bytes;
        }
    }
    static fromUtf8ToArray(str) {
        if (utils_Utils.isNode || utils_Utils.isNativeScript) {
            return new Uint8Array(Buffer.from(str, 'utf8'));
        }
        else {
            const strUtf8 = unescape(encodeURIComponent(str));
            const arr = new Uint8Array(strUtf8.length);
            for (let i = 0; i < strUtf8.length; i++) {
                arr[i] = strUtf8.charCodeAt(i);
            }
            return arr;
        }
    }
    static fromByteStringToArray(str) {
        const arr = new Uint8Array(str.length);
        for (let i = 0; i < str.length; i++) {
            arr[i] = str.charCodeAt(i);
        }
        return arr;
    }
    static fromBufferToB64(buffer) {
        if (utils_Utils.isNode || utils_Utils.isNativeScript) {
            return Buffer.from(buffer).toString('base64');
        }
        else {
            let binary = '';
            const bytes = new Uint8Array(buffer);
            for (let i = 0; i < bytes.byteLength; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return window.btoa(binary);
        }
    }
    static fromBufferToUtf8(buffer) {
        if (utils_Utils.isNode || utils_Utils.isNativeScript) {
            return Buffer.from(buffer).toString('utf8');
        }
        else {
            const bytes = new Uint8Array(buffer);
            const encodedString = String.fromCharCode.apply(null, bytes);
            return decodeURIComponent(escape(encodedString));
        }
    }
    static fromBufferToByteString(buffer) {
        return String.fromCharCode.apply(null, new Uint8Array(buffer));
    }
    // ref: https://stackoverflow.com/a/40031979/1090359
    static fromBufferToHex(buffer) {
        if (utils_Utils.isNode || utils_Utils.isNativeScript) {
            return Buffer.from(buffer).toString('hex');
        }
        else {
            const bytes = new Uint8Array(buffer);
            return Array.prototype.map.call(bytes, (x) => ('00' + x.toString(16)).slice(-2)).join('');
        }
    }
    static fromUrlB64ToUtf8(b64Str) {
        let output = b64Str.replace(/-/g, '+').replace(/_/g, '/');
        switch (output.length % 4) {
            case 0:
                break;
            case 2:
                output += '==';
                break;
            case 3:
                output += '=';
                break;
            default:
                throw new Error('Illegal base64url string!');
        }
        return utils_Utils.fromB64ToUtf8(output);
    }
    static fromB64ToUtf8(b64Str) {
        if (utils_Utils.isNode || utils_Utils.isNativeScript) {
            return Buffer.from(b64Str, 'base64').toString('utf8');
        }
        else {
            return decodeURIComponent(escape(window.atob(b64Str)));
        }
    }
    // ref: http://stackoverflow.com/a/2117523/1090359
    static newGuid() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
            // tslint:disable-next-line
            const r = Math.random() * 16 | 0;
            // tslint:disable-next-line
            const v = c === 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    }
    static isGuid(id) {
        return RegExp(/^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/, 'i').test(id);
    }
    static getHostname(uriString) {
        const url = utils_Utils.getUrl(uriString);
        try {
            return url != null ? url.hostname : null;
        }
        catch (_a) {
            return null;
        }
    }
    static getHost(uriString) {
        const url = utils_Utils.getUrl(uriString);
        try {
            return url != null ? url.host : null;
        }
        catch (_a) {
            return null;
        }
    }
    static getDomain(uriString) {
        if (uriString == null) {
            return null;
        }
        uriString = uriString.trim();
        if (uriString === '') {
            return null;
        }
        if (uriString.startsWith('data:')) {
            return null;
        }
        let httpUrl = uriString.startsWith('http://') || uriString.startsWith('https://');
        if (!httpUrl && uriString.indexOf('://') < 0 && utils_Utils.tldEndingRegex.test(uriString)) {
            uriString = 'http://' + uriString;
            httpUrl = true;
        }
        if (httpUrl) {
            try {
                const url = utils_Utils.getUrlObject(uriString);
                if (url.hostname === 'localhost' || utils_Utils.validIpAddress(url.hostname)) {
                    return url.hostname;
                }
                const urlDomain = external_tldjs_ != null && external_tldjs_["getDomain"] != null ? external_tldjs_["getDomain"](url.hostname) : null;
                return urlDomain != null ? urlDomain : url.hostname;
            }
            catch (e) { }
        }
        const domain = external_tldjs_ != null && external_tldjs_["getDomain"] != null ? external_tldjs_["getDomain"](uriString) : null;
        if (domain != null) {
            return domain;
        }
        return null;
    }
    static getQueryParams(uriString) {
        const url = utils_Utils.getUrl(uriString);
        if (url == null || url.search == null || url.search === '') {
            return null;
        }
        const map = new Map();
        const pairs = (url.search[0] === '?' ? url.search.substr(1) : url.search).split('&');
        pairs.forEach((pair) => {
            const parts = pair.split('=');
            if (parts.length < 1) {
                return;
            }
            map.set(decodeURIComponent(parts[0]).toLowerCase(), parts[1] == null ? '' : decodeURIComponent(parts[1]));
        });
        return map;
    }
    static getSortFunction(i18nService, prop) {
        return (a, b) => {
            if (a[prop] == null && b[prop] != null) {
                return -1;
            }
            if (a[prop] != null && b[prop] == null) {
                return 1;
            }
            if (a[prop] == null && b[prop] == null) {
                return 0;
            }
            return i18nService.collator ? i18nService.collator.compare(a[prop], b[prop]) :
                a[prop].localeCompare(b[prop]);
        };
    }
    static isNullOrWhitespace(str) {
        return str == null || typeof str !== 'string' || str.trim() === '';
    }
    static validIpAddress(ipString) {
        // tslint:disable-next-line
        const ipRegex = /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;
        return ipRegex.test(ipString);
    }
    static isMobile(win) {
        let mobile = false;
        ((a) => {
            // tslint:disable-next-line
            if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4))) {
                mobile = true;
            }
        })(win.navigator.userAgent || win.navigator.vendor || win.opera);
        return mobile || win.navigator.userAgent.match(/iPad/i) != null;
    }
    static isAppleMobile(win) {
        return win.navigator.userAgent.match(/iPhone/i) != null || win.navigator.userAgent.match(/iPad/i) != null;
    }
    static getUrl(uriString) {
        if (uriString == null) {
            return null;
        }
        uriString = uriString.trim();
        if (uriString === '') {
            return null;
        }
        let url = utils_Utils.getUrlObject(uriString);
        if (url == null) {
            const hasHttpProtocol = uriString.indexOf('http://') === 0 || uriString.indexOf('https://') === 0;
            if (!hasHttpProtocol && uriString.indexOf('.') > -1) {
                url = utils_Utils.getUrlObject('http://' + uriString);
            }
        }
        return url;
    }
    static getUrlObject(uriString) {
        try {
            if (nodeURL != null) {
                return nodeURL.URL ? new nodeURL.URL(uriString) : nodeURL.parse(uriString);
            }
            else if (typeof URL === 'function') {
                return new URL(uriString);
            }
            else if (window != null) {
                const hasProtocol = uriString.indexOf('://') > -1;
                if (!hasProtocol && uriString.indexOf('.') > -1) {
                    uriString = 'http://' + uriString;
                }
                else if (!hasProtocol) {
                    return null;
                }
                const anchor = window.document.createElement('a');
                anchor.href = uriString;
                return anchor;
            }
        }
        catch (e) { }
        return null;
    }
}
utils_Utils.inited = false;
utils_Utils.isNativeScript = false;
utils_Utils.isNode = false;
utils_Utils.isBrowser = true;
utils_Utils.isMobileBrowser = false;
utils_Utils.isAppleMobileBrowser = false;
utils_Utils.global = null;
utils_Utils.tldEndingRegex = /.*\.(com|net|org|edu|uk|gov|ca|de|jp|fr|au|ru|ch|io|es|us|co|xyz|info|ly|mil)$/;
utils_Utils.init();

// CONCATENATED MODULE: ./jslib/src/models/domain/cipherString.ts
var cipherString_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};


class cipherString_CipherString {
    constructor(encryptedStringOrType, data, iv, mac) {
        if (data != null) {
            // data and header
            const encType = encryptedStringOrType;
            if (iv != null) {
                this.encryptedString = encType + '.' + iv + '|' + data;
            }
            else {
                this.encryptedString = encType + '.' + data;
            }
            // mac
            if (mac != null) {
                this.encryptedString += ('|' + mac);
            }
            this.encryptionType = encType;
            this.data = data;
            this.iv = iv;
            this.mac = mac;
            return;
        }
        this.encryptedString = encryptedStringOrType;
        if (!this.encryptedString) {
            return;
        }
        const headerPieces = this.encryptedString.split('.');
        let encPieces = null;
        if (headerPieces.length === 2) {
            try {
                this.encryptionType = parseInt(headerPieces[0], null);
                encPieces = headerPieces[1].split('|');
            }
            catch (e) {
                return;
            }
        }
        else {
            encPieces = this.encryptedString.split('|');
            this.encryptionType = encPieces.length === 3 ? EncryptionType.AesCbc128_HmacSha256_B64 :
                EncryptionType.AesCbc256_B64;
        }
        switch (this.encryptionType) {
            case EncryptionType.AesCbc128_HmacSha256_B64:
            case EncryptionType.AesCbc256_HmacSha256_B64:
                if (encPieces.length !== 3) {
                    return;
                }
                this.iv = encPieces[0];
                this.data = encPieces[1];
                this.mac = encPieces[2];
                break;
            case EncryptionType.AesCbc256_B64:
                if (encPieces.length !== 2) {
                    return;
                }
                this.iv = encPieces[0];
                this.data = encPieces[1];
                break;
            case EncryptionType.Rsa2048_OaepSha256_B64:
            case EncryptionType.Rsa2048_OaepSha1_B64:
                if (encPieces.length !== 1) {
                    return;
                }
                this.data = encPieces[0];
                break;
            default:
                return;
        }
    }
    decrypt(orgId) {
        return cipherString_awaiter(this, void 0, void 0, function* () {
            if (this.decryptedValue != null) {
                return this.decryptedValue;
            }
            let cryptoService;
            const containerService = utils_Utils.global.bitwardenContainerService;
            if (containerService) {
                cryptoService = containerService.getCryptoService();
            }
            else {
                throw new Error('global bitwardenContainerService not initialized.');
            }
            try {
                const orgKey = yield cryptoService.getOrgKey(orgId);
                this.decryptedValue = yield cryptoService.decryptToUtf8(this, orgKey);
            }
            catch (e) {
                this.decryptedValue = '[error: cannot decrypt]';
            }
            return this.decryptedValue;
        });
    }
}

// CONCATENATED MODULE: ./jslib/src/models/domain/domainBase.ts
var domainBase_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};

class domainBase_Domain {
    buildDomainModel(domain, dataObj, map, alreadyEncrypted, notEncList = []) {
        for (const prop in map) {
            if (!map.hasOwnProperty(prop)) {
                continue;
            }
            const objProp = dataObj[(map[prop] || prop)];
            if (alreadyEncrypted === true || notEncList.indexOf(prop) > -1) {
                domain[prop] = objProp ? objProp : null;
            }
            else {
                domain[prop] = objProp ? new cipherString_CipherString(objProp) : null;
            }
        }
    }
    buildDataModel(domain, dataObj, map, notCipherStringList = []) {
        for (const prop in map) {
            if (!map.hasOwnProperty(prop)) {
                continue;
            }
            const objProp = domain[(map[prop] || prop)];
            if (notCipherStringList.indexOf(prop) > -1) {
                dataObj[prop] = objProp != null ? objProp : null;
            }
            else {
                dataObj[prop] = objProp != null ? objProp.encryptedString : null;
            }
        }
    }
    decryptObj(viewModel, map, orgId) {
        return domainBase_awaiter(this, void 0, void 0, function* () {
            const promises = [];
            const self = this;
            for (const prop in map) {
                if (!map.hasOwnProperty(prop)) {
                    continue;
                }
                // tslint:disable-next-line
                (function (theProp) {
                    const p = Promise.resolve().then(() => {
                        const mapProp = map[theProp] || theProp;
                        if (self[mapProp]) {
                            return self[mapProp].decrypt(orgId);
                        }
                        return null;
                    }).then((val) => {
                        viewModel[theProp] = val;
                    });
                    promises.push(p);
                })(prop);
            }
            yield Promise.all(promises);
            return viewModel;
        });
    }
}

// CONCATENATED MODULE: ./jslib/src/models/domain/symmetricCryptoKey.ts


class symmetricCryptoKey_SymmetricCryptoKey {
    constructor(key, encType) {
        if (key == null) {
            throw new Error('Must provide key');
        }
        if (encType == null) {
            if (key.byteLength === 32) {
                encType = EncryptionType.AesCbc256_B64;
            }
            else if (key.byteLength === 64) {
                encType = EncryptionType.AesCbc256_HmacSha256_B64;
            }
            else {
                throw new Error('Unable to determine encType.');
            }
        }
        this.key = key;
        this.encType = encType;
        if (encType === EncryptionType.AesCbc256_B64 && key.byteLength === 32) {
            this.encKey = key;
            this.macKey = null;
        }
        else if (encType === EncryptionType.AesCbc128_HmacSha256_B64 && key.byteLength === 32) {
            this.encKey = key.slice(0, 16);
            this.macKey = key.slice(16, 32);
        }
        else if (encType === EncryptionType.AesCbc256_HmacSha256_B64 && key.byteLength === 64) {
            this.encKey = key.slice(0, 32);
            this.macKey = key.slice(32, 64);
        }
        else {
            throw new Error('Unsupported encType/key length.');
        }
        if (this.key != null) {
            this.keyB64 = utils_Utils.fromBufferToB64(this.key);
        }
        if (this.encKey != null) {
            this.encKeyB64 = utils_Utils.fromBufferToB64(this.encKey);
        }
        if (this.macKey != null) {
            this.macKeyB64 = utils_Utils.fromBufferToB64(this.macKey);
        }
    }
}

// CONCATENATED MODULE: ./jslib/src/models/domain/attachment.ts
var attachment_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};





class attachment_Attachment extends domainBase_Domain {
    constructor(obj, alreadyEncrypted = false) {
        super();
        if (obj == null) {
            return;
        }
        this.size = obj.size;
        this.buildDomainModel(this, obj, {
            id: null,
            url: null,
            sizeName: null,
            fileName: null,
            key: null,
        }, alreadyEncrypted, ['id', 'url', 'sizeName']);
    }
    decrypt(orgId) {
        return attachment_awaiter(this, void 0, void 0, function* () {
            const view = yield this.decryptObj(new AttachmentView(this), {
                fileName: null,
            }, orgId);
            if (this.key != null) {
                let cryptoService;
                const containerService = utils_Utils.global.bitwardenContainerService;
                if (containerService) {
                    cryptoService = containerService.getCryptoService();
                }
                else {
                    throw new Error('global bitwardenContainerService not initialized.');
                }
                try {
                    const orgKey = yield cryptoService.getOrgKey(orgId);
                    const decValue = yield cryptoService.decryptToBytes(this.key, orgKey);
                    view.key = new symmetricCryptoKey_SymmetricCryptoKey(decValue);
                }
                catch (e) {
                    // TODO: error?
                }
            }
            return view;
        });
    }
    toAttachmentData() {
        const a = new AttachmentData();
        a.size = this.size;
        this.buildDataModel(this, a, {
            id: null,
            url: null,
            sizeName: null,
            fileName: null,
            key: null,
        }, ['id', 'url', 'sizeName']);
        return a;
    }
}

// CONCATENATED MODULE: ./jslib/src/models/data/cardData.ts
class CardData {
    constructor(data) {
        if (data == null) {
            return;
        }
        this.cardholderName = data.cardholderName;
        this.brand = data.brand;
        this.number = data.number;
        this.expMonth = data.expMonth;
        this.expYear = data.expYear;
        this.code = data.code;
    }
}

// CONCATENATED MODULE: ./jslib/src/models/view/cardView.ts
class CardView {
    // tslint:enable
    constructor(c) {
        this.cardholderName = null;
        this.expMonth = null;
        this.expYear = null;
        this.code = null;
        // tslint:disable
        this._brand = null;
        this._number = null;
        this._subTitle = null;
        // ctor
    }
    get maskedCode() {
        return this.code != null ? '•'.repeat(this.code.length) : null;
    }
    get brand() {
        return this._brand;
    }
    set brand(value) {
        this._brand = value;
        this._subTitle = null;
    }
    get number() {
        return this._number;
    }
    set number(value) {
        this._number = value;
        this._subTitle = null;
    }
    get subTitle() {
        if (this._subTitle == null) {
            this._subTitle = this.brand;
            if (this.number != null && this.number.length >= 4) {
                if (this._subTitle != null && this._subTitle !== '') {
                    this._subTitle += ', ';
                }
                else {
                    this._subTitle = '';
                }
                // Show last 5 on amex, last 4 for all others
                const count = this.number.length >= 5 && this.number.match(new RegExp('^3[47]')) != null ? 5 : 4;
                this._subTitle += ('*' + this.number.substr(this.number.length - count));
            }
        }
        return this._subTitle;
    }
    get expiration() {
        if (!this.expMonth && !this.expYear) {
            return null;
        }
        let exp = this.expMonth != null ? ('0' + this.expMonth).slice(-2) : '__';
        exp += (' / ' + (this.expYear != null ? this.formatYear(this.expYear) : '____'));
        return exp;
    }
    formatYear(year) {
        return year.length === 2 ? '20' + year : year;
    }
}

// CONCATENATED MODULE: ./jslib/src/models/domain/card.ts



class card_Card extends domainBase_Domain {
    constructor(obj, alreadyEncrypted = false) {
        super();
        if (obj == null) {
            return;
        }
        this.buildDomainModel(this, obj, {
            cardholderName: null,
            brand: null,
            number: null,
            expMonth: null,
            expYear: null,
            code: null,
        }, alreadyEncrypted, []);
    }
    decrypt(orgId) {
        return this.decryptObj(new CardView(this), {
            cardholderName: null,
            brand: null,
            number: null,
            expMonth: null,
            expYear: null,
            code: null,
        }, orgId);
    }
    toCardData() {
        const c = new CardData();
        this.buildDataModel(this, c, {
            cardholderName: null,
            brand: null,
            number: null,
            expMonth: null,
            expYear: null,
            code: null,
        });
        return c;
    }
}

// CONCATENATED MODULE: ./jslib/src/enums/cipherType.ts
var CipherType;
(function (CipherType) {
    CipherType[CipherType["Login"] = 1] = "Login";
    CipherType[CipherType["SecureNote"] = 2] = "SecureNote";
    CipherType[CipherType["Card"] = 3] = "Card";
    CipherType[CipherType["Identity"] = 4] = "Identity";
})(CipherType || (CipherType = {}));

// CONCATENATED MODULE: ./jslib/src/models/data/fieldData.ts
class FieldData {
    constructor(response) {
        if (response == null) {
            return;
        }
        this.type = response.type;
        this.name = response.name;
        this.value = response.value;
    }
}

// CONCATENATED MODULE: ./jslib/src/models/data/identityData.ts
class IdentityData {
    constructor(data) {
        if (data == null) {
            return;
        }
        this.title = data.title;
        this.firstName = data.firstName;
        this.middleName = data.middleName;
        this.lastName = data.lastName;
        this.address1 = data.address1;
        this.address2 = data.address2;
        this.address3 = data.address3;
        this.city = data.city;
        this.state = data.state;
        this.postalCode = data.postalCode;
        this.country = data.country;
        this.company = data.company;
        this.email = data.email;
        this.phone = data.phone;
        this.ssn = data.ssn;
        this.username = data.username;
        this.passportNumber = data.passportNumber;
        this.licenseNumber = data.licenseNumber;
    }
}

// CONCATENATED MODULE: ./jslib/src/models/data/loginUriData.ts
class LoginUriData {
    constructor(data) {
        this.match = null;
        if (data == null) {
            return;
        }
        this.uri = data.uri;
        this.match = data.match;
    }
}

// CONCATENATED MODULE: ./jslib/src/models/data/loginData.ts

class loginData_LoginData {
    constructor(data) {
        if (data == null) {
            return;
        }
        this.username = data.username;
        this.password = data.password;
        this.passwordRevisionDate = data.passwordRevisionDate;
        this.totp = data.totp;
        if (data.uris) {
            this.uris = data.uris.map((u) => new LoginUriData(u));
        }
    }
}

// CONCATENATED MODULE: ./jslib/src/models/data/passwordHistoryData.ts
class PasswordHistoryData {
    constructor(response) {
        if (response == null) {
            return;
        }
        this.password = response.password;
        this.lastUsedDate = response.lastUsedDate;
    }
}

// CONCATENATED MODULE: ./jslib/src/models/data/secureNoteData.ts
class SecureNoteData {
    constructor(data) {
        if (data == null) {
            return;
        }
        this.type = data.type;
    }
}

// CONCATENATED MODULE: ./jslib/src/models/data/cipherData.ts








class cipherData_CipherData {
    constructor(response, userId, collectionIds) {
        if (response == null) {
            return;
        }
        this.id = response.id;
        this.organizationId = response.organizationId;
        this.folderId = response.folderId;
        this.userId = userId;
        this.edit = response.edit;
        this.organizationUseTotp = response.organizationUseTotp;
        this.favorite = response.favorite;
        this.revisionDate = response.revisionDate;
        this.type = response.type;
        this.name = response.name;
        this.notes = response.notes;
        this.collectionIds = collectionIds != null ? collectionIds : response.collectionIds;
        this.deletedDate = response.deletedDate;
        switch (this.type) {
            case CipherType.Login:
                this.login = new loginData_LoginData(response.login);
                break;
            case CipherType.SecureNote:
                this.secureNote = new SecureNoteData(response.secureNote);
                break;
            case CipherType.Card:
                this.card = new CardData(response.card);
                break;
            case CipherType.Identity:
                this.identity = new IdentityData(response.identity);
                break;
            default:
                break;
        }
        if (response.fields != null) {
            this.fields = response.fields.map((f) => new FieldData(f));
        }
        if (response.attachments != null) {
            this.attachments = response.attachments.map((a) => new AttachmentData(a));
        }
        if (response.passwordHistory != null) {
            this.passwordHistory = response.passwordHistory.map((ph) => new PasswordHistoryData(ph));
        }
    }
}

// CONCATENATED MODULE: ./jslib/src/models/view/identityView.ts

class identityView_IdentityView {
    // tslint:enable
    constructor(i) {
        this.title = null;
        this.middleName = null;
        this.address1 = null;
        this.address2 = null;
        this.address3 = null;
        this.city = null;
        this.state = null;
        this.postalCode = null;
        this.country = null;
        this.company = null;
        this.email = null;
        this.phone = null;
        this.ssn = null;
        this.username = null;
        this.passportNumber = null;
        this.licenseNumber = null;
        // tslint:disable
        this._firstName = null;
        this._lastName = null;
        this._subTitle = null;
        // ctor
    }
    get firstName() {
        return this._firstName;
    }
    set firstName(value) {
        this._firstName = value;
        this._subTitle = null;
    }
    get lastName() {
        return this._lastName;
    }
    set lastName(value) {
        this._lastName = value;
        this._subTitle = null;
    }
    get subTitle() {
        if (this._subTitle == null && (this.firstName != null || this.lastName != null)) {
            this._subTitle = '';
            if (this.firstName != null) {
                this._subTitle = this.firstName;
            }
            if (this.lastName != null) {
                if (this._subTitle !== '') {
                    this._subTitle += ' ';
                }
                this._subTitle += this.lastName;
            }
        }
        return this._subTitle;
    }
    get fullName() {
        if (this.title != null || this.firstName != null || this.middleName != null || this.lastName != null) {
            let name = '';
            if (this.title != null) {
                name += (this.title + ' ');
            }
            if (this.firstName != null) {
                name += (this.firstName + ' ');
            }
            if (this.middleName != null) {
                name += (this.middleName + ' ');
            }
            if (this.lastName != null) {
                name += this.lastName;
            }
            return name.trim();
        }
        return null;
    }
    get fullAddress() {
        let address = this.address1;
        if (!utils_Utils.isNullOrWhitespace(this.address2)) {
            if (!utils_Utils.isNullOrWhitespace(address)) {
                address += ', ';
            }
            address += this.address2;
        }
        if (!utils_Utils.isNullOrWhitespace(this.address3)) {
            if (!utils_Utils.isNullOrWhitespace(address)) {
                address += ', ';
            }
            address += this.address3;
        }
        return address;
    }
    get fullAddressPart2() {
        if (this.city == null && this.state == null && this.postalCode == null) {
            return null;
        }
        const city = this.city || '-';
        const state = this.state;
        const postalCode = this.postalCode || '-';
        let addressPart2 = city;
        if (!utils_Utils.isNullOrWhitespace(state)) {
            addressPart2 += ', ' + state;
        }
        addressPart2 += ', ' + postalCode;
        return addressPart2;
    }
}

// CONCATENATED MODULE: ./jslib/src/models/view/loginView.ts
class LoginView {
    constructor(l) {
        this.username = null;
        this.password = null;
        this.passwordRevisionDate = null;
        this.totp = null;
        this.uris = null;
        if (!l) {
            return;
        }
        this.passwordRevisionDate = l.passwordRevisionDate;
    }
    get uri() {
        return this.hasUris ? this.uris[0].uri : null;
    }
    get maskedPassword() {
        return this.password != null ? '••••••••' : null;
    }
    get subTitle() {
        return this.username;
    }
    get canLaunch() {
        return this.hasUris && this.uris.some((u) => u.canLaunch);
    }
    get launchUri() {
        if (this.hasUris) {
            const uri = this.uris.find((u) => u.canLaunch);
            if (uri != null) {
                return uri.launchUri;
            }
        }
        return null;
    }
    get hasUris() {
        return this.uris != null && this.uris.length > 0;
    }
}

// CONCATENATED MODULE: ./jslib/src/models/view/secureNoteView.ts
class SecureNoteView {
    constructor(n) {
        this.type = null;
        if (!n) {
            return;
        }
        this.type = n.type;
    }
    get subTitle() {
        return null;
    }
}

// CONCATENATED MODULE: ./jslib/src/models/view/cipherView.ts





class cipherView_CipherView {
    constructor(c) {
        this.id = null;
        this.organizationId = null;
        this.folderId = null;
        this.name = null;
        this.notes = null;
        this.type = null;
        this.favorite = false;
        this.organizationUseTotp = false;
        this.edit = false;
        this.login = new LoginView();
        this.identity = new identityView_IdentityView();
        this.card = new CardView();
        this.secureNote = new SecureNoteView();
        this.attachments = null;
        this.fields = null;
        this.passwordHistory = null;
        this.collectionIds = null;
        this.revisionDate = null;
        this.deletedDate = null;
        if (!c) {
            return;
        }
        this.id = c.id;
        this.organizationId = c.organizationId;
        this.folderId = c.folderId;
        this.favorite = c.favorite;
        this.organizationUseTotp = c.organizationUseTotp;
        this.edit = c.edit;
        this.type = c.type;
        this.localData = c.localData;
        this.collectionIds = c.collectionIds;
        this.revisionDate = c.revisionDate;
        this.deletedDate = c.deletedDate;
    }
    get subTitle() {
        switch (this.type) {
            case CipherType.Login:
                return this.login.subTitle;
            case CipherType.SecureNote:
                return this.secureNote.subTitle;
            case CipherType.Card:
                return this.card.subTitle;
            case CipherType.Identity:
                return this.identity.subTitle;
            default:
                break;
        }
        return null;
    }
    get hasPasswordHistory() {
        return this.passwordHistory && this.passwordHistory.length > 0;
    }
    get hasAttachments() {
        return this.attachments && this.attachments.length > 0;
    }
    get hasOldAttachments() {
        if (this.hasAttachments) {
            for (let i = 0; i < this.attachments.length; i++) {
                if (this.attachments[i].key == null) {
                    return true;
                }
            }
        }
        return false;
    }
    get hasFields() {
        return this.fields && this.fields.length > 0;
    }
    get passwordRevisionDisplayDate() {
        if (this.type !== CipherType.Login || this.login == null) {
            return null;
        }
        else if (this.login.password == null || this.login.password === '') {
            return null;
        }
        return this.login.passwordRevisionDate;
    }
    get isDeleted() {
        return this.deletedDate != null;
    }
}

// CONCATENATED MODULE: ./jslib/src/models/view/fieldView.ts
class FieldView {
    constructor(f) {
        this.name = null;
        this.value = null;
        this.type = null;
        if (!f) {
            return;
        }
        this.type = f.type;
    }
    get maskedValue() {
        return this.value != null ? '••••••••' : null;
    }
}

// CONCATENATED MODULE: ./jslib/src/models/domain/field.ts



class field_Field extends domainBase_Domain {
    constructor(obj, alreadyEncrypted = false) {
        super();
        if (obj == null) {
            return;
        }
        this.type = obj.type;
        this.buildDomainModel(this, obj, {
            name: null,
            value: null,
        }, alreadyEncrypted, []);
    }
    decrypt(orgId) {
        return this.decryptObj(new FieldView(this), {
            name: null,
            value: null,
        }, orgId);
    }
    toFieldData() {
        const f = new FieldData();
        this.buildDataModel(this, f, {
            name: null,
            value: null,
            type: null,
        }, ['type']);
        return f;
    }
}

// CONCATENATED MODULE: ./jslib/src/models/domain/identity.ts



class identity_Identity extends domainBase_Domain {
    constructor(obj, alreadyEncrypted = false) {
        super();
        if (obj == null) {
            return;
        }
        this.buildDomainModel(this, obj, {
            title: null,
            firstName: null,
            middleName: null,
            lastName: null,
            address1: null,
            address2: null,
            address3: null,
            city: null,
            state: null,
            postalCode: null,
            country: null,
            company: null,
            email: null,
            phone: null,
            ssn: null,
            username: null,
            passportNumber: null,
            licenseNumber: null,
        }, alreadyEncrypted, []);
    }
    decrypt(orgId) {
        return this.decryptObj(new identityView_IdentityView(this), {
            title: null,
            firstName: null,
            middleName: null,
            lastName: null,
            address1: null,
            address2: null,
            address3: null,
            city: null,
            state: null,
            postalCode: null,
            country: null,
            company: null,
            email: null,
            phone: null,
            ssn: null,
            username: null,
            passportNumber: null,
            licenseNumber: null,
        }, orgId);
    }
    toIdentityData() {
        const i = new IdentityData();
        this.buildDataModel(this, i, {
            title: null,
            firstName: null,
            middleName: null,
            lastName: null,
            address1: null,
            address2: null,
            address3: null,
            city: null,
            state: null,
            postalCode: null,
            country: null,
            company: null,
            email: null,
            phone: null,
            ssn: null,
            username: null,
            passportNumber: null,
            licenseNumber: null,
        });
        return i;
    }
}

// CONCATENATED MODULE: ./jslib/src/enums/uriMatchType.ts
var UriMatchType;
(function (UriMatchType) {
    UriMatchType[UriMatchType["Domain"] = 0] = "Domain";
    UriMatchType[UriMatchType["Host"] = 1] = "Host";
    UriMatchType[UriMatchType["StartsWith"] = 2] = "StartsWith";
    UriMatchType[UriMatchType["Exact"] = 3] = "Exact";
    UriMatchType[UriMatchType["RegularExpression"] = 4] = "RegularExpression";
    UriMatchType[UriMatchType["Never"] = 5] = "Never";
})(UriMatchType || (UriMatchType = {}));

// CONCATENATED MODULE: ./jslib/src/models/view/loginUriView.ts


const CanLaunchWhitelist = [
    'https://',
    'http://',
    'ssh://',
    'ftp://',
    'sftp://',
    'irc://',
    'vnc://',
    'chrome://',
    'iosapp://',
    'androidapp://',
];
class loginUriView_LoginUriView {
    // tslint:enable
    constructor(u) {
        this.match = null;
        // tslint:disable
        this._uri = null;
        this._domain = null;
        this._hostname = null;
        this._canLaunch = null;
        if (!u) {
            return;
        }
        this.match = u.match;
    }
    get uri() {
        return this._uri;
    }
    set uri(value) {
        this._uri = value;
        this._domain = null;
        this._canLaunch = null;
    }
    get domain() {
        if (this._domain == null && this.uri != null) {
            this._domain = utils_Utils.getDomain(this.uri);
            if (this._domain === '') {
                this._domain = null;
            }
        }
        return this._domain;
    }
    get hostname() {
        if (this._hostname == null && this.uri != null) {
            this._hostname = utils_Utils.getHostname(this.uri);
            if (this._hostname === '') {
                this._hostname = null;
            }
        }
        return this._hostname;
    }
    get hostnameOrUri() {
        return this.hostname != null ? this.hostname : this.uri;
    }
    get isWebsite() {
        return this.uri != null && (this.uri.indexOf('http://') === 0 || this.uri.indexOf('https://') === 0 ||
            (this.uri.indexOf('://') < 0 && utils_Utils.tldEndingRegex.test(this.uri)));
    }
    get canLaunch() {
        if (this._canLaunch != null) {
            return this._canLaunch;
        }
        if (this.uri != null && this.match !== UriMatchType.RegularExpression) {
            const uri = this.launchUri;
            for (let i = 0; i < CanLaunchWhitelist.length; i++) {
                if (uri.indexOf(CanLaunchWhitelist[i]) === 0) {
                    this._canLaunch = true;
                    return this._canLaunch;
                }
            }
        }
        this._canLaunch = false;
        return this._canLaunch;
    }
    get launchUri() {
        return this.uri.indexOf('://') < 0 && utils_Utils.tldEndingRegex.test(this.uri) ? ('http://' + this.uri) : this.uri;
    }
}

// CONCATENATED MODULE: ./jslib/src/models/domain/loginUri.ts



class loginUri_LoginUri extends domainBase_Domain {
    constructor(obj, alreadyEncrypted = false) {
        super();
        if (obj == null) {
            return;
        }
        this.match = obj.match;
        this.buildDomainModel(this, obj, {
            uri: null,
        }, alreadyEncrypted, []);
    }
    decrypt(orgId) {
        return this.decryptObj(new loginUriView_LoginUriView(this), {
            uri: null,
        }, orgId);
    }
    toLoginUriData() {
        const u = new LoginUriData();
        this.buildDataModel(this, u, {
            uri: null,
        }, ['match']);
        return u;
    }
}

// CONCATENATED MODULE: ./jslib/src/models/domain/login.ts
var login_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};




class login_Login extends domainBase_Domain {
    constructor(obj, alreadyEncrypted = false) {
        super();
        if (obj == null) {
            return;
        }
        this.passwordRevisionDate = obj.passwordRevisionDate != null ? new Date(obj.passwordRevisionDate) : null;
        this.buildDomainModel(this, obj, {
            username: null,
            password: null,
            totp: null,
        }, alreadyEncrypted, []);
        if (obj.uris) {
            this.uris = [];
            obj.uris.forEach((u) => {
                this.uris.push(new loginUri_LoginUri(u, alreadyEncrypted));
            });
        }
    }
    decrypt(orgId) {
        return login_awaiter(this, void 0, void 0, function* () {
            const view = yield this.decryptObj(new LoginView(this), {
                username: null,
                password: null,
                totp: null,
            }, orgId);
            if (this.uris != null) {
                view.uris = [];
                for (let i = 0; i < this.uris.length; i++) {
                    const uri = yield this.uris[i].decrypt(orgId);
                    view.uris.push(uri);
                }
            }
            return view;
        });
    }
    toLoginData() {
        const l = new loginData_LoginData();
        l.passwordRevisionDate = this.passwordRevisionDate != null ? this.passwordRevisionDate.toISOString() : null;
        this.buildDataModel(this, l, {
            username: null,
            password: null,
            totp: null,
        });
        if (this.uris != null && this.uris.length > 0) {
            l.uris = [];
            this.uris.forEach((u) => {
                l.uris.push(u.toLoginUriData());
            });
        }
        return l;
    }
}

// CONCATENATED MODULE: ./jslib/src/models/view/passwordHistoryView.ts
class PasswordHistoryView {
    constructor(ph) {
        this.password = null;
        this.lastUsedDate = null;
        if (!ph) {
            return;
        }
        this.lastUsedDate = ph.lastUsedDate;
    }
}

// CONCATENATED MODULE: ./jslib/src/models/domain/password.ts



class password_Password extends domainBase_Domain {
    constructor(obj, alreadyEncrypted = false) {
        super();
        if (obj == null) {
            return;
        }
        this.buildDomainModel(this, obj, {
            password: null,
        }, alreadyEncrypted);
        this.lastUsedDate = new Date(obj.lastUsedDate);
    }
    decrypt(orgId) {
        return this.decryptObj(new PasswordHistoryView(this), {
            password: null,
        }, orgId);
    }
    toPasswordHistoryData() {
        const ph = new PasswordHistoryData();
        ph.lastUsedDate = this.lastUsedDate.toISOString();
        this.buildDataModel(this, ph, {
            password: null,
        });
        return ph;
    }
}

// CONCATENATED MODULE: ./jslib/src/models/domain/secureNote.ts



class secureNote_SecureNote extends domainBase_Domain {
    constructor(obj, alreadyEncrypted = false) {
        super();
        if (obj == null) {
            return;
        }
        this.type = obj.type;
    }
    decrypt(orgId) {
        return Promise.resolve(new SecureNoteView(this));
    }
    toSecureNoteData() {
        const n = new SecureNoteData();
        n.type = this.type;
        return n;
    }
}

// CONCATENATED MODULE: ./jslib/src/models/domain/cipher.ts
var cipher_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};











class cipher_Cipher extends domainBase_Domain {
    constructor(obj, alreadyEncrypted = false, localData = null) {
        super();
        if (obj == null) {
            return;
        }
        this.buildDomainModel(this, obj, {
            id: null,
            userId: null,
            organizationId: null,
            folderId: null,
            name: null,
            notes: null,
        }, alreadyEncrypted, ['id', 'userId', 'organizationId', 'folderId']);
        this.type = obj.type;
        this.favorite = obj.favorite;
        this.organizationUseTotp = obj.organizationUseTotp;
        this.edit = obj.edit;
        this.revisionDate = obj.revisionDate != null ? new Date(obj.revisionDate) : null;
        this.collectionIds = obj.collectionIds;
        this.localData = localData;
        this.deletedDate = obj.deletedDate != null ? new Date(obj.deletedDate) : null;
        switch (this.type) {
            case CipherType.Login:
                this.login = new login_Login(obj.login, alreadyEncrypted);
                break;
            case CipherType.SecureNote:
                this.secureNote = new secureNote_SecureNote(obj.secureNote, alreadyEncrypted);
                break;
            case CipherType.Card:
                this.card = new card_Card(obj.card, alreadyEncrypted);
                break;
            case CipherType.Identity:
                this.identity = new identity_Identity(obj.identity, alreadyEncrypted);
                break;
            default:
                break;
        }
        if (obj.attachments != null) {
            this.attachments = obj.attachments.map((a) => new attachment_Attachment(a, alreadyEncrypted));
        }
        else {
            this.attachments = null;
        }
        if (obj.fields != null) {
            this.fields = obj.fields.map((f) => new field_Field(f, alreadyEncrypted));
        }
        else {
            this.fields = null;
        }
        if (obj.passwordHistory != null) {
            this.passwordHistory = obj.passwordHistory.map((ph) => new password_Password(ph, alreadyEncrypted));
        }
        else {
            this.passwordHistory = null;
        }
    }
    decrypt() {
        return cipher_awaiter(this, void 0, void 0, function* () {
            const model = new cipherView_CipherView(this);
            yield this.decryptObj(model, {
                name: null,
                notes: null,
            }, this.organizationId);
            switch (this.type) {
                case CipherType.Login:
                    model.login = yield this.login.decrypt(this.organizationId);
                    break;
                case CipherType.SecureNote:
                    model.secureNote = yield this.secureNote.decrypt(this.organizationId);
                    break;
                case CipherType.Card:
                    model.card = yield this.card.decrypt(this.organizationId);
                    break;
                case CipherType.Identity:
                    model.identity = yield this.identity.decrypt(this.organizationId);
                    break;
                default:
                    break;
            }
            const orgId = this.organizationId;
            if (this.attachments != null && this.attachments.length > 0) {
                const attachments = [];
                yield this.attachments.reduce((promise, attachment) => {
                    return promise.then(() => {
                        return attachment.decrypt(orgId);
                    }).then((decAttachment) => {
                        attachments.push(decAttachment);
                    });
                }, Promise.resolve());
                model.attachments = attachments;
            }
            if (this.fields != null && this.fields.length > 0) {
                const fields = [];
                yield this.fields.reduce((promise, field) => {
                    return promise.then(() => {
                        return field.decrypt(orgId);
                    }).then((decField) => {
                        fields.push(decField);
                    });
                }, Promise.resolve());
                model.fields = fields;
            }
            if (this.passwordHistory != null && this.passwordHistory.length > 0) {
                const passwordHistory = [];
                yield this.passwordHistory.reduce((promise, ph) => {
                    return promise.then(() => {
                        return ph.decrypt(orgId);
                    }).then((decPh) => {
                        passwordHistory.push(decPh);
                    });
                }, Promise.resolve());
                model.passwordHistory = passwordHistory;
            }
            return model;
        });
    }
    toCipherData(userId) {
        const c = new cipherData_CipherData();
        c.id = this.id;
        c.organizationId = this.organizationId;
        c.folderId = this.folderId;
        c.userId = this.organizationId != null ? userId : null;
        c.edit = this.edit;
        c.organizationUseTotp = this.organizationUseTotp;
        c.favorite = this.favorite;
        c.revisionDate = this.revisionDate != null ? this.revisionDate.toISOString() : null;
        c.type = this.type;
        c.collectionIds = this.collectionIds;
        c.deletedDate = this.deletedDate != null ? this.deletedDate.toISOString() : null;
        this.buildDataModel(this, c, {
            name: null,
            notes: null,
        });
        switch (c.type) {
            case CipherType.Login:
                c.login = this.login.toLoginData();
                break;
            case CipherType.SecureNote:
                c.secureNote = this.secureNote.toSecureNoteData();
                break;
            case CipherType.Card:
                c.card = this.card.toCardData();
                break;
            case CipherType.Identity:
                c.identity = this.identity.toIdentityData();
                break;
            default:
                break;
        }
        if (this.fields != null) {
            c.fields = this.fields.map((f) => f.toFieldData());
        }
        if (this.attachments != null) {
            c.attachments = this.attachments.map((a) => a.toAttachmentData());
        }
        if (this.passwordHistory != null) {
            c.passwordHistory = this.passwordHistory.map((ph) => ph.toPasswordHistoryData());
        }
        return c;
    }
}

// CONCATENATED MODULE: ./jslib/src/models/view/collectionView.ts

class collectionView_CollectionView {
    constructor(c) {
        this.id = null;
        this.organizationId = null;
        this.name = null;
        this.externalId = null;
        this.readOnly = null;
        if (!c) {
            return;
        }
        this.id = c.id;
        this.organizationId = c.organizationId;
        this.externalId = c.externalId;
        if (c instanceof collection_Collection) {
            this.readOnly = c.readOnly;
        }
    }
}

// CONCATENATED MODULE: ./jslib/src/models/domain/collection.ts


class collection_Collection extends domainBase_Domain {
    constructor(obj, alreadyEncrypted = false) {
        super();
        if (obj == null) {
            return;
        }
        this.buildDomainModel(this, obj, {
            id: null,
            organizationId: null,
            name: null,
            externalId: null,
            readOnly: null,
        }, alreadyEncrypted, ['id', 'organizationId', 'externalId', 'readOnly']);
    }
    decrypt() {
        return this.decryptObj(new collectionView_CollectionView(this), {
            name: null,
        }, this.organizationId);
    }
}

// CONCATENATED MODULE: ./jslib/src/models/domain/encryptedObject.ts
class EncryptedObject {
}

// CONCATENATED MODULE: ./jslib/src/models/domain/environmentUrls.ts
class EnvironmentUrls {
}

// CONCATENATED MODULE: ./jslib/src/models/view/folderView.ts
class FolderView {
    constructor(f) {
        this.id = null;
        this.name = null;
        this.revisionDate = null;
        if (!f) {
            return;
        }
        this.id = f.id;
        this.revisionDate = f.revisionDate;
    }
}

// CONCATENATED MODULE: ./jslib/src/models/domain/folder.ts


class folder_Folder extends domainBase_Domain {
    constructor(obj, alreadyEncrypted = false) {
        super();
        if (obj == null) {
            return;
        }
        this.buildDomainModel(this, obj, {
            id: null,
            name: null,
        }, alreadyEncrypted, ['id']);
        this.revisionDate = obj.revisionDate != null ? new Date(obj.revisionDate) : null;
    }
    decrypt() {
        return this.decryptObj(new FolderView(this), {
            name: null,
        }, null);
    }
}

// CONCATENATED MODULE: ./jslib/src/models/domain/generatedPasswordHistory.ts
class GeneratedPasswordHistory {
    constructor(password, date) {
        this.password = password;
        this.date = date;
    }
}

// CONCATENATED MODULE: ./jslib/src/models/domain/index.ts

















// CONCATENATED MODULE: ./src/services/nodeEnvSecureStorage.service.ts
var nodeEnvSecureStorage_service_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};


class nodeEnvSecureStorage_service_NodeEnvSecureStorageService {
    constructor(storageService, cryptoService) {
        this.storageService = storageService;
        this.cryptoService = cryptoService;
    }
    get(key) {
        return nodeEnvSecureStorage_service_awaiter(this, void 0, void 0, function* () {
            const value = yield this.storageService.get(this.makeProtectedStorageKey(key));
            if (value == null) {
                return null;
            }
            const obj = yield this.decrypt(value);
            return obj;
        });
    }
    save(key, obj) {
        return nodeEnvSecureStorage_service_awaiter(this, void 0, void 0, function* () {
            if (typeof (obj) !== 'string') {
                throw new Error('Only string storage is allowed.');
            }
            const protectedObj = yield this.encrypt(obj);
            yield this.storageService.save(this.makeProtectedStorageKey(key), protectedObj);
        });
    }
    remove(key) {
        return this.storageService.remove(this.makeProtectedStorageKey(key));
    }
    encrypt(plainValue) {
        return nodeEnvSecureStorage_service_awaiter(this, void 0, void 0, function* () {
            const sessionKey = this.getSessionKey();
            if (sessionKey == null) {
                throw new Error('No session key available.');
            }
            const encValue = yield this.cryptoService().encryptToBytes(utils_Utils.fromB64ToArray(plainValue).buffer, sessionKey);
            if (encValue == null) {
                throw new Error('Value didn\'t encrypt.');
            }
            return utils_Utils.fromBufferToB64(encValue);
        });
    }
    decrypt(encValue) {
        return nodeEnvSecureStorage_service_awaiter(this, void 0, void 0, function* () {
            try {
                const sessionKey = this.getSessionKey();
                if (sessionKey == null) {
                    return null;
                }
                const decValue = yield this.cryptoService().decryptFromBytes(utils_Utils.fromB64ToArray(encValue).buffer, sessionKey);
                if (decValue == null) {
                    // tslint:disable-next-line
                    console.log('Failed to decrypt.');
                    return null;
                }
                return utils_Utils.fromBufferToB64(decValue);
            }
            catch (e) {
                // tslint:disable-next-line
                console.log('Decrypt error.');
                return null;
            }
        });
    }
    getSessionKey() {
        try {
            if (process.env.BW_SESSION != null) {
                const sessionBuffer = utils_Utils.fromB64ToArray(process.env.BW_SESSION).buffer;
                if (sessionBuffer != null) {
                    const sessionKey = new symmetricCryptoKey_SymmetricCryptoKey(sessionBuffer);
                    if (sessionBuffer != null) {
                        return sessionKey;
                    }
                }
            }
        }
        catch (e) {
            // tslint:disable-next-line
            console.log('Session key is invalid.');
        }
        return null;
    }
    makeProtectedStorageKey(key) {
        return '__PROTECTED__' + key;
    }
}

// CONCATENATED MODULE: ./jslib/src/enums/deviceType.ts
var DeviceType;
(function (DeviceType) {
    DeviceType[DeviceType["Android"] = 0] = "Android";
    DeviceType[DeviceType["iOS"] = 1] = "iOS";
    DeviceType[DeviceType["ChromeExtension"] = 2] = "ChromeExtension";
    DeviceType[DeviceType["FirefoxExtension"] = 3] = "FirefoxExtension";
    DeviceType[DeviceType["OperaExtension"] = 4] = "OperaExtension";
    DeviceType[DeviceType["EdgeExtension"] = 5] = "EdgeExtension";
    DeviceType[DeviceType["WindowsDesktop"] = 6] = "WindowsDesktop";
    DeviceType[DeviceType["MacOsDesktop"] = 7] = "MacOsDesktop";
    DeviceType[DeviceType["LinuxDesktop"] = 8] = "LinuxDesktop";
    DeviceType[DeviceType["ChromeBrowser"] = 9] = "ChromeBrowser";
    DeviceType[DeviceType["FirefoxBrowser"] = 10] = "FirefoxBrowser";
    DeviceType[DeviceType["OperaBrowser"] = 11] = "OperaBrowser";
    DeviceType[DeviceType["EdgeBrowser"] = 12] = "EdgeBrowser";
    DeviceType[DeviceType["IEBrowser"] = 13] = "IEBrowser";
    DeviceType[DeviceType["UnknownBrowser"] = 14] = "UnknownBrowser";
    DeviceType[DeviceType["AndroidAmazon"] = 15] = "AndroidAmazon";
    DeviceType[DeviceType["UWP"] = 16] = "UWP";
    DeviceType[DeviceType["SafariBrowser"] = 17] = "SafariBrowser";
    DeviceType[DeviceType["VivaldiBrowser"] = 18] = "VivaldiBrowser";
    DeviceType[DeviceType["VivaldiExtension"] = 19] = "VivaldiExtension";
    DeviceType[DeviceType["SafariExtension"] = 20] = "SafariExtension";
})(DeviceType || (DeviceType = {}));

// CONCATENATED MODULE: ./jslib/src/cli/services/cliPlatformUtils.service.ts

class cliPlatformUtils_service_CliPlatformUtilsService {
    constructor(identityClientId, packageJson) {
        this.packageJson = packageJson;
        this.deviceCache = null;
        this.identityClientId = identityClientId;
    }
    getDevice() {
        if (!this.deviceCache) {
            switch (process.platform) {
                case 'win32':
                    this.deviceCache = DeviceType.WindowsDesktop;
                    break;
                case 'darwin':
                    this.deviceCache = DeviceType.MacOsDesktop;
                    break;
                case 'linux':
                default:
                    this.deviceCache = DeviceType.LinuxDesktop;
                    break;
            }
        }
        return this.deviceCache;
    }
    getDeviceString() {
        const device = DeviceType[this.getDevice()].toLowerCase();
        return device.replace('desktop', '');
    }
    isFirefox() {
        return false;
    }
    isChrome() {
        return false;
    }
    isEdge() {
        return false;
    }
    isOpera() {
        return false;
    }
    isVivaldi() {
        return false;
    }
    isSafari() {
        return false;
    }
    isIE() {
        return false;
    }
    isMacAppStore() {
        return false;
    }
    analyticsId() {
        return null;
    }
    isViewOpen() {
        return Promise.resolve(false);
    }
    lockTimeout() {
        return null;
    }
    launchUri(uri, options) {
        throw new Error('Not implemented.');
    }
    saveFile(win, blobData, blobOptions, fileName) {
        throw new Error('Not implemented.');
    }
    getApplicationVersion() {
        return this.packageJson.version;
    }
    supportsU2f(win) {
        return false;
    }
    supportsDuo() {
        return false;
    }
    showToast(type, title, text, options) {
        throw new Error('Not implemented.');
    }
    showDialog(text, title, confirmText, cancelText, type) {
        throw new Error('Not implemented.');
    }
    eventTrack(action, label, options) {
        throw new Error('Not implemented.');
    }
    isDev() {
        return "production" === 'development';
    }
    isSelfHost() {
        return false;
    }
    copyToClipboard(text, options) {
        throw new Error('Not implemented.');
    }
    readFromClipboard(options) {
        throw new Error('Not implemented.');
    }
}

// CONCATENATED MODULE: ./jslib/src/services/appId.service.ts
var appId_service_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};

class appId_service_AppIdService {
    constructor(storageService) {
        this.storageService = storageService;
    }
    getAppId() {
        return this.makeAndGetAppId('appId');
    }
    getAnonymousAppId() {
        return this.makeAndGetAppId('anonymousAppId');
    }
    makeAndGetAppId(key) {
        return appId_service_awaiter(this, void 0, void 0, function* () {
            const existingId = yield this.storageService.get(key);
            if (existingId != null) {
                return existingId;
            }
            const guid = utils_Utils.newGuid();
            yield this.storageService.save(key, guid);
            return guid;
        });
    }
}

// CONCATENATED MODULE: ./jslib/src/misc/throttle.ts
/**
 * Use as a Decorator on async functions, it will limit how many times the function can be
 * in-flight at a time.
 *
 * Calls beyond the limit will be queued, and run when one of the active calls finishes
 */
function throttle(limit, throttleKey) {
    return (target, propertyKey, descriptor) => {
        const originalMethod = descriptor.value;
        const allThrottles = new Map();
        const getThrottles = (obj) => {
            let throttles = allThrottles.get(obj);
            if (throttles != null) {
                return throttles;
            }
            throttles = new Map();
            allThrottles.set(obj, throttles);
            return throttles;
        };
        return {
            value: function (...args) {
                const throttles = getThrottles(this);
                const argsThrottleKey = throttleKey(args);
                let queue = throttles.get(argsThrottleKey);
                if (queue == null) {
                    queue = [];
                    throttles.set(argsThrottleKey, queue);
                }
                return new Promise((resolve, reject) => {
                    const exec = () => {
                        const onFinally = () => {
                            queue.splice(queue.indexOf(exec), 1);
                            if (queue.length >= limit) {
                                queue[limit - 1]();
                            }
                            else if (queue.length === 0) {
                                throttles.delete(argsThrottleKey);
                                if (throttles.size === 0) {
                                    allThrottles.delete(this);
                                }
                            }
                        };
                        originalMethod.apply(this, args).then((val) => {
                            onFinally();
                            return val;
                        }).catch((err) => {
                            onFinally();
                            throw err;
                        }).then(resolve, reject);
                    };
                    queue.push(exec);
                    if (queue.length <= limit) {
                        exec();
                    }
                });
            },
        };
    };
}

// CONCATENATED MODULE: ./jslib/src/services/audit.service.ts
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var audit_service_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};


const PwnedPasswordsApi = 'https://api.pwnedpasswords.com/range/';
class audit_service_AuditService {
    constructor(cryptoFunctionService, apiService) {
        this.cryptoFunctionService = cryptoFunctionService;
        this.apiService = apiService;
    }
    passwordLeaked(password) {
        return audit_service_awaiter(this, void 0, void 0, function* () {
            const hashBytes = yield this.cryptoFunctionService.hash(password, 'sha1');
            const hash = utils_Utils.fromBufferToHex(hashBytes).toUpperCase();
            const hashStart = hash.substr(0, 5);
            const hashEnding = hash.substr(5);
            const response = yield this.apiService.nativeFetch(new Request(PwnedPasswordsApi + hashStart));
            const leakedHashes = yield response.text();
            const match = leakedHashes.split(/\r?\n/).find((v) => {
                return v.split(':')[0] === hashEnding;
            });
            return match != null ? parseInt(match.split(':')[1], 10) : 0;
        });
    }
    breachedAccounts(username) {
        return audit_service_awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.apiService.getHibpBreach(username);
            }
            catch (e) {
                const error = e;
                if (error.statusCode === 404) {
                    return [];
                }
                throw new Error();
            }
        });
    }
}
__decorate([
    throttle(100, () => 'passwordLeaked'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], audit_service_AuditService.prototype, "passwordLeaked", null);

// CONCATENATED MODULE: ./jslib/src/enums/fieldType.ts
var FieldType;
(function (FieldType) {
    FieldType[FieldType["Text"] = 0] = "Text";
    FieldType[FieldType["Hidden"] = 1] = "Hidden";
    FieldType[FieldType["Boolean"] = 2] = "Boolean";
})(FieldType || (FieldType = {}));

// CONCATENATED MODULE: ./jslib/src/models/request/cipherBulkDeleteRequest.ts
class CipherBulkDeleteRequest {
    constructor(ids) {
        this.ids = ids == null ? [] : ids;
    }
}

// CONCATENATED MODULE: ./jslib/src/models/request/cipherBulkMoveRequest.ts
class CipherBulkMoveRequest {
    constructor(ids, folderId) {
        this.ids = ids == null ? [] : ids;
        this.folderId = folderId;
    }
}

// CONCATENATED MODULE: ./jslib/src/models/request/cipherBulkRestoreRequest.ts
class CipherBulkRestoreRequest {
    constructor(ids) {
        this.ids = ids == null ? [] : ids;
    }
}

// CONCATENATED MODULE: ./jslib/src/models/response/baseResponse.ts
class BaseResponse {
    constructor(response) {
        this.response = response;
    }
    getResponseProperty(propertyName, response = null, exactName = false) {
        if (propertyName == null || propertyName === '') {
            throw new Error('propertyName must not be null/empty.');
        }
        if (response == null && this.response != null) {
            response = this.response;
        }
        if (response == null) {
            return null;
        }
        if (!exactName && response[propertyName] === undefined) {
            let otherCasePropertyName = null;
            if (propertyName.charAt(0) === propertyName.charAt(0).toUpperCase()) {
                otherCasePropertyName = propertyName.charAt(0).toLowerCase();
            }
            else {
                otherCasePropertyName = propertyName.charAt(0).toUpperCase();
            }
            if (propertyName.length > 1) {
                otherCasePropertyName += propertyName.slice(1);
            }
            propertyName = otherCasePropertyName;
            if (response[propertyName] === undefined) {
                propertyName = propertyName.toLowerCase();
            }
            if (response[propertyName] === undefined) {
                propertyName = propertyName.toUpperCase();
            }
        }
        return response[propertyName];
    }
}

// CONCATENATED MODULE: ./jslib/src/models/api/cardApi.ts

class cardApi_CardApi extends BaseResponse {
    constructor(data = null) {
        super(data);
        if (data == null) {
            return;
        }
        this.cardholderName = this.getResponseProperty('CardholderName');
        this.brand = this.getResponseProperty('Brand');
        this.number = this.getResponseProperty('Number');
        this.expMonth = this.getResponseProperty('ExpMonth');
        this.expYear = this.getResponseProperty('ExpYear');
        this.code = this.getResponseProperty('Code');
    }
}

// CONCATENATED MODULE: ./jslib/src/models/api/fieldApi.ts

class fieldApi_FieldApi extends BaseResponse {
    constructor(data = null) {
        super(data);
        if (data == null) {
            return;
        }
        this.type = this.getResponseProperty('Type');
        this.name = this.getResponseProperty('Name');
        this.value = this.getResponseProperty('Value');
    }
}

// CONCATENATED MODULE: ./jslib/src/models/api/identityApi.ts

class identityApi_IdentityApi extends BaseResponse {
    constructor(data = null) {
        super(data);
        if (data == null) {
            return;
        }
        this.title = this.getResponseProperty('Title');
        this.firstName = this.getResponseProperty('FirstName');
        this.middleName = this.getResponseProperty('MiddleName');
        this.lastName = this.getResponseProperty('LastName');
        this.address1 = this.getResponseProperty('Address1');
        this.address2 = this.getResponseProperty('Address2');
        this.address3 = this.getResponseProperty('Address3');
        this.city = this.getResponseProperty('City');
        this.state = this.getResponseProperty('State');
        this.postalCode = this.getResponseProperty('PostalCode');
        this.country = this.getResponseProperty('Country');
        this.company = this.getResponseProperty('Company');
        this.email = this.getResponseProperty('Email');
        this.phone = this.getResponseProperty('Phone');
        this.ssn = this.getResponseProperty('SSN');
        this.username = this.getResponseProperty('Username');
        this.passportNumber = this.getResponseProperty('PassportNumber');
        this.licenseNumber = this.getResponseProperty('LicenseNumber');
    }
}

// CONCATENATED MODULE: ./jslib/src/models/api/loginUriApi.ts

class loginUriApi_LoginUriApi extends BaseResponse {
    constructor(data = null) {
        super(data);
        this.match = null;
        if (data == null) {
            return;
        }
        this.uri = this.getResponseProperty('Uri');
        const match = this.getResponseProperty('Match');
        this.match = match != null ? match : null;
    }
}

// CONCATENATED MODULE: ./jslib/src/models/api/loginApi.ts


class loginApi_LoginApi extends BaseResponse {
    constructor(data = null) {
        super(data);
        if (data == null) {
            return;
        }
        this.username = this.getResponseProperty('Username');
        this.password = this.getResponseProperty('Password');
        this.passwordRevisionDate = this.getResponseProperty('PasswordRevisionDate');
        this.totp = this.getResponseProperty('Totp');
        const uris = this.getResponseProperty('Uris');
        if (uris != null) {
            this.uris = uris.map((u) => new loginUriApi_LoginUriApi(u));
        }
    }
}

// CONCATENATED MODULE: ./jslib/src/models/api/secureNoteApi.ts

class secureNoteApi_SecureNoteApi extends BaseResponse {
    constructor(data = null) {
        super(data);
        if (data == null) {
            return;
        }
        this.type = this.getResponseProperty('Type');
    }
}

// CONCATENATED MODULE: ./jslib/src/models/request/attachmentRequest.ts
class AttachmentRequest {
}

// CONCATENATED MODULE: ./jslib/src/models/request/cipherRequest.ts








class cipherRequest_CipherRequest {
    constructor(cipher) {
        this.type = cipher.type;
        this.folderId = cipher.folderId;
        this.organizationId = cipher.organizationId;
        this.name = cipher.name ? cipher.name.encryptedString : null;
        this.notes = cipher.notes ? cipher.notes.encryptedString : null;
        this.favorite = cipher.favorite;
        switch (this.type) {
            case CipherType.Login:
                this.login = new loginApi_LoginApi();
                this.login.uris = null;
                this.login.username = cipher.login.username ? cipher.login.username.encryptedString : null;
                this.login.password = cipher.login.password ? cipher.login.password.encryptedString : null;
                this.login.passwordRevisionDate = cipher.login.passwordRevisionDate != null ?
                    cipher.login.passwordRevisionDate.toISOString() : null;
                this.login.totp = cipher.login.totp ? cipher.login.totp.encryptedString : null;
                if (cipher.login.uris != null) {
                    this.login.uris = cipher.login.uris.map((u) => {
                        const uri = new loginUriApi_LoginUriApi();
                        uri.uri = u.uri != null ? u.uri.encryptedString : null;
                        uri.match = u.match != null ? u.match : null;
                        return uri;
                    });
                }
                break;
            case CipherType.SecureNote:
                this.secureNote = new secureNoteApi_SecureNoteApi();
                this.secureNote.type = cipher.secureNote.type;
                break;
            case CipherType.Card:
                this.card = new cardApi_CardApi();
                this.card.cardholderName = cipher.card.cardholderName != null ?
                    cipher.card.cardholderName.encryptedString : null;
                this.card.brand = cipher.card.brand != null ? cipher.card.brand.encryptedString : null;
                this.card.number = cipher.card.number != null ? cipher.card.number.encryptedString : null;
                this.card.expMonth = cipher.card.expMonth != null ? cipher.card.expMonth.encryptedString : null;
                this.card.expYear = cipher.card.expYear != null ? cipher.card.expYear.encryptedString : null;
                this.card.code = cipher.card.code != null ? cipher.card.code.encryptedString : null;
                break;
            case CipherType.Identity:
                this.identity = new identityApi_IdentityApi();
                this.identity.title = cipher.identity.title != null ? cipher.identity.title.encryptedString : null;
                this.identity.firstName = cipher.identity.firstName != null ?
                    cipher.identity.firstName.encryptedString : null;
                this.identity.middleName = cipher.identity.middleName != null ?
                    cipher.identity.middleName.encryptedString : null;
                this.identity.lastName = cipher.identity.lastName != null ?
                    cipher.identity.lastName.encryptedString : null;
                this.identity.address1 = cipher.identity.address1 != null ?
                    cipher.identity.address1.encryptedString : null;
                this.identity.address2 = cipher.identity.address2 != null ?
                    cipher.identity.address2.encryptedString : null;
                this.identity.address3 = cipher.identity.address3 != null ?
                    cipher.identity.address3.encryptedString : null;
                this.identity.city = cipher.identity.city != null ? cipher.identity.city.encryptedString : null;
                this.identity.state = cipher.identity.state != null ? cipher.identity.state.encryptedString : null;
                this.identity.postalCode = cipher.identity.postalCode != null ?
                    cipher.identity.postalCode.encryptedString : null;
                this.identity.country = cipher.identity.country != null ?
                    cipher.identity.country.encryptedString : null;
                this.identity.company = cipher.identity.company != null ?
                    cipher.identity.company.encryptedString : null;
                this.identity.email = cipher.identity.email != null ? cipher.identity.email.encryptedString : null;
                this.identity.phone = cipher.identity.phone != null ? cipher.identity.phone.encryptedString : null;
                this.identity.ssn = cipher.identity.ssn != null ? cipher.identity.ssn.encryptedString : null;
                this.identity.username = cipher.identity.username != null ?
                    cipher.identity.username.encryptedString : null;
                this.identity.passportNumber = cipher.identity.passportNumber != null ?
                    cipher.identity.passportNumber.encryptedString : null;
                this.identity.licenseNumber = cipher.identity.licenseNumber != null ?
                    cipher.identity.licenseNumber.encryptedString : null;
                break;
            default:
                break;
        }
        if (cipher.fields != null) {
            this.fields = cipher.fields.map((f) => {
                const field = new fieldApi_FieldApi();
                field.type = f.type;
                field.name = f.name ? f.name.encryptedString : null;
                field.value = f.value ? f.value.encryptedString : null;
                return field;
            });
        }
        if (cipher.passwordHistory != null) {
            this.passwordHistory = [];
            cipher.passwordHistory.forEach((ph) => {
                this.passwordHistory.push({
                    lastUsedDate: ph.lastUsedDate,
                    password: ph.password ? ph.password.encryptedString : null,
                });
            });
        }
        if (cipher.attachments != null) {
            this.attachments = {};
            this.attachments2 = {};
            cipher.attachments.forEach((attachment) => {
                const fileName = attachment.fileName ? attachment.fileName.encryptedString : null;
                this.attachments[attachment.id] = fileName;
                const attachmentRequest = new AttachmentRequest();
                attachmentRequest.fileName = fileName;
                if (attachment.key != null) {
                    attachmentRequest.key = attachment.key.encryptedString;
                }
                this.attachments2[attachment.id] = attachmentRequest;
            });
        }
    }
}

// CONCATENATED MODULE: ./jslib/src/models/request/cipherWithIdRequest.ts

class cipherWithIdRequest_CipherWithIdRequest extends cipherRequest_CipherRequest {
    constructor(cipher) {
        super(cipher);
        this.id = cipher.id;
    }
}

// CONCATENATED MODULE: ./jslib/src/models/request/cipherBulkShareRequest.ts

class cipherBulkShareRequest_CipherBulkShareRequest {
    constructor(ciphers, collectionIds) {
        if (ciphers != null) {
            this.ciphers = [];
            ciphers.forEach((c) => {
                this.ciphers.push(new cipherWithIdRequest_CipherWithIdRequest(c));
            });
        }
        this.collectionIds = collectionIds;
    }
}

// CONCATENATED MODULE: ./jslib/src/models/request/cipherCollectionsRequest.ts
class CipherCollectionsRequest {
    constructor(collectionIds) {
        this.collectionIds = collectionIds == null ? [] : collectionIds;
    }
}

// CONCATENATED MODULE: ./jslib/src/models/request/cipherCreateRequest.ts

class cipherCreateRequest_CipherCreateRequest {
    constructor(cipher) {
        this.cipher = new cipherRequest_CipherRequest(cipher);
        this.collectionIds = cipher.collectionIds;
    }
}

// CONCATENATED MODULE: ./jslib/src/models/request/cipherShareRequest.ts

class cipherShareRequest_CipherShareRequest {
    constructor(cipher) {
        this.cipher = new cipherRequest_CipherRequest(cipher);
        this.collectionIds = cipher.collectionIds;
    }
}

// CONCATENATED MODULE: ./jslib/src/services/constants.service.ts
class ConstantsService {
    constructor() {
        this.environmentUrlsKey = ConstantsService.environmentUrlsKey;
        this.disableGaKey = ConstantsService.disableGaKey;
        this.disableAddLoginNotificationKey = ConstantsService.disableAddLoginNotificationKey;
        this.disableContextMenuItemKey = ConstantsService.disableContextMenuItemKey;
        this.disableFaviconKey = ConstantsService.disableFaviconKey;
        this.disableAutoTotpCopyKey = ConstantsService.disableAutoTotpCopyKey;
        this.enableAutoFillOnPageLoadKey = ConstantsService.enableAutoFillOnPageLoadKey;
        this.vaultTimeoutKey = ConstantsService.vaultTimeoutKey;
        this.vaultTimeoutActionKey = ConstantsService.vaultTimeoutActionKey;
        this.lastActiveKey = ConstantsService.lastActiveKey;
        this.neverDomainsKey = ConstantsService.neverDomainsKey;
        this.installedVersionKey = ConstantsService.installedVersionKey;
        this.localeKey = ConstantsService.localeKey;
        this.themeKey = ConstantsService.themeKey;
        this.collapsedGroupingsKey = ConstantsService.collapsedGroupingsKey;
        this.autoConfirmFingerprints = ConstantsService.autoConfirmFingerprints;
        this.dontShowCardsCurrentTab = ConstantsService.dontShowCardsCurrentTab;
        this.dontShowIdentitiesCurrentTab = ConstantsService.dontShowIdentitiesCurrentTab;
        this.defaultUriMatch = ConstantsService.defaultUriMatch;
        this.pinProtectedKey = ConstantsService.pinProtectedKey;
        this.protectedPin = ConstantsService.protectedPin;
        this.clearClipboardKey = ConstantsService.clearClipboardKey;
        this.eventCollectionKey = ConstantsService.eventCollectionKey;
    }
}
ConstantsService.environmentUrlsKey = 'environmentUrls';
ConstantsService.disableGaKey = 'disableGa';
ConstantsService.disableAddLoginNotificationKey = 'disableAddLoginNotification';
ConstantsService.disableChangedPasswordNotificationKey = 'disableChangedPasswordNotification';
ConstantsService.disableContextMenuItemKey = 'disableContextMenuItem';
ConstantsService.disableFaviconKey = 'disableFavicon';
ConstantsService.disableAutoTotpCopyKey = 'disableAutoTotpCopy';
ConstantsService.enableAutoFillOnPageLoadKey = 'enableAutoFillOnPageLoad';
ConstantsService.vaultTimeoutKey = 'lockOption';
ConstantsService.vaultTimeoutActionKey = 'vaultTimeoutAction';
ConstantsService.lastActiveKey = 'lastActive';
ConstantsService.neverDomainsKey = 'neverDomains';
ConstantsService.installedVersionKey = 'installedVersion';
ConstantsService.localeKey = 'locale';
ConstantsService.themeKey = 'theme';
ConstantsService.collapsedGroupingsKey = 'collapsedGroupings';
ConstantsService.autoConfirmFingerprints = 'autoConfirmFingerprints';
ConstantsService.dontShowCardsCurrentTab = 'dontShowCardsCurrentTab';
ConstantsService.dontShowIdentitiesCurrentTab = 'dontShowIdentitiesCurrentTab';
ConstantsService.defaultUriMatch = 'defaultUriMatch';
ConstantsService.pinProtectedKey = 'pinProtectedKey';
ConstantsService.protectedPin = 'protectedPin';
ConstantsService.clearClipboardKey = 'clearClipboardKey';
ConstantsService.eventCollectionKey = 'eventCollection';

// CONCATENATED MODULE: ./jslib/src/misc/sequentialize.ts
/**
 * Use as a Decorator on async functions, it will prevent multiple 'active' calls as the same time
 *
 * If a promise was returned from a previous call to this function, that hasn't yet resolved it will
 * be returned, instead of calling the original function again
 *
 * Results are not cached, once the promise has returned, the next call will result in a fresh call
 *
 * Read more at https://github.com/bitwarden/jslib/pull/7
 */
function sequentialize(cacheKey) {
    return (target, propertyKey, descriptor) => {
        const originalMethod = descriptor.value;
        const caches = new Map();
        const getCache = (obj) => {
            let cache = caches.get(obj);
            if (cache != null) {
                return cache;
            }
            cache = new Map();
            caches.set(obj, cache);
            return cache;
        };
        return {
            value: function (...args) {
                const cache = getCache(this);
                const argsCacheKey = cacheKey(args);
                let response = cache.get(argsCacheKey);
                if (response != null) {
                    return response;
                }
                const onFinally = () => {
                    cache.delete(argsCacheKey);
                    if (cache.size === 0) {
                        caches.delete(this);
                    }
                };
                response = originalMethod.apply(this, args).then((val) => {
                    onFinally();
                    return val;
                }).catch((err) => {
                    onFinally();
                    throw err;
                });
                cache.set(argsCacheKey, response);
                return response;
            },
        };
    };
}

// CONCATENATED MODULE: ./jslib/src/services/cipher.service.ts
var cipher_service_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var cipher_service_metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var cipher_service_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};

























const Keys = {
    ciphersPrefix: 'ciphers_',
    localData: 'sitesLocalData',
    neverDomains: 'neverDomains',
};
const DomainMatchBlacklist = new Map([
    ['google.com', new Set(['script.google.com'])],
]);
class cipher_service_CipherService {
    constructor(cryptoService, userService, settingsService, apiService, storageService, i18nService, searchService) {
        this.cryptoService = cryptoService;
        this.userService = userService;
        this.settingsService = settingsService;
        this.apiService = apiService;
        this.storageService = storageService;
        this.i18nService = i18nService;
        this.searchService = searchService;
    }
    get decryptedCipherCache() {
        return this._decryptedCipherCache;
    }
    set decryptedCipherCache(value) {
        this._decryptedCipherCache = value;
        if (this.searchService != null) {
            if (value == null) {
                this.searchService().clearIndex();
            }
            else {
                this.searchService().indexCiphers();
            }
        }
    }
    clearCache() {
        this.decryptedCipherCache = null;
    }
    encrypt(model, key, originalCipher = null) {
        return cipher_service_awaiter(this, void 0, void 0, function* () {
            // Adjust password history
            if (model.id != null) {
                if (originalCipher == null) {
                    originalCipher = yield this.get(model.id);
                }
                if (originalCipher != null) {
                    const existingCipher = yield originalCipher.decrypt();
                    model.passwordHistory = existingCipher.passwordHistory || [];
                    if (model.type === CipherType.Login && existingCipher.type === CipherType.Login) {
                        if (existingCipher.login.password != null && existingCipher.login.password !== '' &&
                            existingCipher.login.password !== model.login.password) {
                            const ph = new PasswordHistoryView();
                            ph.password = existingCipher.login.password;
                            ph.lastUsedDate = model.login.passwordRevisionDate = new Date();
                            model.passwordHistory.splice(0, 0, ph);
                        }
                        else {
                            model.login.passwordRevisionDate = existingCipher.login.passwordRevisionDate;
                        }
                    }
                    if (existingCipher.hasFields) {
                        const existingHiddenFields = existingCipher.fields.filter((f) => f.type === FieldType.Hidden &&
                            f.name != null && f.name !== '' && f.value != null && f.value !== '');
                        const hiddenFields = model.fields == null ? [] :
                            model.fields.filter((f) => f.type === FieldType.Hidden && f.name != null && f.name !== '');
                        existingHiddenFields.forEach((ef) => {
                            const matchedField = hiddenFields.find((f) => f.name === ef.name);
                            if (matchedField == null || matchedField.value !== ef.value) {
                                const ph = new PasswordHistoryView();
                                ph.password = ef.name + ': ' + ef.value;
                                ph.lastUsedDate = new Date();
                                model.passwordHistory.splice(0, 0, ph);
                            }
                        });
                    }
                }
                if (model.passwordHistory != null && model.passwordHistory.length === 0) {
                    model.passwordHistory = null;
                }
                else if (model.passwordHistory != null && model.passwordHistory.length > 5) {
                    // only save last 5 history
                    model.passwordHistory = model.passwordHistory.slice(0, 5);
                }
            }
            const cipher = new cipher_Cipher();
            cipher.id = model.id;
            cipher.folderId = model.folderId;
            cipher.favorite = model.favorite;
            cipher.organizationId = model.organizationId;
            cipher.type = model.type;
            cipher.collectionIds = model.collectionIds;
            if (key == null && cipher.organizationId != null) {
                key = yield this.cryptoService.getOrgKey(cipher.organizationId);
                if (key == null) {
                    throw new Error('Cannot encrypt cipher for organization. No key.');
                }
            }
            yield Promise.all([
                this.encryptObjProperty(model, cipher, {
                    name: null,
                    notes: null,
                }, key),
                this.encryptCipherData(cipher, model, key),
                this.encryptFields(model.fields, key).then((fields) => {
                    cipher.fields = fields;
                }),
                this.encryptPasswordHistories(model.passwordHistory, key).then((ph) => {
                    cipher.passwordHistory = ph;
                }),
                this.encryptAttachments(model.attachments, key).then((attachments) => {
                    cipher.attachments = attachments;
                }),
            ]);
            return cipher;
        });
    }
    encryptAttachments(attachmentsModel, key) {
        return cipher_service_awaiter(this, void 0, void 0, function* () {
            if (attachmentsModel == null || attachmentsModel.length === 0) {
                return null;
            }
            const promises = [];
            const encAttachments = [];
            attachmentsModel.forEach((model) => cipher_service_awaiter(this, void 0, void 0, function* () {
                const attachment = new attachment_Attachment();
                attachment.id = model.id;
                attachment.size = model.size;
                attachment.sizeName = model.sizeName;
                attachment.url = model.url;
                const promise = this.encryptObjProperty(model, attachment, {
                    fileName: null,
                }, key).then(() => cipher_service_awaiter(this, void 0, void 0, function* () {
                    if (model.key != null) {
                        attachment.key = yield this.cryptoService.encrypt(model.key.key, key);
                    }
                    encAttachments.push(attachment);
                }));
                promises.push(promise);
            }));
            yield Promise.all(promises);
            return encAttachments;
        });
    }
    encryptFields(fieldsModel, key) {
        return cipher_service_awaiter(this, void 0, void 0, function* () {
            if (!fieldsModel || !fieldsModel.length) {
                return null;
            }
            const self = this;
            const encFields = [];
            yield fieldsModel.reduce((promise, field) => {
                return promise.then(() => {
                    return self.encryptField(field, key);
                }).then((encField) => {
                    encFields.push(encField);
                });
            }, Promise.resolve());
            return encFields;
        });
    }
    encryptField(fieldModel, key) {
        return cipher_service_awaiter(this, void 0, void 0, function* () {
            const field = new field_Field();
            field.type = fieldModel.type;
            // normalize boolean type field values
            if (fieldModel.type === FieldType.Boolean && fieldModel.value !== 'true') {
                fieldModel.value = 'false';
            }
            yield this.encryptObjProperty(fieldModel, field, {
                name: null,
                value: null,
            }, key);
            return field;
        });
    }
    encryptPasswordHistories(phModels, key) {
        return cipher_service_awaiter(this, void 0, void 0, function* () {
            if (!phModels || !phModels.length) {
                return null;
            }
            const self = this;
            const encPhs = [];
            yield phModels.reduce((promise, ph) => {
                return promise.then(() => {
                    return self.encryptPasswordHistory(ph, key);
                }).then((encPh) => {
                    encPhs.push(encPh);
                });
            }, Promise.resolve());
            return encPhs;
        });
    }
    encryptPasswordHistory(phModel, key) {
        return cipher_service_awaiter(this, void 0, void 0, function* () {
            const ph = new password_Password();
            ph.lastUsedDate = phModel.lastUsedDate;
            yield this.encryptObjProperty(phModel, ph, {
                password: null,
            }, key);
            return ph;
        });
    }
    get(id) {
        return cipher_service_awaiter(this, void 0, void 0, function* () {
            const userId = yield this.userService.getUserId();
            const localData = yield this.storageService.get(Keys.localData);
            const ciphers = yield this.storageService.get(Keys.ciphersPrefix + userId);
            if (ciphers == null || !ciphers.hasOwnProperty(id)) {
                return null;
            }
            return new cipher_Cipher(ciphers[id], false, localData ? localData[id] : null);
        });
    }
    getAll() {
        return cipher_service_awaiter(this, void 0, void 0, function* () {
            const userId = yield this.userService.getUserId();
            const localData = yield this.storageService.get(Keys.localData);
            const ciphers = yield this.storageService.get(Keys.ciphersPrefix + userId);
            const response = [];
            for (const id in ciphers) {
                if (ciphers.hasOwnProperty(id)) {
                    response.push(new cipher_Cipher(ciphers[id], false, localData ? localData[id] : null));
                }
            }
            return response;
        });
    }
    getAllDecrypted() {
        return cipher_service_awaiter(this, void 0, void 0, function* () {
            if (this.decryptedCipherCache != null) {
                return this.decryptedCipherCache;
            }
            const decCiphers = [];
            const hasKey = yield this.cryptoService.hasKey();
            if (!hasKey) {
                throw new Error('No key.');
            }
            const promises = [];
            const ciphers = yield this.getAll();
            ciphers.forEach((cipher) => {
                promises.push(cipher.decrypt().then((c) => decCiphers.push(c)));
            });
            yield Promise.all(promises);
            decCiphers.sort(this.getLocaleSortingFunction());
            this.decryptedCipherCache = decCiphers;
            return this.decryptedCipherCache;
        });
    }
    getAllDecryptedForGrouping(groupingId, folder = true) {
        return cipher_service_awaiter(this, void 0, void 0, function* () {
            const ciphers = yield this.getAllDecrypted();
            return ciphers.filter((cipher) => {
                if (cipher.isDeleted) {
                    return false;
                }
                if (folder && cipher.folderId === groupingId) {
                    return true;
                }
                else if (!folder && cipher.collectionIds != null && cipher.collectionIds.indexOf(groupingId) > -1) {
                    return true;
                }
                return false;
            });
        });
    }
    getAllDecryptedForUrl(url, includeOtherTypes) {
        return cipher_service_awaiter(this, void 0, void 0, function* () {
            if (url == null && includeOtherTypes == null) {
                return Promise.resolve([]);
            }
            const domain = utils_Utils.getDomain(url);
            const eqDomainsPromise = domain == null ? Promise.resolve([]) :
                this.settingsService.getEquivalentDomains().then((eqDomains) => {
                    let matches = [];
                    eqDomains.forEach((eqDomain) => {
                        if (eqDomain.length && eqDomain.indexOf(domain) >= 0) {
                            matches = matches.concat(eqDomain);
                        }
                    });
                    if (!matches.length) {
                        matches.push(domain);
                    }
                    return matches;
                });
            const result = yield Promise.all([eqDomainsPromise, this.getAllDecrypted()]);
            const matchingDomains = result[0];
            const ciphers = result[1];
            let defaultMatch = yield this.storageService.get(ConstantsService.defaultUriMatch);
            if (defaultMatch == null) {
                defaultMatch = UriMatchType.Domain;
            }
            return ciphers.filter((cipher) => {
                if (cipher.deletedDate != null) {
                    return false;
                }
                if (includeOtherTypes != null && includeOtherTypes.indexOf(cipher.type) > -1) {
                    return true;
                }
                if (url != null && cipher.type === CipherType.Login && cipher.login.uris != null) {
                    for (let i = 0; i < cipher.login.uris.length; i++) {
                        const u = cipher.login.uris[i];
                        if (u.uri == null) {
                            continue;
                        }
                        const match = u.match == null ? defaultMatch : u.match;
                        switch (match) {
                            case UriMatchType.Domain:
                                if (domain != null && u.domain != null && matchingDomains.indexOf(u.domain) > -1) {
                                    if (DomainMatchBlacklist.has(u.domain)) {
                                        const domainUrlHost = utils_Utils.getHost(url);
                                        if (!DomainMatchBlacklist.get(u.domain).has(domainUrlHost)) {
                                            return true;
                                        }
                                    }
                                    else {
                                        return true;
                                    }
                                }
                                break;
                            case UriMatchType.Host:
                                const urlHost = utils_Utils.getHost(url);
                                if (urlHost != null && urlHost === utils_Utils.getHost(u.uri)) {
                                    return true;
                                }
                                break;
                            case UriMatchType.Exact:
                                if (url === u.uri) {
                                    return true;
                                }
                                break;
                            case UriMatchType.StartsWith:
                                if (url.startsWith(u.uri)) {
                                    return true;
                                }
                                break;
                            case UriMatchType.RegularExpression:
                                try {
                                    const regex = new RegExp(u.uri, 'i');
                                    if (regex.test(url)) {
                                        return true;
                                    }
                                }
                                catch (_a) { }
                                break;
                            case UriMatchType.Never:
                            default:
                                break;
                        }
                    }
                }
                return false;
            });
        });
    }
    getAllFromApiForOrganization(organizationId) {
        return cipher_service_awaiter(this, void 0, void 0, function* () {
            const ciphers = yield this.apiService.getCiphersOrganization(organizationId);
            if (ciphers != null && ciphers.data != null && ciphers.data.length) {
                const decCiphers = [];
                const promises = [];
                ciphers.data.forEach((r) => {
                    const data = new cipherData_CipherData(r);
                    const cipher = new cipher_Cipher(data);
                    promises.push(cipher.decrypt().then((c) => decCiphers.push(c)));
                });
                yield Promise.all(promises);
                decCiphers.sort(this.getLocaleSortingFunction());
                return decCiphers;
            }
            else {
                return [];
            }
        });
    }
    getLastUsedForUrl(url) {
        return cipher_service_awaiter(this, void 0, void 0, function* () {
            const ciphers = yield this.getAllDecryptedForUrl(url);
            if (ciphers.length === 0) {
                return null;
            }
            const sortedCiphers = ciphers.sort(this.sortCiphersByLastUsed);
            return sortedCiphers[0];
        });
    }
    updateLastUsedDate(id) {
        return cipher_service_awaiter(this, void 0, void 0, function* () {
            let ciphersLocalData = yield this.storageService.get(Keys.localData);
            if (!ciphersLocalData) {
                ciphersLocalData = {};
            }
            if (ciphersLocalData[id]) {
                ciphersLocalData[id].lastUsedDate = new Date().getTime();
            }
            else {
                ciphersLocalData[id] = {
                    lastUsedDate: new Date().getTime(),
                };
            }
            yield this.storageService.save(Keys.localData, ciphersLocalData);
            if (this.decryptedCipherCache == null) {
                return;
            }
            for (let i = 0; i < this.decryptedCipherCache.length; i++) {
                const cached = this.decryptedCipherCache[i];
                if (cached.id === id) {
                    cached.localData = ciphersLocalData[id];
                    break;
                }
            }
        });
    }
    saveNeverDomain(domain) {
        return cipher_service_awaiter(this, void 0, void 0, function* () {
            if (domain == null) {
                return;
            }
            let domains = yield this.storageService.get(Keys.neverDomains);
            if (!domains) {
                domains = {};
            }
            domains[domain] = null;
            yield this.storageService.save(Keys.neverDomains, domains);
        });
    }
    saveWithServer(cipher) {
        return cipher_service_awaiter(this, void 0, void 0, function* () {
            let response;
            if (cipher.id == null) {
                if (cipher.collectionIds != null) {
                    const request = new cipherCreateRequest_CipherCreateRequest(cipher);
                    response = yield this.apiService.postCipherCreate(request);
                }
                else {
                    const request = new cipherRequest_CipherRequest(cipher);
                    response = yield this.apiService.postCipher(request);
                }
                cipher.id = response.id;
            }
            else {
                const request = new cipherRequest_CipherRequest(cipher);
                response = yield this.apiService.putCipher(cipher.id, request);
            }
            const userId = yield this.userService.getUserId();
            const data = new cipherData_CipherData(response, userId, cipher.collectionIds);
            yield this.upsert(data);
        });
    }
    shareWithServer(cipher, organizationId, collectionIds) {
        return cipher_service_awaiter(this, void 0, void 0, function* () {
            const attachmentPromises = [];
            if (cipher.attachments != null) {
                cipher.attachments.forEach((attachment) => {
                    if (attachment.key == null) {
                        attachmentPromises.push(this.shareAttachmentWithServer(attachment, cipher.id, organizationId));
                    }
                });
            }
            yield Promise.all(attachmentPromises);
            cipher.organizationId = organizationId;
            cipher.collectionIds = collectionIds;
            const encCipher = yield this.encrypt(cipher);
            const request = new cipherShareRequest_CipherShareRequest(encCipher);
            const response = yield this.apiService.putShareCipher(cipher.id, request);
            const userId = yield this.userService.getUserId();
            const data = new cipherData_CipherData(response, userId, collectionIds);
            yield this.upsert(data);
        });
    }
    shareManyWithServer(ciphers, organizationId, collectionIds) {
        return cipher_service_awaiter(this, void 0, void 0, function* () {
            const promises = [];
            const encCiphers = [];
            for (const cipher of ciphers) {
                cipher.organizationId = organizationId;
                cipher.collectionIds = collectionIds;
                promises.push(this.encrypt(cipher).then((c) => {
                    encCiphers.push(c);
                }));
            }
            yield Promise.all(promises);
            const request = new cipherBulkShareRequest_CipherBulkShareRequest(encCiphers, collectionIds);
            yield this.apiService.putShareCiphers(request);
            const userId = yield this.userService.getUserId();
            yield this.upsert(encCiphers.map((c) => c.toCipherData(userId)));
        });
    }
    saveAttachmentWithServer(cipher, unencryptedFile, admin = false) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.readAsArrayBuffer(unencryptedFile);
            reader.onload = (evt) => cipher_service_awaiter(this, void 0, void 0, function* () {
                try {
                    const cData = yield this.saveAttachmentRawWithServer(cipher, unencryptedFile.name, evt.target.result, admin);
                    resolve(cData);
                }
                catch (e) {
                    reject(e);
                }
            });
            reader.onerror = (evt) => {
                reject('Error reading file.');
            };
        });
    }
    saveAttachmentRawWithServer(cipher, filename, data, admin = false) {
        return cipher_service_awaiter(this, void 0, void 0, function* () {
            const key = yield this.cryptoService.getOrgKey(cipher.organizationId);
            const encFileName = yield this.cryptoService.encrypt(filename, key);
            const dataEncKey = yield this.cryptoService.makeEncKey(key);
            const encData = yield this.cryptoService.encryptToBytes(data, dataEncKey[0]);
            const fd = new FormData();
            try {
                const blob = new Blob([encData], { type: 'application/octet-stream' });
                fd.append('key', dataEncKey[1].encryptedString);
                fd.append('data', blob, encFileName.encryptedString);
            }
            catch (e) {
                if (utils_Utils.isNode && !utils_Utils.isBrowser) {
                    fd.append('key', dataEncKey[1].encryptedString);
                    fd.append('data', Buffer.from(encData), {
                        filepath: encFileName.encryptedString,
                        contentType: 'application/octet-stream',
                    });
                }
                else {
                    throw e;
                }
            }
            let response;
            try {
                if (admin) {
                    response = yield this.apiService.postCipherAttachmentAdmin(cipher.id, fd);
                }
                else {
                    response = yield this.apiService.postCipherAttachment(cipher.id, fd);
                }
            }
            catch (e) {
                throw new Error(e.getSingleMessage());
            }
            const userId = yield this.userService.getUserId();
            const cData = new cipherData_CipherData(response, userId, cipher.collectionIds);
            if (!admin) {
                yield this.upsert(cData);
            }
            return new cipher_Cipher(cData);
        });
    }
    saveCollectionsWithServer(cipher) {
        return cipher_service_awaiter(this, void 0, void 0, function* () {
            const request = new CipherCollectionsRequest(cipher.collectionIds);
            yield this.apiService.putCipherCollections(cipher.id, request);
            const userId = yield this.userService.getUserId();
            const data = cipher.toCipherData(userId);
            yield this.upsert(data);
        });
    }
    upsert(cipher) {
        return cipher_service_awaiter(this, void 0, void 0, function* () {
            const userId = yield this.userService.getUserId();
            let ciphers = yield this.storageService.get(Keys.ciphersPrefix + userId);
            if (ciphers == null) {
                ciphers = {};
            }
            if (cipher instanceof cipherData_CipherData) {
                const c = cipher;
                ciphers[c.id] = c;
            }
            else {
                cipher.forEach((c) => {
                    ciphers[c.id] = c;
                });
            }
            yield this.storageService.save(Keys.ciphersPrefix + userId, ciphers);
            this.decryptedCipherCache = null;
        });
    }
    replace(ciphers) {
        return cipher_service_awaiter(this, void 0, void 0, function* () {
            const userId = yield this.userService.getUserId();
            yield this.storageService.save(Keys.ciphersPrefix + userId, ciphers);
            this.decryptedCipherCache = null;
        });
    }
    clear(userId) {
        return cipher_service_awaiter(this, void 0, void 0, function* () {
            yield this.storageService.remove(Keys.ciphersPrefix + userId);
            this.clearCache();
        });
    }
    moveManyWithServer(ids, folderId) {
        return cipher_service_awaiter(this, void 0, void 0, function* () {
            yield this.apiService.putMoveCiphers(new CipherBulkMoveRequest(ids, folderId));
            const userId = yield this.userService.getUserId();
            let ciphers = yield this.storageService.get(Keys.ciphersPrefix + userId);
            if (ciphers == null) {
                ciphers = {};
            }
            ids.forEach((id) => {
                if (ciphers.hasOwnProperty(id)) {
                    ciphers[id].folderId = folderId;
                }
            });
            yield this.storageService.save(Keys.ciphersPrefix + userId, ciphers);
            this.decryptedCipherCache = null;
        });
    }
    delete(id) {
        return cipher_service_awaiter(this, void 0, void 0, function* () {
            const userId = yield this.userService.getUserId();
            const ciphers = yield this.storageService.get(Keys.ciphersPrefix + userId);
            if (ciphers == null) {
                return;
            }
            if (typeof id === 'string') {
                if (ciphers[id] == null) {
                    return;
                }
                delete ciphers[id];
            }
            else {
                id.forEach((i) => {
                    delete ciphers[i];
                });
            }
            yield this.storageService.save(Keys.ciphersPrefix + userId, ciphers);
            this.decryptedCipherCache = null;
        });
    }
    deleteWithServer(id) {
        return cipher_service_awaiter(this, void 0, void 0, function* () {
            yield this.apiService.deleteCipher(id);
            yield this.delete(id);
        });
    }
    deleteManyWithServer(ids) {
        return cipher_service_awaiter(this, void 0, void 0, function* () {
            yield this.apiService.deleteManyCiphers(new CipherBulkDeleteRequest(ids));
            yield this.delete(ids);
        });
    }
    deleteAttachment(id, attachmentId) {
        return cipher_service_awaiter(this, void 0, void 0, function* () {
            const userId = yield this.userService.getUserId();
            const ciphers = yield this.storageService.get(Keys.ciphersPrefix + userId);
            if (ciphers == null || !ciphers.hasOwnProperty(id) || ciphers[id].attachments == null) {
                return;
            }
            for (let i = 0; i < ciphers[id].attachments.length; i++) {
                if (ciphers[id].attachments[i].id === attachmentId) {
                    ciphers[id].attachments.splice(i, 1);
                }
            }
            yield this.storageService.save(Keys.ciphersPrefix + userId, ciphers);
            this.decryptedCipherCache = null;
        });
    }
    deleteAttachmentWithServer(id, attachmentId) {
        return cipher_service_awaiter(this, void 0, void 0, function* () {
            try {
                yield this.apiService.deleteCipherAttachment(id, attachmentId);
            }
            catch (e) {
                return Promise.reject(e.getSingleMessage());
            }
            yield this.deleteAttachment(id, attachmentId);
        });
    }
    sortCiphersByLastUsed(a, b) {
        const aLastUsed = a.localData && a.localData.lastUsedDate ? a.localData.lastUsedDate : null;
        const bLastUsed = b.localData && b.localData.lastUsedDate ? b.localData.lastUsedDate : null;
        const bothNotNull = aLastUsed != null && bLastUsed != null;
        if (bothNotNull && aLastUsed < bLastUsed) {
            return 1;
        }
        if (aLastUsed != null && bLastUsed == null) {
            return -1;
        }
        if (bothNotNull && aLastUsed > bLastUsed) {
            return -1;
        }
        if (bLastUsed != null && aLastUsed == null) {
            return 1;
        }
        return 0;
    }
    sortCiphersByLastUsedThenName(a, b) {
        const result = this.sortCiphersByLastUsed(a, b);
        if (result !== 0) {
            return result;
        }
        return this.getLocaleSortingFunction()(a, b);
    }
    getLocaleSortingFunction() {
        return (a, b) => {
            let aName = a.name;
            let bName = b.name;
            if (aName == null && bName != null) {
                return -1;
            }
            if (aName != null && bName == null) {
                return 1;
            }
            if (aName == null && bName == null) {
                return 0;
            }
            const result = this.i18nService.collator ? this.i18nService.collator.compare(aName, bName) :
                aName.localeCompare(bName);
            if (result !== 0 || a.type !== CipherType.Login || b.type !== CipherType.Login) {
                return result;
            }
            if (a.login.username != null) {
                aName += a.login.username;
            }
            if (b.login.username != null) {
                bName += b.login.username;
            }
            return this.i18nService.collator ? this.i18nService.collator.compare(aName, bName) :
                aName.localeCompare(bName);
        };
    }
    softDelete(id) {
        return cipher_service_awaiter(this, void 0, void 0, function* () {
            const userId = yield this.userService.getUserId();
            const ciphers = yield this.storageService.get(Keys.ciphersPrefix + userId);
            if (ciphers == null) {
                return;
            }
            const setDeletedDate = (cipherId) => {
                if (ciphers[cipherId] == null) {
                    return;
                }
                ciphers[cipherId].deletedDate = new Date().toISOString();
            };
            if (typeof id === 'string') {
                setDeletedDate(id);
            }
            else {
                id.forEach(setDeletedDate);
            }
            yield this.storageService.save(Keys.ciphersPrefix + userId, ciphers);
            this.decryptedCipherCache = null;
        });
    }
    softDeleteWithServer(id) {
        return cipher_service_awaiter(this, void 0, void 0, function* () {
            yield this.apiService.putDeleteCipher(id);
            yield this.softDelete(id);
        });
    }
    softDeleteManyWithServer(ids) {
        return cipher_service_awaiter(this, void 0, void 0, function* () {
            yield this.apiService.putDeleteManyCiphers(new CipherBulkDeleteRequest(ids));
            yield this.softDelete(ids);
        });
    }
    restore(id) {
        return cipher_service_awaiter(this, void 0, void 0, function* () {
            const userId = yield this.userService.getUserId();
            const ciphers = yield this.storageService.get(Keys.ciphersPrefix + userId);
            if (ciphers == null) {
                return;
            }
            const clearDeletedDate = (cipherId) => {
                if (ciphers[cipherId] == null) {
                    return;
                }
                ciphers[cipherId].deletedDate = null;
            };
            if (typeof id === 'string') {
                clearDeletedDate(id);
            }
            else {
                id.forEach(clearDeletedDate);
            }
            yield this.storageService.save(Keys.ciphersPrefix + userId, ciphers);
            this.decryptedCipherCache = null;
        });
    }
    restoreWithServer(id) {
        return cipher_service_awaiter(this, void 0, void 0, function* () {
            yield this.apiService.putRestoreCipher(id);
            yield this.restore(id);
        });
    }
    restoreManyWithServer(ids) {
        return cipher_service_awaiter(this, void 0, void 0, function* () {
            yield this.apiService.putRestoreManyCiphers(new CipherBulkRestoreRequest(ids));
            yield this.restore(ids);
        });
    }
    // Helpers
    shareAttachmentWithServer(attachmentView, cipherId, organizationId) {
        return cipher_service_awaiter(this, void 0, void 0, function* () {
            const attachmentResponse = yield this.apiService.nativeFetch(new Request(attachmentView.url, { cache: 'no-store' }));
            if (attachmentResponse.status !== 200) {
                throw Error('Failed to download attachment: ' + attachmentResponse.status.toString());
            }
            const buf = yield attachmentResponse.arrayBuffer();
            const decBuf = yield this.cryptoService.decryptFromBytes(buf, null);
            const key = yield this.cryptoService.getOrgKey(organizationId);
            const encFileName = yield this.cryptoService.encrypt(attachmentView.fileName, key);
            const dataEncKey = yield this.cryptoService.makeEncKey(key);
            const encData = yield this.cryptoService.encryptToBytes(decBuf, dataEncKey[0]);
            const fd = new FormData();
            try {
                const blob = new Blob([encData], { type: 'application/octet-stream' });
                fd.append('key', dataEncKey[1].encryptedString);
                fd.append('data', blob, encFileName.encryptedString);
            }
            catch (e) {
                if (utils_Utils.isNode && !utils_Utils.isBrowser) {
                    fd.append('key', dataEncKey[1].encryptedString);
                    fd.append('data', Buffer.from(encData), {
                        filepath: encFileName.encryptedString,
                        contentType: 'application/octet-stream',
                    });
                }
                else {
                    throw e;
                }
            }
            try {
                yield this.apiService.postShareCipherAttachment(cipherId, attachmentView.id, fd, organizationId);
            }
            catch (e) {
                throw new Error(e.getSingleMessage());
            }
        });
    }
    encryptObjProperty(model, obj, map, key) {
        return cipher_service_awaiter(this, void 0, void 0, function* () {
            const promises = [];
            const self = this;
            for (const prop in map) {
                if (!map.hasOwnProperty(prop)) {
                    continue;
                }
                // tslint:disable-next-line
                (function (theProp, theObj) {
                    const p = Promise.resolve().then(() => {
                        const modelProp = model[(map[theProp] || theProp)];
                        if (modelProp && modelProp !== '') {
                            return self.cryptoService.encrypt(modelProp, key);
                        }
                        return null;
                    }).then((val) => {
                        theObj[theProp] = val;
                    });
                    promises.push(p);
                })(prop, obj);
            }
            yield Promise.all(promises);
        });
    }
    encryptCipherData(cipher, model, key) {
        return cipher_service_awaiter(this, void 0, void 0, function* () {
            switch (cipher.type) {
                case CipherType.Login:
                    cipher.login = new login_Login();
                    cipher.login.passwordRevisionDate = model.login.passwordRevisionDate;
                    yield this.encryptObjProperty(model.login, cipher.login, {
                        username: null,
                        password: null,
                        totp: null,
                    }, key);
                    if (model.login.uris != null) {
                        cipher.login.uris = [];
                        for (let i = 0; i < model.login.uris.length; i++) {
                            const loginUri = new loginUri_LoginUri();
                            loginUri.match = model.login.uris[i].match;
                            yield this.encryptObjProperty(model.login.uris[i], loginUri, {
                                uri: null,
                            }, key);
                            cipher.login.uris.push(loginUri);
                        }
                    }
                    return;
                case CipherType.SecureNote:
                    cipher.secureNote = new secureNote_SecureNote();
                    cipher.secureNote.type = model.secureNote.type;
                    return;
                case CipherType.Card:
                    cipher.card = new card_Card();
                    yield this.encryptObjProperty(model.card, cipher.card, {
                        cardholderName: null,
                        brand: null,
                        number: null,
                        expMonth: null,
                        expYear: null,
                        code: null,
                    }, key);
                    return;
                case CipherType.Identity:
                    cipher.identity = new identity_Identity();
                    yield this.encryptObjProperty(model.identity, cipher.identity, {
                        title: null,
                        firstName: null,
                        middleName: null,
                        lastName: null,
                        address1: null,
                        address2: null,
                        address3: null,
                        city: null,
                        state: null,
                        postalCode: null,
                        country: null,
                        company: null,
                        email: null,
                        phone: null,
                        ssn: null,
                        username: null,
                        passportNumber: null,
                        licenseNumber: null,
                    }, key);
                    return;
                default:
                    throw new Error('Unknown cipher type.');
            }
        });
    }
}
cipher_service_decorate([
    sequentialize(() => 'getAllDecrypted'),
    cipher_service_metadata("design:type", Function),
    cipher_service_metadata("design:paramtypes", []),
    cipher_service_metadata("design:returntype", Promise)
], cipher_service_CipherService.prototype, "getAllDecrypted", null);

// CONCATENATED MODULE: ./jslib/src/models/data/collectionData.ts
class CollectionData {
    constructor(response) {
        this.id = response.id;
        this.organizationId = response.organizationId;
        this.name = response.name;
        this.externalId = response.externalId;
        this.readOnly = response.readOnly;
    }
}

// CONCATENATED MODULE: ./jslib/src/models/domain/treeNode.ts
class TreeNode {
    constructor(node, name, parent) {
        this.children = [];
        this.parent = parent;
        this.node = node;
        this.node.name = name;
    }
}

// CONCATENATED MODULE: ./jslib/src/misc/serviceUtils.ts

class serviceUtils_ServiceUtils {
    static nestedTraverse(nodeTree, partIndex, parts, obj, parent, delimiter) {
        if (parts.length <= partIndex) {
            return;
        }
        const end = partIndex === parts.length - 1;
        const partName = parts[partIndex];
        for (let i = 0; i < nodeTree.length; i++) {
            if (nodeTree[i].node.name !== parts[partIndex]) {
                continue;
            }
            if (end && nodeTree[i].node.id !== obj.id) {
                // Another node with the same name.
                nodeTree.push(new TreeNode(obj, partName, parent));
                return;
            }
            serviceUtils_ServiceUtils.nestedTraverse(nodeTree[i].children, partIndex + 1, parts, obj, nodeTree[i].node, delimiter);
            return;
        }
        if (nodeTree.filter((n) => n.node.name === partName).length === 0) {
            if (end) {
                nodeTree.push(new TreeNode(obj, partName, parent));
                return;
            }
            const newPartName = parts[partIndex] + delimiter + parts[partIndex + 1];
            serviceUtils_ServiceUtils.nestedTraverse(nodeTree, 0, [newPartName, ...parts.slice(partIndex + 2)], obj, parent, delimiter);
        }
    }
    static getTreeNodeObject(nodeTree, id) {
        for (let i = 0; i < nodeTree.length; i++) {
            if (nodeTree[i].node.id === id) {
                return nodeTree[i];
            }
            else if (nodeTree[i].children != null) {
                const node = serviceUtils_ServiceUtils.getTreeNodeObject(nodeTree[i].children, id);
                if (node !== null) {
                    return node;
                }
            }
        }
        return null;
    }
}

// CONCATENATED MODULE: ./jslib/src/services/collection.service.ts
var collection_service_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};





const collection_service_Keys = {
    collectionsPrefix: 'collections_',
};
const NestingDelimiter = '/';
class collection_service_CollectionService {
    constructor(cryptoService, userService, storageService, i18nService) {
        this.cryptoService = cryptoService;
        this.userService = userService;
        this.storageService = storageService;
        this.i18nService = i18nService;
    }
    clearCache() {
        this.decryptedCollectionCache = null;
    }
    encrypt(model) {
        return collection_service_awaiter(this, void 0, void 0, function* () {
            if (model.organizationId == null) {
                throw new Error('Collection has no organization id.');
            }
            const key = yield this.cryptoService.getOrgKey(model.organizationId);
            if (key == null) {
                throw new Error('No key for this collection\'s organization.');
            }
            const collection = new collection_Collection();
            collection.id = model.id;
            collection.organizationId = model.organizationId;
            collection.readOnly = model.readOnly;
            collection.name = yield this.cryptoService.encrypt(model.name, key);
            return collection;
        });
    }
    decryptMany(collections) {
        return collection_service_awaiter(this, void 0, void 0, function* () {
            if (collections == null) {
                return [];
            }
            const decCollections = [];
            const promises = [];
            collections.forEach((collection) => {
                promises.push(collection.decrypt().then((c) => decCollections.push(c)));
            });
            yield Promise.all(promises);
            return decCollections.sort(utils_Utils.getSortFunction(this.i18nService, 'name'));
        });
    }
    get(id) {
        return collection_service_awaiter(this, void 0, void 0, function* () {
            const userId = yield this.userService.getUserId();
            const collections = yield this.storageService.get(collection_service_Keys.collectionsPrefix + userId);
            if (collections == null || !collections.hasOwnProperty(id)) {
                return null;
            }
            return new collection_Collection(collections[id]);
        });
    }
    getAll() {
        return collection_service_awaiter(this, void 0, void 0, function* () {
            const userId = yield this.userService.getUserId();
            const collections = yield this.storageService.get(collection_service_Keys.collectionsPrefix + userId);
            const response = [];
            for (const id in collections) {
                if (collections.hasOwnProperty(id)) {
                    response.push(new collection_Collection(collections[id]));
                }
            }
            return response;
        });
    }
    getAllDecrypted() {
        return collection_service_awaiter(this, void 0, void 0, function* () {
            if (this.decryptedCollectionCache != null) {
                return this.decryptedCollectionCache;
            }
            const hasKey = yield this.cryptoService.hasKey();
            if (!hasKey) {
                throw new Error('No key.');
            }
            const collections = yield this.getAll();
            this.decryptedCollectionCache = yield this.decryptMany(collections);
            return this.decryptedCollectionCache;
        });
    }
    getAllNested(collections = null) {
        return collection_service_awaiter(this, void 0, void 0, function* () {
            if (collections == null) {
                collections = yield this.getAllDecrypted();
            }
            const nodes = [];
            collections.forEach((c) => {
                const collectionCopy = new collectionView_CollectionView();
                collectionCopy.id = c.id;
                collectionCopy.organizationId = c.organizationId;
                const parts = c.name != null ? c.name.replace(/^\/+|\/+$/g, '').split(NestingDelimiter) : [];
                serviceUtils_ServiceUtils.nestedTraverse(nodes, 0, parts, collectionCopy, null, NestingDelimiter);
            });
            return nodes;
        });
    }
    getNested(id) {
        return collection_service_awaiter(this, void 0, void 0, function* () {
            const collections = yield this.getAllNested();
            return serviceUtils_ServiceUtils.getTreeNodeObject(collections, id);
        });
    }
    upsert(collection) {
        return collection_service_awaiter(this, void 0, void 0, function* () {
            const userId = yield this.userService.getUserId();
            let collections = yield this.storageService.get(collection_service_Keys.collectionsPrefix + userId);
            if (collections == null) {
                collections = {};
            }
            if (collection instanceof CollectionData) {
                const c = collection;
                collections[c.id] = c;
            }
            else {
                collection.forEach((c) => {
                    collections[c.id] = c;
                });
            }
            yield this.storageService.save(collection_service_Keys.collectionsPrefix + userId, collections);
            this.decryptedCollectionCache = null;
        });
    }
    replace(collections) {
        return collection_service_awaiter(this, void 0, void 0, function* () {
            const userId = yield this.userService.getUserId();
            yield this.storageService.save(collection_service_Keys.collectionsPrefix + userId, collections);
            this.decryptedCollectionCache = null;
        });
    }
    clear(userId) {
        return collection_service_awaiter(this, void 0, void 0, function* () {
            yield this.storageService.remove(collection_service_Keys.collectionsPrefix + userId);
            this.decryptedCollectionCache = null;
        });
    }
    delete(id) {
        return collection_service_awaiter(this, void 0, void 0, function* () {
            const userId = yield this.userService.getUserId();
            const collections = yield this.storageService.get(collection_service_Keys.collectionsPrefix + userId);
            if (collections == null) {
                return;
            }
            if (typeof id === 'string') {
                const i = id;
                delete collections[id];
            }
            else {
                id.forEach((i) => {
                    delete collections[i];
                });
            }
            yield this.storageService.save(collection_service_Keys.collectionsPrefix + userId, collections);
            this.decryptedCollectionCache = null;
        });
    }
}

// CONCATENATED MODULE: ./jslib/src/services/container.service.ts
class ContainerService {
    constructor(cryptoService) {
        this.cryptoService = cryptoService;
    }
    // deprecated, use attachToGlobal instead
    attachToWindow(win) {
        this.attachToGlobal(win);
    }
    attachToGlobal(global) {
        if (!global.bitwardenContainerService) {
            global.bitwardenContainerService = this;
        }
    }
    getCryptoService() {
        return this.cryptoService;
    }
}

// EXTERNAL MODULE: external "big-integer"
var external_big_integer_ = __webpack_require__(13);

// CONCATENATED MODULE: ./jslib/src/enums/kdfType.ts
var KdfType;
(function (KdfType) {
    KdfType[KdfType["PBKDF2_SHA256"] = 0] = "PBKDF2_SHA256";
})(KdfType || (KdfType = {}));

// CONCATENATED MODULE: ./jslib/src/misc/wordlist.ts
// EFF's Long Wordlist from https://www.eff.org/dice
const EEFLongWordList = [
    'abacus',
    'abdomen',
    'abdominal',
    'abide',
    'abiding',
    'ability',
    'ablaze',
    'able',
    'abnormal',
    'abrasion',
    'abrasive',
    'abreast',
    'abridge',
    'abroad',
    'abruptly',
    'absence',
    'absentee',
    'absently',
    'absinthe',
    'absolute',
    'absolve',
    'abstain',
    'abstract',
    'absurd',
    'accent',
    'acclaim',
    'acclimate',
    'accompany',
    'account',
    'accuracy',
    'accurate',
    'accustom',
    'acetone',
    'achiness',
    'aching',
    'acid',
    'acorn',
    'acquaint',
    'acquire',
    'acre',
    'acrobat',
    'acronym',
    'acting',
    'action',
    'activate',
    'activator',
    'active',
    'activism',
    'activist',
    'activity',
    'actress',
    'acts',
    'acutely',
    'acuteness',
    'aeration',
    'aerobics',
    'aerosol',
    'aerospace',
    'afar',
    'affair',
    'affected',
    'affecting',
    'affection',
    'affidavit',
    'affiliate',
    'affirm',
    'affix',
    'afflicted',
    'affluent',
    'afford',
    'affront',
    'aflame',
    'afloat',
    'aflutter',
    'afoot',
    'afraid',
    'afterglow',
    'afterlife',
    'aftermath',
    'aftermost',
    'afternoon',
    'aged',
    'ageless',
    'agency',
    'agenda',
    'agent',
    'aggregate',
    'aghast',
    'agile',
    'agility',
    'aging',
    'agnostic',
    'agonize',
    'agonizing',
    'agony',
    'agreeable',
    'agreeably',
    'agreed',
    'agreeing',
    'agreement',
    'aground',
    'ahead',
    'ahoy',
    'aide',
    'aids',
    'aim',
    'ajar',
    'alabaster',
    'alarm',
    'albatross',
    'album',
    'alfalfa',
    'algebra',
    'algorithm',
    'alias',
    'alibi',
    'alienable',
    'alienate',
    'aliens',
    'alike',
    'alive',
    'alkaline',
    'alkalize',
    'almanac',
    'almighty',
    'almost',
    'aloe',
    'aloft',
    'aloha',
    'alone',
    'alongside',
    'aloof',
    'alphabet',
    'alright',
    'although',
    'altitude',
    'alto',
    'aluminum',
    'alumni',
    'always',
    'amaretto',
    'amaze',
    'amazingly',
    'amber',
    'ambiance',
    'ambiguity',
    'ambiguous',
    'ambition',
    'ambitious',
    'ambulance',
    'ambush',
    'amendable',
    'amendment',
    'amends',
    'amenity',
    'amiable',
    'amicably',
    'amid',
    'amigo',
    'amino',
    'amiss',
    'ammonia',
    'ammonium',
    'amnesty',
    'amniotic',
    'among',
    'amount',
    'amperage',
    'ample',
    'amplifier',
    'amplify',
    'amply',
    'amuck',
    'amulet',
    'amusable',
    'amused',
    'amusement',
    'amuser',
    'amusing',
    'anaconda',
    'anaerobic',
    'anagram',
    'anatomist',
    'anatomy',
    'anchor',
    'anchovy',
    'ancient',
    'android',
    'anemia',
    'anemic',
    'aneurism',
    'anew',
    'angelfish',
    'angelic',
    'anger',
    'angled',
    'angler',
    'angles',
    'angling',
    'angrily',
    'angriness',
    'anguished',
    'angular',
    'animal',
    'animate',
    'animating',
    'animation',
    'animator',
    'anime',
    'animosity',
    'ankle',
    'annex',
    'annotate',
    'announcer',
    'annoying',
    'annually',
    'annuity',
    'anointer',
    'another',
    'answering',
    'antacid',
    'antarctic',
    'anteater',
    'antelope',
    'antennae',
    'anthem',
    'anthill',
    'anthology',
    'antibody',
    'antics',
    'antidote',
    'antihero',
    'antiquely',
    'antiques',
    'antiquity',
    'antirust',
    'antitoxic',
    'antitrust',
    'antiviral',
    'antivirus',
    'antler',
    'antonym',
    'antsy',
    'anvil',
    'anybody',
    'anyhow',
    'anymore',
    'anyone',
    'anyplace',
    'anything',
    'anytime',
    'anyway',
    'anywhere',
    'aorta',
    'apache',
    'apostle',
    'appealing',
    'appear',
    'appease',
    'appeasing',
    'appendage',
    'appendix',
    'appetite',
    'appetizer',
    'applaud',
    'applause',
    'apple',
    'appliance',
    'applicant',
    'applied',
    'apply',
    'appointee',
    'appraisal',
    'appraiser',
    'apprehend',
    'approach',
    'approval',
    'approve',
    'apricot',
    'april',
    'apron',
    'aptitude',
    'aptly',
    'aqua',
    'aqueduct',
    'arbitrary',
    'arbitrate',
    'ardently',
    'area',
    'arena',
    'arguable',
    'arguably',
    'argue',
    'arise',
    'armadillo',
    'armband',
    'armchair',
    'armed',
    'armful',
    'armhole',
    'arming',
    'armless',
    'armoire',
    'armored',
    'armory',
    'armrest',
    'army',
    'aroma',
    'arose',
    'around',
    'arousal',
    'arrange',
    'array',
    'arrest',
    'arrival',
    'arrive',
    'arrogance',
    'arrogant',
    'arson',
    'art',
    'ascend',
    'ascension',
    'ascent',
    'ascertain',
    'ashamed',
    'ashen',
    'ashes',
    'ashy',
    'aside',
    'askew',
    'asleep',
    'asparagus',
    'aspect',
    'aspirate',
    'aspire',
    'aspirin',
    'astonish',
    'astound',
    'astride',
    'astrology',
    'astronaut',
    'astronomy',
    'astute',
    'atlantic',
    'atlas',
    'atom',
    'atonable',
    'atop',
    'atrium',
    'atrocious',
    'atrophy',
    'attach',
    'attain',
    'attempt',
    'attendant',
    'attendee',
    'attention',
    'attentive',
    'attest',
    'attic',
    'attire',
    'attitude',
    'attractor',
    'attribute',
    'atypical',
    'auction',
    'audacious',
    'audacity',
    'audible',
    'audibly',
    'audience',
    'audio',
    'audition',
    'augmented',
    'august',
    'authentic',
    'author',
    'autism',
    'autistic',
    'autograph',
    'automaker',
    'automated',
    'automatic',
    'autopilot',
    'available',
    'avalanche',
    'avatar',
    'avenge',
    'avenging',
    'avenue',
    'average',
    'aversion',
    'avert',
    'aviation',
    'aviator',
    'avid',
    'avoid',
    'await',
    'awaken',
    'award',
    'aware',
    'awhile',
    'awkward',
    'awning',
    'awoke',
    'awry',
    'axis',
    'babble',
    'babbling',
    'babied',
    'baboon',
    'backache',
    'backboard',
    'backboned',
    'backdrop',
    'backed',
    'backer',
    'backfield',
    'backfire',
    'backhand',
    'backing',
    'backlands',
    'backlash',
    'backless',
    'backlight',
    'backlit',
    'backlog',
    'backpack',
    'backpedal',
    'backrest',
    'backroom',
    'backshift',
    'backside',
    'backslid',
    'backspace',
    'backspin',
    'backstab',
    'backstage',
    'backtalk',
    'backtrack',
    'backup',
    'backward',
    'backwash',
    'backwater',
    'backyard',
    'bacon',
    'bacteria',
    'bacterium',
    'badass',
    'badge',
    'badland',
    'badly',
    'badness',
    'baffle',
    'baffling',
    'bagel',
    'bagful',
    'baggage',
    'bagged',
    'baggie',
    'bagginess',
    'bagging',
    'baggy',
    'bagpipe',
    'baguette',
    'baked',
    'bakery',
    'bakeshop',
    'baking',
    'balance',
    'balancing',
    'balcony',
    'balmy',
    'balsamic',
    'bamboo',
    'banana',
    'banish',
    'banister',
    'banjo',
    'bankable',
    'bankbook',
    'banked',
    'banker',
    'banking',
    'banknote',
    'bankroll',
    'banner',
    'bannister',
    'banshee',
    'banter',
    'barbecue',
    'barbed',
    'barbell',
    'barber',
    'barcode',
    'barge',
    'bargraph',
    'barista',
    'baritone',
    'barley',
    'barmaid',
    'barman',
    'barn',
    'barometer',
    'barrack',
    'barracuda',
    'barrel',
    'barrette',
    'barricade',
    'barrier',
    'barstool',
    'bartender',
    'barterer',
    'bash',
    'basically',
    'basics',
    'basil',
    'basin',
    'basis',
    'basket',
    'batboy',
    'batch',
    'bath',
    'baton',
    'bats',
    'battalion',
    'battered',
    'battering',
    'battery',
    'batting',
    'battle',
    'bauble',
    'bazooka',
    'blabber',
    'bladder',
    'blade',
    'blah',
    'blame',
    'blaming',
    'blanching',
    'blandness',
    'blank',
    'blaspheme',
    'blasphemy',
    'blast',
    'blatancy',
    'blatantly',
    'blazer',
    'blazing',
    'bleach',
    'bleak',
    'bleep',
    'blemish',
    'blend',
    'bless',
    'blighted',
    'blimp',
    'bling',
    'blinked',
    'blinker',
    'blinking',
    'blinks',
    'blip',
    'blissful',
    'blitz',
    'blizzard',
    'bloated',
    'bloating',
    'blob',
    'blog',
    'bloomers',
    'blooming',
    'blooper',
    'blot',
    'blouse',
    'blubber',
    'bluff',
    'bluish',
    'blunderer',
    'blunt',
    'blurb',
    'blurred',
    'blurry',
    'blurt',
    'blush',
    'blustery',
    'boaster',
    'boastful',
    'boasting',
    'boat',
    'bobbed',
    'bobbing',
    'bobble',
    'bobcat',
    'bobsled',
    'bobtail',
    'bodacious',
    'body',
    'bogged',
    'boggle',
    'bogus',
    'boil',
    'bok',
    'bolster',
    'bolt',
    'bonanza',
    'bonded',
    'bonding',
    'bondless',
    'boned',
    'bonehead',
    'boneless',
    'bonelike',
    'boney',
    'bonfire',
    'bonnet',
    'bonsai',
    'bonus',
    'bony',
    'boogeyman',
    'boogieman',
    'book',
    'boondocks',
    'booted',
    'booth',
    'bootie',
    'booting',
    'bootlace',
    'bootleg',
    'boots',
    'boozy',
    'borax',
    'boring',
    'borough',
    'borrower',
    'borrowing',
    'boss',
    'botanical',
    'botanist',
    'botany',
    'botch',
    'both',
    'bottle',
    'bottling',
    'bottom',
    'bounce',
    'bouncing',
    'bouncy',
    'bounding',
    'boundless',
    'bountiful',
    'bovine',
    'boxcar',
    'boxer',
    'boxing',
    'boxlike',
    'boxy',
    'breach',
    'breath',
    'breeches',
    'breeching',
    'breeder',
    'breeding',
    'breeze',
    'breezy',
    'brethren',
    'brewery',
    'brewing',
    'briar',
    'bribe',
    'brick',
    'bride',
    'bridged',
    'brigade',
    'bright',
    'brilliant',
    'brim',
    'bring',
    'brink',
    'brisket',
    'briskly',
    'briskness',
    'bristle',
    'brittle',
    'broadband',
    'broadcast',
    'broaden',
    'broadly',
    'broadness',
    'broadside',
    'broadways',
    'broiler',
    'broiling',
    'broken',
    'broker',
    'bronchial',
    'bronco',
    'bronze',
    'bronzing',
    'brook',
    'broom',
    'brought',
    'browbeat',
    'brownnose',
    'browse',
    'browsing',
    'bruising',
    'brunch',
    'brunette',
    'brunt',
    'brush',
    'brussels',
    'brute',
    'brutishly',
    'bubble',
    'bubbling',
    'bubbly',
    'buccaneer',
    'bucked',
    'bucket',
    'buckle',
    'buckshot',
    'buckskin',
    'bucktooth',
    'buckwheat',
    'buddhism',
    'buddhist',
    'budding',
    'buddy',
    'budget',
    'buffalo',
    'buffed',
    'buffer',
    'buffing',
    'buffoon',
    'buggy',
    'bulb',
    'bulge',
    'bulginess',
    'bulgur',
    'bulk',
    'bulldog',
    'bulldozer',
    'bullfight',
    'bullfrog',
    'bullhorn',
    'bullion',
    'bullish',
    'bullpen',
    'bullring',
    'bullseye',
    'bullwhip',
    'bully',
    'bunch',
    'bundle',
    'bungee',
    'bunion',
    'bunkbed',
    'bunkhouse',
    'bunkmate',
    'bunny',
    'bunt',
    'busboy',
    'bush',
    'busily',
    'busload',
    'bust',
    'busybody',
    'buzz',
    'cabana',
    'cabbage',
    'cabbie',
    'cabdriver',
    'cable',
    'caboose',
    'cache',
    'cackle',
    'cacti',
    'cactus',
    'caddie',
    'caddy',
    'cadet',
    'cadillac',
    'cadmium',
    'cage',
    'cahoots',
    'cake',
    'calamari',
    'calamity',
    'calcium',
    'calculate',
    'calculus',
    'caliber',
    'calibrate',
    'calm',
    'caloric',
    'calorie',
    'calzone',
    'camcorder',
    'cameo',
    'camera',
    'camisole',
    'camper',
    'campfire',
    'camping',
    'campsite',
    'campus',
    'canal',
    'canary',
    'cancel',
    'candied',
    'candle',
    'candy',
    'cane',
    'canine',
    'canister',
    'cannabis',
    'canned',
    'canning',
    'cannon',
    'cannot',
    'canola',
    'canon',
    'canopener',
    'canopy',
    'canteen',
    'canyon',
    'capable',
    'capably',
    'capacity',
    'cape',
    'capillary',
    'capital',
    'capitol',
    'capped',
    'capricorn',
    'capsize',
    'capsule',
    'caption',
    'captivate',
    'captive',
    'captivity',
    'capture',
    'caramel',
    'carat',
    'caravan',
    'carbon',
    'cardboard',
    'carded',
    'cardiac',
    'cardigan',
    'cardinal',
    'cardstock',
    'carefully',
    'caregiver',
    'careless',
    'caress',
    'caretaker',
    'cargo',
    'caring',
    'carless',
    'carload',
    'carmaker',
    'carnage',
    'carnation',
    'carnival',
    'carnivore',
    'carol',
    'carpenter',
    'carpentry',
    'carpool',
    'carport',
    'carried',
    'carrot',
    'carrousel',
    'carry',
    'cartel',
    'cartload',
    'carton',
    'cartoon',
    'cartridge',
    'cartwheel',
    'carve',
    'carving',
    'carwash',
    'cascade',
    'case',
    'cash',
    'casing',
    'casino',
    'casket',
    'cassette',
    'casually',
    'casualty',
    'catacomb',
    'catalog',
    'catalyst',
    'catalyze',
    'catapult',
    'cataract',
    'catatonic',
    'catcall',
    'catchable',
    'catcher',
    'catching',
    'catchy',
    'caterer',
    'catering',
    'catfight',
    'catfish',
    'cathedral',
    'cathouse',
    'catlike',
    'catnap',
    'catnip',
    'catsup',
    'cattail',
    'cattishly',
    'cattle',
    'catty',
    'catwalk',
    'caucasian',
    'caucus',
    'causal',
    'causation',
    'cause',
    'causing',
    'cauterize',
    'caution',
    'cautious',
    'cavalier',
    'cavalry',
    'caviar',
    'cavity',
    'cedar',
    'celery',
    'celestial',
    'celibacy',
    'celibate',
    'celtic',
    'cement',
    'census',
    'ceramics',
    'ceremony',
    'certainly',
    'certainty',
    'certified',
    'certify',
    'cesarean',
    'cesspool',
    'chafe',
    'chaffing',
    'chain',
    'chair',
    'chalice',
    'challenge',
    'chamber',
    'chamomile',
    'champion',
    'chance',
    'change',
    'channel',
    'chant',
    'chaos',
    'chaperone',
    'chaplain',
    'chapped',
    'chaps',
    'chapter',
    'character',
    'charbroil',
    'charcoal',
    'charger',
    'charging',
    'chariot',
    'charity',
    'charm',
    'charred',
    'charter',
    'charting',
    'chase',
    'chasing',
    'chaste',
    'chastise',
    'chastity',
    'chatroom',
    'chatter',
    'chatting',
    'chatty',
    'cheating',
    'cheddar',
    'cheek',
    'cheer',
    'cheese',
    'cheesy',
    'chef',
    'chemicals',
    'chemist',
    'chemo',
    'cherisher',
    'cherub',
    'chess',
    'chest',
    'chevron',
    'chevy',
    'chewable',
    'chewer',
    'chewing',
    'chewy',
    'chief',
    'chihuahua',
    'childcare',
    'childhood',
    'childish',
    'childless',
    'childlike',
    'chili',
    'chill',
    'chimp',
    'chip',
    'chirping',
    'chirpy',
    'chitchat',
    'chivalry',
    'chive',
    'chloride',
    'chlorine',
    'choice',
    'chokehold',
    'choking',
    'chomp',
    'chooser',
    'choosing',
    'choosy',
    'chop',
    'chosen',
    'chowder',
    'chowtime',
    'chrome',
    'chubby',
    'chuck',
    'chug',
    'chummy',
    'chump',
    'chunk',
    'churn',
    'chute',
    'cider',
    'cilantro',
    'cinch',
    'cinema',
    'cinnamon',
    'circle',
    'circling',
    'circular',
    'circulate',
    'circus',
    'citable',
    'citadel',
    'citation',
    'citizen',
    'citric',
    'citrus',
    'city',
    'civic',
    'civil',
    'clad',
    'claim',
    'clambake',
    'clammy',
    'clamor',
    'clamp',
    'clamshell',
    'clang',
    'clanking',
    'clapped',
    'clapper',
    'clapping',
    'clarify',
    'clarinet',
    'clarity',
    'clash',
    'clasp',
    'class',
    'clatter',
    'clause',
    'clavicle',
    'claw',
    'clay',
    'clean',
    'clear',
    'cleat',
    'cleaver',
    'cleft',
    'clench',
    'clergyman',
    'clerical',
    'clerk',
    'clever',
    'clicker',
    'client',
    'climate',
    'climatic',
    'cling',
    'clinic',
    'clinking',
    'clip',
    'clique',
    'cloak',
    'clobber',
    'clock',
    'clone',
    'cloning',
    'closable',
    'closure',
    'clothes',
    'clothing',
    'cloud',
    'clover',
    'clubbed',
    'clubbing',
    'clubhouse',
    'clump',
    'clumsily',
    'clumsy',
    'clunky',
    'clustered',
    'clutch',
    'clutter',
    'coach',
    'coagulant',
    'coastal',
    'coaster',
    'coasting',
    'coastland',
    'coastline',
    'coat',
    'coauthor',
    'cobalt',
    'cobbler',
    'cobweb',
    'cocoa',
    'coconut',
    'cod',
    'coeditor',
    'coerce',
    'coexist',
    'coffee',
    'cofounder',
    'cognition',
    'cognitive',
    'cogwheel',
    'coherence',
    'coherent',
    'cohesive',
    'coil',
    'coke',
    'cola',
    'cold',
    'coleslaw',
    'coliseum',
    'collage',
    'collapse',
    'collar',
    'collected',
    'collector',
    'collide',
    'collie',
    'collision',
    'colonial',
    'colonist',
    'colonize',
    'colony',
    'colossal',
    'colt',
    'coma',
    'come',
    'comfort',
    'comfy',
    'comic',
    'coming',
    'comma',
    'commence',
    'commend',
    'comment',
    'commerce',
    'commode',
    'commodity',
    'commodore',
    'common',
    'commotion',
    'commute',
    'commuting',
    'compacted',
    'compacter',
    'compactly',
    'compactor',
    'companion',
    'company',
    'compare',
    'compel',
    'compile',
    'comply',
    'component',
    'composed',
    'composer',
    'composite',
    'compost',
    'composure',
    'compound',
    'compress',
    'comprised',
    'computer',
    'computing',
    'comrade',
    'concave',
    'conceal',
    'conceded',
    'concept',
    'concerned',
    'concert',
    'conch',
    'concierge',
    'concise',
    'conclude',
    'concrete',
    'concur',
    'condense',
    'condiment',
    'condition',
    'condone',
    'conducive',
    'conductor',
    'conduit',
    'cone',
    'confess',
    'confetti',
    'confidant',
    'confident',
    'confider',
    'confiding',
    'configure',
    'confined',
    'confining',
    'confirm',
    'conflict',
    'conform',
    'confound',
    'confront',
    'confused',
    'confusing',
    'confusion',
    'congenial',
    'congested',
    'congrats',
    'congress',
    'conical',
    'conjoined',
    'conjure',
    'conjuror',
    'connected',
    'connector',
    'consensus',
    'consent',
    'console',
    'consoling',
    'consonant',
    'constable',
    'constant',
    'constrain',
    'constrict',
    'construct',
    'consult',
    'consumer',
    'consuming',
    'contact',
    'container',
    'contempt',
    'contend',
    'contented',
    'contently',
    'contents',
    'contest',
    'context',
    'contort',
    'contour',
    'contrite',
    'control',
    'contusion',
    'convene',
    'convent',
    'copartner',
    'cope',
    'copied',
    'copier',
    'copilot',
    'coping',
    'copious',
    'copper',
    'copy',
    'coral',
    'cork',
    'cornball',
    'cornbread',
    'corncob',
    'cornea',
    'corned',
    'corner',
    'cornfield',
    'cornflake',
    'cornhusk',
    'cornmeal',
    'cornstalk',
    'corny',
    'coronary',
    'coroner',
    'corporal',
    'corporate',
    'corral',
    'correct',
    'corridor',
    'corrode',
    'corroding',
    'corrosive',
    'corsage',
    'corset',
    'cortex',
    'cosigner',
    'cosmetics',
    'cosmic',
    'cosmos',
    'cosponsor',
    'cost',
    'cottage',
    'cotton',
    'couch',
    'cough',
    'could',
    'countable',
    'countdown',
    'counting',
    'countless',
    'country',
    'county',
    'courier',
    'covenant',
    'cover',
    'coveted',
    'coveting',
    'coyness',
    'cozily',
    'coziness',
    'cozy',
    'crabbing',
    'crabgrass',
    'crablike',
    'crabmeat',
    'cradle',
    'cradling',
    'crafter',
    'craftily',
    'craftsman',
    'craftwork',
    'crafty',
    'cramp',
    'cranberry',
    'crane',
    'cranial',
    'cranium',
    'crank',
    'crate',
    'crave',
    'craving',
    'crawfish',
    'crawlers',
    'crawling',
    'crayfish',
    'crayon',
    'crazed',
    'crazily',
    'craziness',
    'crazy',
    'creamed',
    'creamer',
    'creamlike',
    'crease',
    'creasing',
    'creatable',
    'create',
    'creation',
    'creative',
    'creature',
    'credible',
    'credibly',
    'credit',
    'creed',
    'creme',
    'creole',
    'crepe',
    'crept',
    'crescent',
    'crested',
    'cresting',
    'crestless',
    'crevice',
    'crewless',
    'crewman',
    'crewmate',
    'crib',
    'cricket',
    'cried',
    'crier',
    'crimp',
    'crimson',
    'cringe',
    'cringing',
    'crinkle',
    'crinkly',
    'crisped',
    'crisping',
    'crisply',
    'crispness',
    'crispy',
    'criteria',
    'critter',
    'croak',
    'crock',
    'crook',
    'croon',
    'crop',
    'cross',
    'crouch',
    'crouton',
    'crowbar',
    'crowd',
    'crown',
    'crucial',
    'crudely',
    'crudeness',
    'cruelly',
    'cruelness',
    'cruelty',
    'crumb',
    'crummiest',
    'crummy',
    'crumpet',
    'crumpled',
    'cruncher',
    'crunching',
    'crunchy',
    'crusader',
    'crushable',
    'crushed',
    'crusher',
    'crushing',
    'crust',
    'crux',
    'crying',
    'cryptic',
    'crystal',
    'cubbyhole',
    'cube',
    'cubical',
    'cubicle',
    'cucumber',
    'cuddle',
    'cuddly',
    'cufflink',
    'culinary',
    'culminate',
    'culpable',
    'culprit',
    'cultivate',
    'cultural',
    'culture',
    'cupbearer',
    'cupcake',
    'cupid',
    'cupped',
    'cupping',
    'curable',
    'curator',
    'curdle',
    'cure',
    'curfew',
    'curing',
    'curled',
    'curler',
    'curliness',
    'curling',
    'curly',
    'curry',
    'curse',
    'cursive',
    'cursor',
    'curtain',
    'curtly',
    'curtsy',
    'curvature',
    'curve',
    'curvy',
    'cushy',
    'cusp',
    'cussed',
    'custard',
    'custodian',
    'custody',
    'customary',
    'customer',
    'customize',
    'customs',
    'cut',
    'cycle',
    'cyclic',
    'cycling',
    'cyclist',
    'cylinder',
    'cymbal',
    'cytoplasm',
    'cytoplast',
    'dab',
    'dad',
    'daffodil',
    'dagger',
    'daily',
    'daintily',
    'dainty',
    'dairy',
    'daisy',
    'dallying',
    'dance',
    'dancing',
    'dandelion',
    'dander',
    'dandruff',
    'dandy',
    'danger',
    'dangle',
    'dangling',
    'daredevil',
    'dares',
    'daringly',
    'darkened',
    'darkening',
    'darkish',
    'darkness',
    'darkroom',
    'darling',
    'darn',
    'dart',
    'darwinism',
    'dash',
    'dastardly',
    'data',
    'datebook',
    'dating',
    'daughter',
    'daunting',
    'dawdler',
    'dawn',
    'daybed',
    'daybreak',
    'daycare',
    'daydream',
    'daylight',
    'daylong',
    'dayroom',
    'daytime',
    'dazzler',
    'dazzling',
    'deacon',
    'deafening',
    'deafness',
    'dealer',
    'dealing',
    'dealmaker',
    'dealt',
    'dean',
    'debatable',
    'debate',
    'debating',
    'debit',
    'debrief',
    'debtless',
    'debtor',
    'debug',
    'debunk',
    'decade',
    'decaf',
    'decal',
    'decathlon',
    'decay',
    'deceased',
    'deceit',
    'deceiver',
    'deceiving',
    'december',
    'decency',
    'decent',
    'deception',
    'deceptive',
    'decibel',
    'decidable',
    'decimal',
    'decimeter',
    'decipher',
    'deck',
    'declared',
    'decline',
    'decode',
    'decompose',
    'decorated',
    'decorator',
    'decoy',
    'decrease',
    'decree',
    'dedicate',
    'dedicator',
    'deduce',
    'deduct',
    'deed',
    'deem',
    'deepen',
    'deeply',
    'deepness',
    'deface',
    'defacing',
    'defame',
    'default',
    'defeat',
    'defection',
    'defective',
    'defendant',
    'defender',
    'defense',
    'defensive',
    'deferral',
    'deferred',
    'defiance',
    'defiant',
    'defile',
    'defiling',
    'define',
    'definite',
    'deflate',
    'deflation',
    'deflator',
    'deflected',
    'deflector',
    'defog',
    'deforest',
    'defraud',
    'defrost',
    'deftly',
    'defuse',
    'defy',
    'degraded',
    'degrading',
    'degrease',
    'degree',
    'dehydrate',
    'deity',
    'dejected',
    'delay',
    'delegate',
    'delegator',
    'delete',
    'deletion',
    'delicacy',
    'delicate',
    'delicious',
    'delighted',
    'delirious',
    'delirium',
    'deliverer',
    'delivery',
    'delouse',
    'delta',
    'deluge',
    'delusion',
    'deluxe',
    'demanding',
    'demeaning',
    'demeanor',
    'demise',
    'democracy',
    'democrat',
    'demote',
    'demotion',
    'demystify',
    'denatured',
    'deniable',
    'denial',
    'denim',
    'denote',
    'dense',
    'density',
    'dental',
    'dentist',
    'denture',
    'deny',
    'deodorant',
    'deodorize',
    'departed',
    'departure',
    'depict',
    'deplete',
    'depletion',
    'deplored',
    'deploy',
    'deport',
    'depose',
    'depraved',
    'depravity',
    'deprecate',
    'depress',
    'deprive',
    'depth',
    'deputize',
    'deputy',
    'derail',
    'deranged',
    'derby',
    'derived',
    'desecrate',
    'deserve',
    'deserving',
    'designate',
    'designed',
    'designer',
    'designing',
    'deskbound',
    'desktop',
    'deskwork',
    'desolate',
    'despair',
    'despise',
    'despite',
    'destiny',
    'destitute',
    'destruct',
    'detached',
    'detail',
    'detection',
    'detective',
    'detector',
    'detention',
    'detergent',
    'detest',
    'detonate',
    'detonator',
    'detoxify',
    'detract',
    'deuce',
    'devalue',
    'deviancy',
    'deviant',
    'deviate',
    'deviation',
    'deviator',
    'device',
    'devious',
    'devotedly',
    'devotee',
    'devotion',
    'devourer',
    'devouring',
    'devoutly',
    'dexterity',
    'dexterous',
    'diabetes',
    'diabetic',
    'diabolic',
    'diagnoses',
    'diagnosis',
    'diagram',
    'dial',
    'diameter',
    'diaper',
    'diaphragm',
    'diary',
    'dice',
    'dicing',
    'dictate',
    'dictation',
    'dictator',
    'difficult',
    'diffused',
    'diffuser',
    'diffusion',
    'diffusive',
    'dig',
    'dilation',
    'diligence',
    'diligent',
    'dill',
    'dilute',
    'dime',
    'diminish',
    'dimly',
    'dimmed',
    'dimmer',
    'dimness',
    'dimple',
    'diner',
    'dingbat',
    'dinghy',
    'dinginess',
    'dingo',
    'dingy',
    'dining',
    'dinner',
    'diocese',
    'dioxide',
    'diploma',
    'dipped',
    'dipper',
    'dipping',
    'directed',
    'direction',
    'directive',
    'directly',
    'directory',
    'direness',
    'dirtiness',
    'disabled',
    'disagree',
    'disallow',
    'disarm',
    'disarray',
    'disaster',
    'disband',
    'disbelief',
    'disburse',
    'discard',
    'discern',
    'discharge',
    'disclose',
    'discolor',
    'discount',
    'discourse',
    'discover',
    'discuss',
    'disdain',
    'disengage',
    'disfigure',
    'disgrace',
    'dish',
    'disinfect',
    'disjoin',
    'disk',
    'dislike',
    'disliking',
    'dislocate',
    'dislodge',
    'disloyal',
    'dismantle',
    'dismay',
    'dismiss',
    'dismount',
    'disobey',
    'disorder',
    'disown',
    'disparate',
    'disparity',
    'dispatch',
    'dispense',
    'dispersal',
    'dispersed',
    'disperser',
    'displace',
    'display',
    'displease',
    'disposal',
    'dispose',
    'disprove',
    'dispute',
    'disregard',
    'disrupt',
    'dissuade',
    'distance',
    'distant',
    'distaste',
    'distill',
    'distinct',
    'distort',
    'distract',
    'distress',
    'district',
    'distrust',
    'ditch',
    'ditto',
    'ditzy',
    'dividable',
    'divided',
    'dividend',
    'dividers',
    'dividing',
    'divinely',
    'diving',
    'divinity',
    'divisible',
    'divisibly',
    'division',
    'divisive',
    'divorcee',
    'dizziness',
    'dizzy',
    'doable',
    'docile',
    'dock',
    'doctrine',
    'document',
    'dodge',
    'dodgy',
    'doily',
    'doing',
    'dole',
    'dollar',
    'dollhouse',
    'dollop',
    'dolly',
    'dolphin',
    'domain',
    'domelike',
    'domestic',
    'dominion',
    'dominoes',
    'donated',
    'donation',
    'donator',
    'donor',
    'donut',
    'doodle',
    'doorbell',
    'doorframe',
    'doorknob',
    'doorman',
    'doormat',
    'doornail',
    'doorpost',
    'doorstep',
    'doorstop',
    'doorway',
    'doozy',
    'dork',
    'dormitory',
    'dorsal',
    'dosage',
    'dose',
    'dotted',
    'doubling',
    'douche',
    'dove',
    'down',
    'dowry',
    'doze',
    'drab',
    'dragging',
    'dragonfly',
    'dragonish',
    'dragster',
    'drainable',
    'drainage',
    'drained',
    'drainer',
    'drainpipe',
    'dramatic',
    'dramatize',
    'drank',
    'drapery',
    'drastic',
    'draw',
    'dreaded',
    'dreadful',
    'dreadlock',
    'dreamboat',
    'dreamily',
    'dreamland',
    'dreamless',
    'dreamlike',
    'dreamt',
    'dreamy',
    'drearily',
    'dreary',
    'drench',
    'dress',
    'drew',
    'dribble',
    'dried',
    'drier',
    'drift',
    'driller',
    'drilling',
    'drinkable',
    'drinking',
    'dripping',
    'drippy',
    'drivable',
    'driven',
    'driver',
    'driveway',
    'driving',
    'drizzle',
    'drizzly',
    'drone',
    'drool',
    'droop',
    'drop-down',
    'dropbox',
    'dropkick',
    'droplet',
    'dropout',
    'dropper',
    'drove',
    'drown',
    'drowsily',
    'drudge',
    'drum',
    'dry',
    'dubbed',
    'dubiously',
    'duchess',
    'duckbill',
    'ducking',
    'duckling',
    'ducktail',
    'ducky',
    'duct',
    'dude',
    'duffel',
    'dugout',
    'duh',
    'duke',
    'duller',
    'dullness',
    'duly',
    'dumping',
    'dumpling',
    'dumpster',
    'duo',
    'dupe',
    'duplex',
    'duplicate',
    'duplicity',
    'durable',
    'durably',
    'duration',
    'duress',
    'during',
    'dusk',
    'dust',
    'dutiful',
    'duty',
    'duvet',
    'dwarf',
    'dweeb',
    'dwelled',
    'dweller',
    'dwelling',
    'dwindle',
    'dwindling',
    'dynamic',
    'dynamite',
    'dynasty',
    'dyslexia',
    'dyslexic',
    'each',
    'eagle',
    'earache',
    'eardrum',
    'earflap',
    'earful',
    'earlobe',
    'early',
    'earmark',
    'earmuff',
    'earphone',
    'earpiece',
    'earplugs',
    'earring',
    'earshot',
    'earthen',
    'earthlike',
    'earthling',
    'earthly',
    'earthworm',
    'earthy',
    'earwig',
    'easeful',
    'easel',
    'easiest',
    'easily',
    'easiness',
    'easing',
    'eastbound',
    'eastcoast',
    'easter',
    'eastward',
    'eatable',
    'eaten',
    'eatery',
    'eating',
    'eats',
    'ebay',
    'ebony',
    'ebook',
    'ecard',
    'eccentric',
    'echo',
    'eclair',
    'eclipse',
    'ecologist',
    'ecology',
    'economic',
    'economist',
    'economy',
    'ecosphere',
    'ecosystem',
    'edge',
    'edginess',
    'edging',
    'edgy',
    'edition',
    'editor',
    'educated',
    'education',
    'educator',
    'eel',
    'effective',
    'effects',
    'efficient',
    'effort',
    'eggbeater',
    'egging',
    'eggnog',
    'eggplant',
    'eggshell',
    'egomaniac',
    'egotism',
    'egotistic',
    'either',
    'eject',
    'elaborate',
    'elastic',
    'elated',
    'elbow',
    'eldercare',
    'elderly',
    'eldest',
    'electable',
    'election',
    'elective',
    'elephant',
    'elevate',
    'elevating',
    'elevation',
    'elevator',
    'eleven',
    'elf',
    'eligible',
    'eligibly',
    'eliminate',
    'elite',
    'elitism',
    'elixir',
    'elk',
    'ellipse',
    'elliptic',
    'elm',
    'elongated',
    'elope',
    'eloquence',
    'eloquent',
    'elsewhere',
    'elude',
    'elusive',
    'elves',
    'email',
    'embargo',
    'embark',
    'embassy',
    'embattled',
    'embellish',
    'ember',
    'embezzle',
    'emblaze',
    'emblem',
    'embody',
    'embolism',
    'emboss',
    'embroider',
    'emcee',
    'emerald',
    'emergency',
    'emission',
    'emit',
    'emote',
    'emoticon',
    'emotion',
    'empathic',
    'empathy',
    'emperor',
    'emphases',
    'emphasis',
    'emphasize',
    'emphatic',
    'empirical',
    'employed',
    'employee',
    'employer',
    'emporium',
    'empower',
    'emptier',
    'emptiness',
    'empty',
    'emu',
    'enable',
    'enactment',
    'enamel',
    'enchanted',
    'enchilada',
    'encircle',
    'enclose',
    'enclosure',
    'encode',
    'encore',
    'encounter',
    'encourage',
    'encroach',
    'encrust',
    'encrypt',
    'endanger',
    'endeared',
    'endearing',
    'ended',
    'ending',
    'endless',
    'endnote',
    'endocrine',
    'endorphin',
    'endorse',
    'endowment',
    'endpoint',
    'endurable',
    'endurance',
    'enduring',
    'energetic',
    'energize',
    'energy',
    'enforced',
    'enforcer',
    'engaged',
    'engaging',
    'engine',
    'engorge',
    'engraved',
    'engraver',
    'engraving',
    'engross',
    'engulf',
    'enhance',
    'enigmatic',
    'enjoyable',
    'enjoyably',
    'enjoyer',
    'enjoying',
    'enjoyment',
    'enlarged',
    'enlarging',
    'enlighten',
    'enlisted',
    'enquirer',
    'enrage',
    'enrich',
    'enroll',
    'enslave',
    'ensnare',
    'ensure',
    'entail',
    'entangled',
    'entering',
    'entertain',
    'enticing',
    'entire',
    'entitle',
    'entity',
    'entomb',
    'entourage',
    'entrap',
    'entree',
    'entrench',
    'entrust',
    'entryway',
    'entwine',
    'enunciate',
    'envelope',
    'enviable',
    'enviably',
    'envious',
    'envision',
    'envoy',
    'envy',
    'enzyme',
    'epic',
    'epidemic',
    'epidermal',
    'epidermis',
    'epidural',
    'epilepsy',
    'epileptic',
    'epilogue',
    'epiphany',
    'episode',
    'equal',
    'equate',
    'equation',
    'equator',
    'equinox',
    'equipment',
    'equity',
    'equivocal',
    'eradicate',
    'erasable',
    'erased',
    'eraser',
    'erasure',
    'ergonomic',
    'errand',
    'errant',
    'erratic',
    'error',
    'erupt',
    'escalate',
    'escalator',
    'escapable',
    'escapade',
    'escapist',
    'escargot',
    'eskimo',
    'esophagus',
    'espionage',
    'espresso',
    'esquire',
    'essay',
    'essence',
    'essential',
    'establish',
    'estate',
    'esteemed',
    'estimate',
    'estimator',
    'estranged',
    'estrogen',
    'etching',
    'eternal',
    'eternity',
    'ethanol',
    'ether',
    'ethically',
    'ethics',
    'euphemism',
    'evacuate',
    'evacuee',
    'evade',
    'evaluate',
    'evaluator',
    'evaporate',
    'evasion',
    'evasive',
    'even',
    'everglade',
    'evergreen',
    'everybody',
    'everyday',
    'everyone',
    'evict',
    'evidence',
    'evident',
    'evil',
    'evoke',
    'evolution',
    'evolve',
    'exact',
    'exalted',
    'example',
    'excavate',
    'excavator',
    'exceeding',
    'exception',
    'excess',
    'exchange',
    'excitable',
    'exciting',
    'exclaim',
    'exclude',
    'excluding',
    'exclusion',
    'exclusive',
    'excretion',
    'excretory',
    'excursion',
    'excusable',
    'excusably',
    'excuse',
    'exemplary',
    'exemplify',
    'exemption',
    'exerciser',
    'exert',
    'exes',
    'exfoliate',
    'exhale',
    'exhaust',
    'exhume',
    'exile',
    'existing',
    'exit',
    'exodus',
    'exonerate',
    'exorcism',
    'exorcist',
    'expand',
    'expanse',
    'expansion',
    'expansive',
    'expectant',
    'expedited',
    'expediter',
    'expel',
    'expend',
    'expenses',
    'expensive',
    'expert',
    'expire',
    'expiring',
    'explain',
    'expletive',
    'explicit',
    'explode',
    'exploit',
    'explore',
    'exploring',
    'exponent',
    'exporter',
    'exposable',
    'expose',
    'exposure',
    'express',
    'expulsion',
    'exquisite',
    'extended',
    'extending',
    'extent',
    'extenuate',
    'exterior',
    'external',
    'extinct',
    'extortion',
    'extradite',
    'extras',
    'extrovert',
    'extrude',
    'extruding',
    'exuberant',
    'fable',
    'fabric',
    'fabulous',
    'facebook',
    'facecloth',
    'facedown',
    'faceless',
    'facelift',
    'faceplate',
    'faceted',
    'facial',
    'facility',
    'facing',
    'facsimile',
    'faction',
    'factoid',
    'factor',
    'factsheet',
    'factual',
    'faculty',
    'fade',
    'fading',
    'failing',
    'falcon',
    'fall',
    'false',
    'falsify',
    'fame',
    'familiar',
    'family',
    'famine',
    'famished',
    'fanatic',
    'fancied',
    'fanciness',
    'fancy',
    'fanfare',
    'fang',
    'fanning',
    'fantasize',
    'fantastic',
    'fantasy',
    'fascism',
    'fastball',
    'faster',
    'fasting',
    'fastness',
    'faucet',
    'favorable',
    'favorably',
    'favored',
    'favoring',
    'favorite',
    'fax',
    'feast',
    'federal',
    'fedora',
    'feeble',
    'feed',
    'feel',
    'feisty',
    'feline',
    'felt-tip',
    'feminine',
    'feminism',
    'feminist',
    'feminize',
    'femur',
    'fence',
    'fencing',
    'fender',
    'ferment',
    'fernlike',
    'ferocious',
    'ferocity',
    'ferret',
    'ferris',
    'ferry',
    'fervor',
    'fester',
    'festival',
    'festive',
    'festivity',
    'fetal',
    'fetch',
    'fever',
    'fiber',
    'fiction',
    'fiddle',
    'fiddling',
    'fidelity',
    'fidgeting',
    'fidgety',
    'fifteen',
    'fifth',
    'fiftieth',
    'fifty',
    'figment',
    'figure',
    'figurine',
    'filing',
    'filled',
    'filler',
    'filling',
    'film',
    'filter',
    'filth',
    'filtrate',
    'finale',
    'finalist',
    'finalize',
    'finally',
    'finance',
    'financial',
    'finch',
    'fineness',
    'finer',
    'finicky',
    'finished',
    'finisher',
    'finishing',
    'finite',
    'finless',
    'finlike',
    'fiscally',
    'fit',
    'five',
    'flaccid',
    'flagman',
    'flagpole',
    'flagship',
    'flagstick',
    'flagstone',
    'flail',
    'flakily',
    'flaky',
    'flame',
    'flammable',
    'flanked',
    'flanking',
    'flannels',
    'flap',
    'flaring',
    'flashback',
    'flashbulb',
    'flashcard',
    'flashily',
    'flashing',
    'flashy',
    'flask',
    'flatbed',
    'flatfoot',
    'flatly',
    'flatness',
    'flatten',
    'flattered',
    'flatterer',
    'flattery',
    'flattop',
    'flatware',
    'flatworm',
    'flavored',
    'flavorful',
    'flavoring',
    'flaxseed',
    'fled',
    'fleshed',
    'fleshy',
    'flick',
    'flier',
    'flight',
    'flinch',
    'fling',
    'flint',
    'flip',
    'flirt',
    'float',
    'flock',
    'flogging',
    'flop',
    'floral',
    'florist',
    'floss',
    'flounder',
    'flyable',
    'flyaway',
    'flyer',
    'flying',
    'flyover',
    'flypaper',
    'foam',
    'foe',
    'fog',
    'foil',
    'folic',
    'folk',
    'follicle',
    'follow',
    'fondling',
    'fondly',
    'fondness',
    'fondue',
    'font',
    'food',
    'fool',
    'footage',
    'football',
    'footbath',
    'footboard',
    'footer',
    'footgear',
    'foothill',
    'foothold',
    'footing',
    'footless',
    'footman',
    'footnote',
    'footpad',
    'footpath',
    'footprint',
    'footrest',
    'footsie',
    'footsore',
    'footwear',
    'footwork',
    'fossil',
    'foster',
    'founder',
    'founding',
    'fountain',
    'fox',
    'foyer',
    'fraction',
    'fracture',
    'fragile',
    'fragility',
    'fragment',
    'fragrance',
    'fragrant',
    'frail',
    'frame',
    'framing',
    'frantic',
    'fraternal',
    'frayed',
    'fraying',
    'frays',
    'freckled',
    'freckles',
    'freebase',
    'freebee',
    'freebie',
    'freedom',
    'freefall',
    'freehand',
    'freeing',
    'freeload',
    'freely',
    'freemason',
    'freeness',
    'freestyle',
    'freeware',
    'freeway',
    'freewill',
    'freezable',
    'freezing',
    'freight',
    'french',
    'frenzied',
    'frenzy',
    'frequency',
    'frequent',
    'fresh',
    'fretful',
    'fretted',
    'friction',
    'friday',
    'fridge',
    'fried',
    'friend',
    'frighten',
    'frightful',
    'frigidity',
    'frigidly',
    'frill',
    'fringe',
    'frisbee',
    'frisk',
    'fritter',
    'frivolous',
    'frolic',
    'from',
    'front',
    'frostbite',
    'frosted',
    'frostily',
    'frosting',
    'frostlike',
    'frosty',
    'froth',
    'frown',
    'frozen',
    'fructose',
    'frugality',
    'frugally',
    'fruit',
    'frustrate',
    'frying',
    'gab',
    'gaffe',
    'gag',
    'gainfully',
    'gaining',
    'gains',
    'gala',
    'gallantly',
    'galleria',
    'gallery',
    'galley',
    'gallon',
    'gallows',
    'gallstone',
    'galore',
    'galvanize',
    'gambling',
    'game',
    'gaming',
    'gamma',
    'gander',
    'gangly',
    'gangrene',
    'gangway',
    'gap',
    'garage',
    'garbage',
    'garden',
    'gargle',
    'garland',
    'garlic',
    'garment',
    'garnet',
    'garnish',
    'garter',
    'gas',
    'gatherer',
    'gathering',
    'gating',
    'gauging',
    'gauntlet',
    'gauze',
    'gave',
    'gawk',
    'gazing',
    'gear',
    'gecko',
    'geek',
    'geiger',
    'gem',
    'gender',
    'generic',
    'generous',
    'genetics',
    'genre',
    'gentile',
    'gentleman',
    'gently',
    'gents',
    'geography',
    'geologic',
    'geologist',
    'geology',
    'geometric',
    'geometry',
    'geranium',
    'gerbil',
    'geriatric',
    'germicide',
    'germinate',
    'germless',
    'germproof',
    'gestate',
    'gestation',
    'gesture',
    'getaway',
    'getting',
    'getup',
    'giant',
    'gibberish',
    'giblet',
    'giddily',
    'giddiness',
    'giddy',
    'gift',
    'gigabyte',
    'gigahertz',
    'gigantic',
    'giggle',
    'giggling',
    'giggly',
    'gigolo',
    'gilled',
    'gills',
    'gimmick',
    'girdle',
    'giveaway',
    'given',
    'giver',
    'giving',
    'gizmo',
    'gizzard',
    'glacial',
    'glacier',
    'glade',
    'gladiator',
    'gladly',
    'glamorous',
    'glamour',
    'glance',
    'glancing',
    'glandular',
    'glare',
    'glaring',
    'glass',
    'glaucoma',
    'glazing',
    'gleaming',
    'gleeful',
    'glider',
    'gliding',
    'glimmer',
    'glimpse',
    'glisten',
    'glitch',
    'glitter',
    'glitzy',
    'gloater',
    'gloating',
    'gloomily',
    'gloomy',
    'glorified',
    'glorifier',
    'glorify',
    'glorious',
    'glory',
    'gloss',
    'glove',
    'glowing',
    'glowworm',
    'glucose',
    'glue',
    'gluten',
    'glutinous',
    'glutton',
    'gnarly',
    'gnat',
    'goal',
    'goatskin',
    'goes',
    'goggles',
    'going',
    'goldfish',
    'goldmine',
    'goldsmith',
    'golf',
    'goliath',
    'gonad',
    'gondola',
    'gone',
    'gong',
    'good',
    'gooey',
    'goofball',
    'goofiness',
    'goofy',
    'google',
    'goon',
    'gopher',
    'gore',
    'gorged',
    'gorgeous',
    'gory',
    'gosling',
    'gossip',
    'gothic',
    'gotten',
    'gout',
    'gown',
    'grab',
    'graceful',
    'graceless',
    'gracious',
    'gradation',
    'graded',
    'grader',
    'gradient',
    'grading',
    'gradually',
    'graduate',
    'graffiti',
    'grafted',
    'grafting',
    'grain',
    'granddad',
    'grandkid',
    'grandly',
    'grandma',
    'grandpa',
    'grandson',
    'granite',
    'granny',
    'granola',
    'grant',
    'granular',
    'grape',
    'graph',
    'grapple',
    'grappling',
    'grasp',
    'grass',
    'gratified',
    'gratify',
    'grating',
    'gratitude',
    'gratuity',
    'gravel',
    'graveness',
    'graves',
    'graveyard',
    'gravitate',
    'gravity',
    'gravy',
    'gray',
    'grazing',
    'greasily',
    'greedily',
    'greedless',
    'greedy',
    'green',
    'greeter',
    'greeting',
    'grew',
    'greyhound',
    'grid',
    'grief',
    'grievance',
    'grieving',
    'grievous',
    'grill',
    'grimace',
    'grimacing',
    'grime',
    'griminess',
    'grimy',
    'grinch',
    'grinning',
    'grip',
    'gristle',
    'grit',
    'groggily',
    'groggy',
    'groin',
    'groom',
    'groove',
    'grooving',
    'groovy',
    'grope',
    'ground',
    'grouped',
    'grout',
    'grove',
    'grower',
    'growing',
    'growl',
    'grub',
    'grudge',
    'grudging',
    'grueling',
    'gruffly',
    'grumble',
    'grumbling',
    'grumbly',
    'grumpily',
    'grunge',
    'grunt',
    'guacamole',
    'guidable',
    'guidance',
    'guide',
    'guiding',
    'guileless',
    'guise',
    'gulf',
    'gullible',
    'gully',
    'gulp',
    'gumball',
    'gumdrop',
    'gumminess',
    'gumming',
    'gummy',
    'gurgle',
    'gurgling',
    'guru',
    'gush',
    'gusto',
    'gusty',
    'gutless',
    'guts',
    'gutter',
    'guy',
    'guzzler',
    'gyration',
    'habitable',
    'habitant',
    'habitat',
    'habitual',
    'hacked',
    'hacker',
    'hacking',
    'hacksaw',
    'had',
    'haggler',
    'haiku',
    'half',
    'halogen',
    'halt',
    'halved',
    'halves',
    'hamburger',
    'hamlet',
    'hammock',
    'hamper',
    'hamster',
    'hamstring',
    'handbag',
    'handball',
    'handbook',
    'handbrake',
    'handcart',
    'handclap',
    'handclasp',
    'handcraft',
    'handcuff',
    'handed',
    'handful',
    'handgrip',
    'handgun',
    'handheld',
    'handiness',
    'handiwork',
    'handlebar',
    'handled',
    'handler',
    'handling',
    'handmade',
    'handoff',
    'handpick',
    'handprint',
    'handrail',
    'handsaw',
    'handset',
    'handsfree',
    'handshake',
    'handstand',
    'handwash',
    'handwork',
    'handwoven',
    'handwrite',
    'handyman',
    'hangnail',
    'hangout',
    'hangover',
    'hangup',
    'hankering',
    'hankie',
    'hanky',
    'haphazard',
    'happening',
    'happier',
    'happiest',
    'happily',
    'happiness',
    'happy',
    'harbor',
    'hardcopy',
    'hardcore',
    'hardcover',
    'harddisk',
    'hardened',
    'hardener',
    'hardening',
    'hardhat',
    'hardhead',
    'hardiness',
    'hardly',
    'hardness',
    'hardship',
    'hardware',
    'hardwired',
    'hardwood',
    'hardy',
    'harmful',
    'harmless',
    'harmonica',
    'harmonics',
    'harmonize',
    'harmony',
    'harness',
    'harpist',
    'harsh',
    'harvest',
    'hash',
    'hassle',
    'haste',
    'hastily',
    'hastiness',
    'hasty',
    'hatbox',
    'hatchback',
    'hatchery',
    'hatchet',
    'hatching',
    'hatchling',
    'hate',
    'hatless',
    'hatred',
    'haunt',
    'haven',
    'hazard',
    'hazelnut',
    'hazily',
    'haziness',
    'hazing',
    'hazy',
    'headache',
    'headband',
    'headboard',
    'headcount',
    'headdress',
    'headed',
    'header',
    'headfirst',
    'headgear',
    'heading',
    'headlamp',
    'headless',
    'headlock',
    'headphone',
    'headpiece',
    'headrest',
    'headroom',
    'headscarf',
    'headset',
    'headsman',
    'headstand',
    'headstone',
    'headway',
    'headwear',
    'heap',
    'heat',
    'heave',
    'heavily',
    'heaviness',
    'heaving',
    'hedge',
    'hedging',
    'heftiness',
    'hefty',
    'helium',
    'helmet',
    'helper',
    'helpful',
    'helping',
    'helpless',
    'helpline',
    'hemlock',
    'hemstitch',
    'hence',
    'henchman',
    'henna',
    'herald',
    'herbal',
    'herbicide',
    'herbs',
    'heritage',
    'hermit',
    'heroics',
    'heroism',
    'herring',
    'herself',
    'hertz',
    'hesitancy',
    'hesitant',
    'hesitate',
    'hexagon',
    'hexagram',
    'hubcap',
    'huddle',
    'huddling',
    'huff',
    'hug',
    'hula',
    'hulk',
    'hull',
    'human',
    'humble',
    'humbling',
    'humbly',
    'humid',
    'humiliate',
    'humility',
    'humming',
    'hummus',
    'humongous',
    'humorist',
    'humorless',
    'humorous',
    'humpback',
    'humped',
    'humvee',
    'hunchback',
    'hundredth',
    'hunger',
    'hungrily',
    'hungry',
    'hunk',
    'hunter',
    'hunting',
    'huntress',
    'huntsman',
    'hurdle',
    'hurled',
    'hurler',
    'hurling',
    'hurray',
    'hurricane',
    'hurried',
    'hurry',
    'hurt',
    'husband',
    'hush',
    'husked',
    'huskiness',
    'hut',
    'hybrid',
    'hydrant',
    'hydrated',
    'hydration',
    'hydrogen',
    'hydroxide',
    'hyperlink',
    'hypertext',
    'hyphen',
    'hypnoses',
    'hypnosis',
    'hypnotic',
    'hypnotism',
    'hypnotist',
    'hypnotize',
    'hypocrisy',
    'hypocrite',
    'ibuprofen',
    'ice',
    'iciness',
    'icing',
    'icky',
    'icon',
    'icy',
    'idealism',
    'idealist',
    'idealize',
    'ideally',
    'idealness',
    'identical',
    'identify',
    'identity',
    'ideology',
    'idiocy',
    'idiom',
    'idly',
    'igloo',
    'ignition',
    'ignore',
    'iguana',
    'illicitly',
    'illusion',
    'illusive',
    'image',
    'imaginary',
    'imagines',
    'imaging',
    'imbecile',
    'imitate',
    'imitation',
    'immature',
    'immerse',
    'immersion',
    'imminent',
    'immobile',
    'immodest',
    'immorally',
    'immortal',
    'immovable',
    'immovably',
    'immunity',
    'immunize',
    'impaired',
    'impale',
    'impart',
    'impatient',
    'impeach',
    'impeding',
    'impending',
    'imperfect',
    'imperial',
    'impish',
    'implant',
    'implement',
    'implicate',
    'implicit',
    'implode',
    'implosion',
    'implosive',
    'imply',
    'impolite',
    'important',
    'importer',
    'impose',
    'imposing',
    'impotence',
    'impotency',
    'impotent',
    'impound',
    'imprecise',
    'imprint',
    'imprison',
    'impromptu',
    'improper',
    'improve',
    'improving',
    'improvise',
    'imprudent',
    'impulse',
    'impulsive',
    'impure',
    'impurity',
    'iodine',
    'iodize',
    'ion',
    'ipad',
    'iphone',
    'ipod',
    'irate',
    'irk',
    'iron',
    'irregular',
    'irrigate',
    'irritable',
    'irritably',
    'irritant',
    'irritate',
    'islamic',
    'islamist',
    'isolated',
    'isolating',
    'isolation',
    'isotope',
    'issue',
    'issuing',
    'italicize',
    'italics',
    'item',
    'itinerary',
    'itunes',
    'ivory',
    'ivy',
    'jab',
    'jackal',
    'jacket',
    'jackknife',
    'jackpot',
    'jailbird',
    'jailbreak',
    'jailer',
    'jailhouse',
    'jalapeno',
    'jam',
    'janitor',
    'january',
    'jargon',
    'jarring',
    'jasmine',
    'jaundice',
    'jaunt',
    'java',
    'jawed',
    'jawless',
    'jawline',
    'jaws',
    'jaybird',
    'jaywalker',
    'jazz',
    'jeep',
    'jeeringly',
    'jellied',
    'jelly',
    'jersey',
    'jester',
    'jet',
    'jiffy',
    'jigsaw',
    'jimmy',
    'jingle',
    'jingling',
    'jinx',
    'jitters',
    'jittery',
    'job',
    'jockey',
    'jockstrap',
    'jogger',
    'jogging',
    'john',
    'joining',
    'jokester',
    'jokingly',
    'jolliness',
    'jolly',
    'jolt',
    'jot',
    'jovial',
    'joyfully',
    'joylessly',
    'joyous',
    'joyride',
    'joystick',
    'jubilance',
    'jubilant',
    'judge',
    'judgingly',
    'judicial',
    'judiciary',
    'judo',
    'juggle',
    'juggling',
    'jugular',
    'juice',
    'juiciness',
    'juicy',
    'jujitsu',
    'jukebox',
    'july',
    'jumble',
    'jumbo',
    'jump',
    'junction',
    'juncture',
    'june',
    'junior',
    'juniper',
    'junkie',
    'junkman',
    'junkyard',
    'jurist',
    'juror',
    'jury',
    'justice',
    'justifier',
    'justify',
    'justly',
    'justness',
    'juvenile',
    'kabob',
    'kangaroo',
    'karaoke',
    'karate',
    'karma',
    'kebab',
    'keenly',
    'keenness',
    'keep',
    'keg',
    'kelp',
    'kennel',
    'kept',
    'kerchief',
    'kerosene',
    'kettle',
    'kick',
    'kiln',
    'kilobyte',
    'kilogram',
    'kilometer',
    'kilowatt',
    'kilt',
    'kimono',
    'kindle',
    'kindling',
    'kindly',
    'kindness',
    'kindred',
    'kinetic',
    'kinfolk',
    'king',
    'kinship',
    'kinsman',
    'kinswoman',
    'kissable',
    'kisser',
    'kissing',
    'kitchen',
    'kite',
    'kitten',
    'kitty',
    'kiwi',
    'kleenex',
    'knapsack',
    'knee',
    'knelt',
    'knickers',
    'knoll',
    'koala',
    'kooky',
    'kosher',
    'krypton',
    'kudos',
    'kung',
    'labored',
    'laborer',
    'laboring',
    'laborious',
    'labrador',
    'ladder',
    'ladies',
    'ladle',
    'ladybug',
    'ladylike',
    'lagged',
    'lagging',
    'lagoon',
    'lair',
    'lake',
    'lance',
    'landed',
    'landfall',
    'landfill',
    'landing',
    'landlady',
    'landless',
    'landline',
    'landlord',
    'landmark',
    'landmass',
    'landmine',
    'landowner',
    'landscape',
    'landside',
    'landslide',
    'language',
    'lankiness',
    'lanky',
    'lantern',
    'lapdog',
    'lapel',
    'lapped',
    'lapping',
    'laptop',
    'lard',
    'large',
    'lark',
    'lash',
    'lasso',
    'last',
    'latch',
    'late',
    'lather',
    'latitude',
    'latrine',
    'latter',
    'latticed',
    'launch',
    'launder',
    'laundry',
    'laurel',
    'lavender',
    'lavish',
    'laxative',
    'lazily',
    'laziness',
    'lazy',
    'lecturer',
    'left',
    'legacy',
    'legal',
    'legend',
    'legged',
    'leggings',
    'legible',
    'legibly',
    'legislate',
    'lego',
    'legroom',
    'legume',
    'legwarmer',
    'legwork',
    'lemon',
    'lend',
    'length',
    'lens',
    'lent',
    'leotard',
    'lesser',
    'letdown',
    'lethargic',
    'lethargy',
    'letter',
    'lettuce',
    'level',
    'leverage',
    'levers',
    'levitate',
    'levitator',
    'liability',
    'liable',
    'liberty',
    'librarian',
    'library',
    'licking',
    'licorice',
    'lid',
    'life',
    'lifter',
    'lifting',
    'liftoff',
    'ligament',
    'likely',
    'likeness',
    'likewise',
    'liking',
    'lilac',
    'lilly',
    'lily',
    'limb',
    'limeade',
    'limelight',
    'limes',
    'limit',
    'limping',
    'limpness',
    'line',
    'lingo',
    'linguini',
    'linguist',
    'lining',
    'linked',
    'linoleum',
    'linseed',
    'lint',
    'lion',
    'lip',
    'liquefy',
    'liqueur',
    'liquid',
    'lisp',
    'list',
    'litigate',
    'litigator',
    'litmus',
    'litter',
    'little',
    'livable',
    'lived',
    'lively',
    'liver',
    'livestock',
    'lividly',
    'living',
    'lizard',
    'lubricant',
    'lubricate',
    'lucid',
    'luckily',
    'luckiness',
    'luckless',
    'lucrative',
    'ludicrous',
    'lugged',
    'lukewarm',
    'lullaby',
    'lumber',
    'luminance',
    'luminous',
    'lumpiness',
    'lumping',
    'lumpish',
    'lunacy',
    'lunar',
    'lunchbox',
    'luncheon',
    'lunchroom',
    'lunchtime',
    'lung',
    'lurch',
    'lure',
    'luridness',
    'lurk',
    'lushly',
    'lushness',
    'luster',
    'lustfully',
    'lustily',
    'lustiness',
    'lustrous',
    'lusty',
    'luxurious',
    'luxury',
    'lying',
    'lyrically',
    'lyricism',
    'lyricist',
    'lyrics',
    'macarena',
    'macaroni',
    'macaw',
    'mace',
    'machine',
    'machinist',
    'magazine',
    'magenta',
    'maggot',
    'magical',
    'magician',
    'magma',
    'magnesium',
    'magnetic',
    'magnetism',
    'magnetize',
    'magnifier',
    'magnify',
    'magnitude',
    'magnolia',
    'mahogany',
    'maimed',
    'majestic',
    'majesty',
    'majorette',
    'majority',
    'makeover',
    'maker',
    'makeshift',
    'making',
    'malformed',
    'malt',
    'mama',
    'mammal',
    'mammary',
    'mammogram',
    'manager',
    'managing',
    'manatee',
    'mandarin',
    'mandate',
    'mandatory',
    'mandolin',
    'manger',
    'mangle',
    'mango',
    'mangy',
    'manhandle',
    'manhole',
    'manhood',
    'manhunt',
    'manicotti',
    'manicure',
    'manifesto',
    'manila',
    'mankind',
    'manlike',
    'manliness',
    'manly',
    'manmade',
    'manned',
    'mannish',
    'manor',
    'manpower',
    'mantis',
    'mantra',
    'manual',
    'many',
    'map',
    'marathon',
    'marauding',
    'marbled',
    'marbles',
    'marbling',
    'march',
    'mardi',
    'margarine',
    'margarita',
    'margin',
    'marigold',
    'marina',
    'marine',
    'marital',
    'maritime',
    'marlin',
    'marmalade',
    'maroon',
    'married',
    'marrow',
    'marry',
    'marshland',
    'marshy',
    'marsupial',
    'marvelous',
    'marxism',
    'mascot',
    'masculine',
    'mashed',
    'mashing',
    'massager',
    'masses',
    'massive',
    'mastiff',
    'matador',
    'matchbook',
    'matchbox',
    'matcher',
    'matching',
    'matchless',
    'material',
    'maternal',
    'maternity',
    'math',
    'mating',
    'matriarch',
    'matrimony',
    'matrix',
    'matron',
    'matted',
    'matter',
    'maturely',
    'maturing',
    'maturity',
    'mauve',
    'maverick',
    'maximize',
    'maximum',
    'maybe',
    'mayday',
    'mayflower',
    'moaner',
    'moaning',
    'mobile',
    'mobility',
    'mobilize',
    'mobster',
    'mocha',
    'mocker',
    'mockup',
    'modified',
    'modify',
    'modular',
    'modulator',
    'module',
    'moisten',
    'moistness',
    'moisture',
    'molar',
    'molasses',
    'mold',
    'molecular',
    'molecule',
    'molehill',
    'mollusk',
    'mom',
    'monastery',
    'monday',
    'monetary',
    'monetize',
    'moneybags',
    'moneyless',
    'moneywise',
    'mongoose',
    'mongrel',
    'monitor',
    'monkhood',
    'monogamy',
    'monogram',
    'monologue',
    'monopoly',
    'monorail',
    'monotone',
    'monotype',
    'monoxide',
    'monsieur',
    'monsoon',
    'monstrous',
    'monthly',
    'monument',
    'moocher',
    'moodiness',
    'moody',
    'mooing',
    'moonbeam',
    'mooned',
    'moonlight',
    'moonlike',
    'moonlit',
    'moonrise',
    'moonscape',
    'moonshine',
    'moonstone',
    'moonwalk',
    'mop',
    'morale',
    'morality',
    'morally',
    'morbidity',
    'morbidly',
    'morphine',
    'morphing',
    'morse',
    'mortality',
    'mortally',
    'mortician',
    'mortified',
    'mortify',
    'mortuary',
    'mosaic',
    'mossy',
    'most',
    'mothball',
    'mothproof',
    'motion',
    'motivate',
    'motivator',
    'motive',
    'motocross',
    'motor',
    'motto',
    'mountable',
    'mountain',
    'mounted',
    'mounting',
    'mourner',
    'mournful',
    'mouse',
    'mousiness',
    'moustache',
    'mousy',
    'mouth',
    'movable',
    'move',
    'movie',
    'moving',
    'mower',
    'mowing',
    'much',
    'muck',
    'mud',
    'mug',
    'mulberry',
    'mulch',
    'mule',
    'mulled',
    'mullets',
    'multiple',
    'multiply',
    'multitask',
    'multitude',
    'mumble',
    'mumbling',
    'mumbo',
    'mummified',
    'mummify',
    'mummy',
    'mumps',
    'munchkin',
    'mundane',
    'municipal',
    'muppet',
    'mural',
    'murkiness',
    'murky',
    'murmuring',
    'muscular',
    'museum',
    'mushily',
    'mushiness',
    'mushroom',
    'mushy',
    'music',
    'musket',
    'muskiness',
    'musky',
    'mustang',
    'mustard',
    'muster',
    'mustiness',
    'musty',
    'mutable',
    'mutate',
    'mutation',
    'mute',
    'mutilated',
    'mutilator',
    'mutiny',
    'mutt',
    'mutual',
    'muzzle',
    'myself',
    'myspace',
    'mystified',
    'mystify',
    'myth',
    'nacho',
    'nag',
    'nail',
    'name',
    'naming',
    'nanny',
    'nanometer',
    'nape',
    'napkin',
    'napped',
    'napping',
    'nappy',
    'narrow',
    'nastily',
    'nastiness',
    'national',
    'native',
    'nativity',
    'natural',
    'nature',
    'naturist',
    'nautical',
    'navigate',
    'navigator',
    'navy',
    'nearby',
    'nearest',
    'nearly',
    'nearness',
    'neatly',
    'neatness',
    'nebula',
    'nebulizer',
    'nectar',
    'negate',
    'negation',
    'negative',
    'neglector',
    'negligee',
    'negligent',
    'negotiate',
    'nemeses',
    'nemesis',
    'neon',
    'nephew',
    'nerd',
    'nervous',
    'nervy',
    'nest',
    'net',
    'neurology',
    'neuron',
    'neurosis',
    'neurotic',
    'neuter',
    'neutron',
    'never',
    'next',
    'nibble',
    'nickname',
    'nicotine',
    'niece',
    'nifty',
    'nimble',
    'nimbly',
    'nineteen',
    'ninetieth',
    'ninja',
    'nintendo',
    'ninth',
    'nuclear',
    'nuclei',
    'nucleus',
    'nugget',
    'nullify',
    'number',
    'numbing',
    'numbly',
    'numbness',
    'numeral',
    'numerate',
    'numerator',
    'numeric',
    'numerous',
    'nuptials',
    'nursery',
    'nursing',
    'nurture',
    'nutcase',
    'nutlike',
    'nutmeg',
    'nutrient',
    'nutshell',
    'nuttiness',
    'nutty',
    'nuzzle',
    'nylon',
    'oaf',
    'oak',
    'oasis',
    'oat',
    'obedience',
    'obedient',
    'obituary',
    'object',
    'obligate',
    'obliged',
    'oblivion',
    'oblivious',
    'oblong',
    'obnoxious',
    'oboe',
    'obscure',
    'obscurity',
    'observant',
    'observer',
    'observing',
    'obsessed',
    'obsession',
    'obsessive',
    'obsolete',
    'obstacle',
    'obstinate',
    'obstruct',
    'obtain',
    'obtrusive',
    'obtuse',
    'obvious',
    'occultist',
    'occupancy',
    'occupant',
    'occupier',
    'occupy',
    'ocean',
    'ocelot',
    'octagon',
    'octane',
    'october',
    'octopus',
    'ogle',
    'oil',
    'oink',
    'ointment',
    'okay',
    'old',
    'olive',
    'olympics',
    'omega',
    'omen',
    'ominous',
    'omission',
    'omit',
    'omnivore',
    'onboard',
    'oncoming',
    'ongoing',
    'onion',
    'online',
    'onlooker',
    'only',
    'onscreen',
    'onset',
    'onshore',
    'onslaught',
    'onstage',
    'onto',
    'onward',
    'onyx',
    'oops',
    'ooze',
    'oozy',
    'opacity',
    'opal',
    'open',
    'operable',
    'operate',
    'operating',
    'operation',
    'operative',
    'operator',
    'opium',
    'opossum',
    'opponent',
    'oppose',
    'opposing',
    'opposite',
    'oppressed',
    'oppressor',
    'opt',
    'opulently',
    'osmosis',
    'other',
    'otter',
    'ouch',
    'ought',
    'ounce',
    'outage',
    'outback',
    'outbid',
    'outboard',
    'outbound',
    'outbreak',
    'outburst',
    'outcast',
    'outclass',
    'outcome',
    'outdated',
    'outdoors',
    'outer',
    'outfield',
    'outfit',
    'outflank',
    'outgoing',
    'outgrow',
    'outhouse',
    'outing',
    'outlast',
    'outlet',
    'outline',
    'outlook',
    'outlying',
    'outmatch',
    'outmost',
    'outnumber',
    'outplayed',
    'outpost',
    'outpour',
    'output',
    'outrage',
    'outrank',
    'outreach',
    'outright',
    'outscore',
    'outsell',
    'outshine',
    'outshoot',
    'outsider',
    'outskirts',
    'outsmart',
    'outsource',
    'outspoken',
    'outtakes',
    'outthink',
    'outward',
    'outweigh',
    'outwit',
    'oval',
    'ovary',
    'oven',
    'overact',
    'overall',
    'overarch',
    'overbid',
    'overbill',
    'overbite',
    'overblown',
    'overboard',
    'overbook',
    'overbuilt',
    'overcast',
    'overcoat',
    'overcome',
    'overcook',
    'overcrowd',
    'overdraft',
    'overdrawn',
    'overdress',
    'overdrive',
    'overdue',
    'overeager',
    'overeater',
    'overexert',
    'overfed',
    'overfeed',
    'overfill',
    'overflow',
    'overfull',
    'overgrown',
    'overhand',
    'overhang',
    'overhaul',
    'overhead',
    'overhear',
    'overheat',
    'overhung',
    'overjoyed',
    'overkill',
    'overlabor',
    'overlaid',
    'overlap',
    'overlay',
    'overload',
    'overlook',
    'overlord',
    'overlying',
    'overnight',
    'overpass',
    'overpay',
    'overplant',
    'overplay',
    'overpower',
    'overprice',
    'overrate',
    'overreach',
    'overreact',
    'override',
    'overripe',
    'overrule',
    'overrun',
    'overshoot',
    'overshot',
    'oversight',
    'oversized',
    'oversleep',
    'oversold',
    'overspend',
    'overstate',
    'overstay',
    'overstep',
    'overstock',
    'overstuff',
    'oversweet',
    'overtake',
    'overthrow',
    'overtime',
    'overtly',
    'overtone',
    'overture',
    'overturn',
    'overuse',
    'overvalue',
    'overview',
    'overwrite',
    'owl',
    'oxford',
    'oxidant',
    'oxidation',
    'oxidize',
    'oxidizing',
    'oxygen',
    'oxymoron',
    'oyster',
    'ozone',
    'paced',
    'pacemaker',
    'pacific',
    'pacifier',
    'pacifism',
    'pacifist',
    'pacify',
    'padded',
    'padding',
    'paddle',
    'paddling',
    'padlock',
    'pagan',
    'pager',
    'paging',
    'pajamas',
    'palace',
    'palatable',
    'palm',
    'palpable',
    'palpitate',
    'paltry',
    'pampered',
    'pamperer',
    'pampers',
    'pamphlet',
    'panama',
    'pancake',
    'pancreas',
    'panda',
    'pandemic',
    'pang',
    'panhandle',
    'panic',
    'panning',
    'panorama',
    'panoramic',
    'panther',
    'pantomime',
    'pantry',
    'pants',
    'pantyhose',
    'paparazzi',
    'papaya',
    'paper',
    'paprika',
    'papyrus',
    'parabola',
    'parachute',
    'parade',
    'paradox',
    'paragraph',
    'parakeet',
    'paralegal',
    'paralyses',
    'paralysis',
    'paralyze',
    'paramedic',
    'parameter',
    'paramount',
    'parasail',
    'parasite',
    'parasitic',
    'parcel',
    'parched',
    'parchment',
    'pardon',
    'parish',
    'parka',
    'parking',
    'parkway',
    'parlor',
    'parmesan',
    'parole',
    'parrot',
    'parsley',
    'parsnip',
    'partake',
    'parted',
    'parting',
    'partition',
    'partly',
    'partner',
    'partridge',
    'party',
    'passable',
    'passably',
    'passage',
    'passcode',
    'passenger',
    'passerby',
    'passing',
    'passion',
    'passive',
    'passivism',
    'passover',
    'passport',
    'password',
    'pasta',
    'pasted',
    'pastel',
    'pastime',
    'pastor',
    'pastrami',
    'pasture',
    'pasty',
    'patchwork',
    'patchy',
    'paternal',
    'paternity',
    'path',
    'patience',
    'patient',
    'patio',
    'patriarch',
    'patriot',
    'patrol',
    'patronage',
    'patronize',
    'pauper',
    'pavement',
    'paver',
    'pavestone',
    'pavilion',
    'paving',
    'pawing',
    'payable',
    'payback',
    'paycheck',
    'payday',
    'payee',
    'payer',
    'paying',
    'payment',
    'payphone',
    'payroll',
    'pebble',
    'pebbly',
    'pecan',
    'pectin',
    'peculiar',
    'peddling',
    'pediatric',
    'pedicure',
    'pedigree',
    'pedometer',
    'pegboard',
    'pelican',
    'pellet',
    'pelt',
    'pelvis',
    'penalize',
    'penalty',
    'pencil',
    'pendant',
    'pending',
    'penholder',
    'penknife',
    'pennant',
    'penniless',
    'penny',
    'penpal',
    'pension',
    'pentagon',
    'pentagram',
    'pep',
    'perceive',
    'percent',
    'perch',
    'percolate',
    'perennial',
    'perfected',
    'perfectly',
    'perfume',
    'periscope',
    'perish',
    'perjurer',
    'perjury',
    'perkiness',
    'perky',
    'perm',
    'peroxide',
    'perpetual',
    'perplexed',
    'persecute',
    'persevere',
    'persuaded',
    'persuader',
    'pesky',
    'peso',
    'pessimism',
    'pessimist',
    'pester',
    'pesticide',
    'petal',
    'petite',
    'petition',
    'petri',
    'petroleum',
    'petted',
    'petticoat',
    'pettiness',
    'petty',
    'petunia',
    'phantom',
    'phobia',
    'phoenix',
    'phonebook',
    'phoney',
    'phonics',
    'phoniness',
    'phony',
    'phosphate',
    'photo',
    'phrase',
    'phrasing',
    'placard',
    'placate',
    'placidly',
    'plank',
    'planner',
    'plant',
    'plasma',
    'plaster',
    'plastic',
    'plated',
    'platform',
    'plating',
    'platinum',
    'platonic',
    'platter',
    'platypus',
    'plausible',
    'plausibly',
    'playable',
    'playback',
    'player',
    'playful',
    'playgroup',
    'playhouse',
    'playing',
    'playlist',
    'playmaker',
    'playmate',
    'playoff',
    'playpen',
    'playroom',
    'playset',
    'plaything',
    'playtime',
    'plaza',
    'pleading',
    'pleat',
    'pledge',
    'plentiful',
    'plenty',
    'plethora',
    'plexiglas',
    'pliable',
    'plod',
    'plop',
    'plot',
    'plow',
    'ploy',
    'pluck',
    'plug',
    'plunder',
    'plunging',
    'plural',
    'plus',
    'plutonium',
    'plywood',
    'poach',
    'pod',
    'poem',
    'poet',
    'pogo',
    'pointed',
    'pointer',
    'pointing',
    'pointless',
    'pointy',
    'poise',
    'poison',
    'poker',
    'poking',
    'polar',
    'police',
    'policy',
    'polio',
    'polish',
    'politely',
    'polka',
    'polo',
    'polyester',
    'polygon',
    'polygraph',
    'polymer',
    'poncho',
    'pond',
    'pony',
    'popcorn',
    'pope',
    'poplar',
    'popper',
    'poppy',
    'popsicle',
    'populace',
    'popular',
    'populate',
    'porcupine',
    'pork',
    'porous',
    'porridge',
    'portable',
    'portal',
    'portfolio',
    'porthole',
    'portion',
    'portly',
    'portside',
    'poser',
    'posh',
    'posing',
    'possible',
    'possibly',
    'possum',
    'postage',
    'postal',
    'postbox',
    'postcard',
    'posted',
    'poster',
    'posting',
    'postnasal',
    'posture',
    'postwar',
    'pouch',
    'pounce',
    'pouncing',
    'pound',
    'pouring',
    'pout',
    'powdered',
    'powdering',
    'powdery',
    'power',
    'powwow',
    'pox',
    'praising',
    'prance',
    'prancing',
    'pranker',
    'prankish',
    'prankster',
    'prayer',
    'praying',
    'preacher',
    'preaching',
    'preachy',
    'preamble',
    'precinct',
    'precise',
    'precision',
    'precook',
    'precut',
    'predator',
    'predefine',
    'predict',
    'preface',
    'prefix',
    'preflight',
    'preformed',
    'pregame',
    'pregnancy',
    'pregnant',
    'preheated',
    'prelaunch',
    'prelaw',
    'prelude',
    'premiere',
    'premises',
    'premium',
    'prenatal',
    'preoccupy',
    'preorder',
    'prepaid',
    'prepay',
    'preplan',
    'preppy',
    'preschool',
    'prescribe',
    'preseason',
    'preset',
    'preshow',
    'president',
    'presoak',
    'press',
    'presume',
    'presuming',
    'preteen',
    'pretended',
    'pretender',
    'pretense',
    'pretext',
    'pretty',
    'pretzel',
    'prevail',
    'prevalent',
    'prevent',
    'preview',
    'previous',
    'prewar',
    'prewashed',
    'prideful',
    'pried',
    'primal',
    'primarily',
    'primary',
    'primate',
    'primer',
    'primp',
    'princess',
    'print',
    'prior',
    'prism',
    'prison',
    'prissy',
    'pristine',
    'privacy',
    'private',
    'privatize',
    'prize',
    'proactive',
    'probable',
    'probably',
    'probation',
    'probe',
    'probing',
    'probiotic',
    'problem',
    'procedure',
    'process',
    'proclaim',
    'procreate',
    'procurer',
    'prodigal',
    'prodigy',
    'produce',
    'product',
    'profane',
    'profanity',
    'professed',
    'professor',
    'profile',
    'profound',
    'profusely',
    'progeny',
    'prognosis',
    'program',
    'progress',
    'projector',
    'prologue',
    'prolonged',
    'promenade',
    'prominent',
    'promoter',
    'promotion',
    'prompter',
    'promptly',
    'prone',
    'prong',
    'pronounce',
    'pronto',
    'proofing',
    'proofread',
    'proofs',
    'propeller',
    'properly',
    'property',
    'proponent',
    'proposal',
    'propose',
    'props',
    'prorate',
    'protector',
    'protegee',
    'proton',
    'prototype',
    'protozoan',
    'protract',
    'protrude',
    'proud',
    'provable',
    'proved',
    'proven',
    'provided',
    'provider',
    'providing',
    'province',
    'proving',
    'provoke',
    'provoking',
    'provolone',
    'prowess',
    'prowler',
    'prowling',
    'proximity',
    'proxy',
    'prozac',
    'prude',
    'prudishly',
    'prune',
    'pruning',
    'pry',
    'psychic',
    'public',
    'publisher',
    'pucker',
    'pueblo',
    'pug',
    'pull',
    'pulmonary',
    'pulp',
    'pulsate',
    'pulse',
    'pulverize',
    'puma',
    'pumice',
    'pummel',
    'punch',
    'punctual',
    'punctuate',
    'punctured',
    'pungent',
    'punisher',
    'punk',
    'pupil',
    'puppet',
    'puppy',
    'purchase',
    'pureblood',
    'purebred',
    'purely',
    'pureness',
    'purgatory',
    'purge',
    'purging',
    'purifier',
    'purify',
    'purist',
    'puritan',
    'purity',
    'purple',
    'purplish',
    'purposely',
    'purr',
    'purse',
    'pursuable',
    'pursuant',
    'pursuit',
    'purveyor',
    'pushcart',
    'pushchair',
    'pusher',
    'pushiness',
    'pushing',
    'pushover',
    'pushpin',
    'pushup',
    'pushy',
    'putdown',
    'putt',
    'puzzle',
    'puzzling',
    'pyramid',
    'pyromania',
    'python',
    'quack',
    'quadrant',
    'quail',
    'quaintly',
    'quake',
    'quaking',
    'qualified',
    'qualifier',
    'qualify',
    'quality',
    'qualm',
    'quantum',
    'quarrel',
    'quarry',
    'quartered',
    'quarterly',
    'quarters',
    'quartet',
    'quench',
    'query',
    'quicken',
    'quickly',
    'quickness',
    'quicksand',
    'quickstep',
    'quiet',
    'quill',
    'quilt',
    'quintet',
    'quintuple',
    'quirk',
    'quit',
    'quiver',
    'quizzical',
    'quotable',
    'quotation',
    'quote',
    'rabid',
    'race',
    'racing',
    'racism',
    'rack',
    'racoon',
    'radar',
    'radial',
    'radiance',
    'radiantly',
    'radiated',
    'radiation',
    'radiator',
    'radio',
    'radish',
    'raffle',
    'raft',
    'rage',
    'ragged',
    'raging',
    'ragweed',
    'raider',
    'railcar',
    'railing',
    'railroad',
    'railway',
    'raisin',
    'rake',
    'raking',
    'rally',
    'ramble',
    'rambling',
    'ramp',
    'ramrod',
    'ranch',
    'rancidity',
    'random',
    'ranged',
    'ranger',
    'ranging',
    'ranked',
    'ranking',
    'ransack',
    'ranting',
    'rants',
    'rare',
    'rarity',
    'rascal',
    'rash',
    'rasping',
    'ravage',
    'raven',
    'ravine',
    'raving',
    'ravioli',
    'ravishing',
    'reabsorb',
    'reach',
    'reacquire',
    'reaction',
    'reactive',
    'reactor',
    'reaffirm',
    'ream',
    'reanalyze',
    'reappear',
    'reapply',
    'reappoint',
    'reapprove',
    'rearrange',
    'rearview',
    'reason',
    'reassign',
    'reassure',
    'reattach',
    'reawake',
    'rebalance',
    'rebate',
    'rebel',
    'rebirth',
    'reboot',
    'reborn',
    'rebound',
    'rebuff',
    'rebuild',
    'rebuilt',
    'reburial',
    'rebuttal',
    'recall',
    'recant',
    'recapture',
    'recast',
    'recede',
    'recent',
    'recess',
    'recharger',
    'recipient',
    'recital',
    'recite',
    'reckless',
    'reclaim',
    'recliner',
    'reclining',
    'recluse',
    'reclusive',
    'recognize',
    'recoil',
    'recollect',
    'recolor',
    'reconcile',
    'reconfirm',
    'reconvene',
    'recopy',
    'record',
    'recount',
    'recoup',
    'recovery',
    'recreate',
    'rectal',
    'rectangle',
    'rectified',
    'rectify',
    'recycled',
    'recycler',
    'recycling',
    'reemerge',
    'reenact',
    'reenter',
    'reentry',
    'reexamine',
    'referable',
    'referee',
    'reference',
    'refill',
    'refinance',
    'refined',
    'refinery',
    'refining',
    'refinish',
    'reflected',
    'reflector',
    'reflex',
    'reflux',
    'refocus',
    'refold',
    'reforest',
    'reformat',
    'reformed',
    'reformer',
    'reformist',
    'refract',
    'refrain',
    'refreeze',
    'refresh',
    'refried',
    'refueling',
    'refund',
    'refurbish',
    'refurnish',
    'refusal',
    'refuse',
    'refusing',
    'refutable',
    'refute',
    'regain',
    'regalia',
    'regally',
    'reggae',
    'regime',
    'region',
    'register',
    'registrar',
    'registry',
    'regress',
    'regretful',
    'regroup',
    'regular',
    'regulate',
    'regulator',
    'rehab',
    'reheat',
    'rehire',
    'rehydrate',
    'reimburse',
    'reissue',
    'reiterate',
    'rejoice',
    'rejoicing',
    'rejoin',
    'rekindle',
    'relapse',
    'relapsing',
    'relatable',
    'related',
    'relation',
    'relative',
    'relax',
    'relay',
    'relearn',
    'release',
    'relenting',
    'reliable',
    'reliably',
    'reliance',
    'reliant',
    'relic',
    'relieve',
    'relieving',
    'relight',
    'relish',
    'relive',
    'reload',
    'relocate',
    'relock',
    'reluctant',
    'rely',
    'remake',
    'remark',
    'remarry',
    'rematch',
    'remedial',
    'remedy',
    'remember',
    'reminder',
    'remindful',
    'remission',
    'remix',
    'remnant',
    'remodeler',
    'remold',
    'remorse',
    'remote',
    'removable',
    'removal',
    'removed',
    'remover',
    'removing',
    'rename',
    'renderer',
    'rendering',
    'rendition',
    'renegade',
    'renewable',
    'renewably',
    'renewal',
    'renewed',
    'renounce',
    'renovate',
    'renovator',
    'rentable',
    'rental',
    'rented',
    'renter',
    'reoccupy',
    'reoccur',
    'reopen',
    'reorder',
    'repackage',
    'repacking',
    'repaint',
    'repair',
    'repave',
    'repaying',
    'repayment',
    'repeal',
    'repeated',
    'repeater',
    'repent',
    'rephrase',
    'replace',
    'replay',
    'replica',
    'reply',
    'reporter',
    'repose',
    'repossess',
    'repost',
    'repressed',
    'reprimand',
    'reprint',
    'reprise',
    'reproach',
    'reprocess',
    'reproduce',
    'reprogram',
    'reps',
    'reptile',
    'reptilian',
    'repugnant',
    'repulsion',
    'repulsive',
    'repurpose',
    'reputable',
    'reputably',
    'request',
    'require',
    'requisite',
    'reroute',
    'rerun',
    'resale',
    'resample',
    'rescuer',
    'reseal',
    'research',
    'reselect',
    'reseller',
    'resemble',
    'resend',
    'resent',
    'reset',
    'reshape',
    'reshoot',
    'reshuffle',
    'residence',
    'residency',
    'resident',
    'residual',
    'residue',
    'resigned',
    'resilient',
    'resistant',
    'resisting',
    'resize',
    'resolute',
    'resolved',
    'resonant',
    'resonate',
    'resort',
    'resource',
    'respect',
    'resubmit',
    'result',
    'resume',
    'resupply',
    'resurface',
    'resurrect',
    'retail',
    'retainer',
    'retaining',
    'retake',
    'retaliate',
    'retention',
    'rethink',
    'retinal',
    'retired',
    'retiree',
    'retiring',
    'retold',
    'retool',
    'retorted',
    'retouch',
    'retrace',
    'retract',
    'retrain',
    'retread',
    'retreat',
    'retrial',
    'retrieval',
    'retriever',
    'retry',
    'return',
    'retying',
    'retype',
    'reunion',
    'reunite',
    'reusable',
    'reuse',
    'reveal',
    'reveler',
    'revenge',
    'revenue',
    'reverb',
    'revered',
    'reverence',
    'reverend',
    'reversal',
    'reverse',
    'reversing',
    'reversion',
    'revert',
    'revisable',
    'revise',
    'revision',
    'revisit',
    'revivable',
    'revival',
    'reviver',
    'reviving',
    'revocable',
    'revoke',
    'revolt',
    'revolver',
    'revolving',
    'reward',
    'rewash',
    'rewind',
    'rewire',
    'reword',
    'rework',
    'rewrap',
    'rewrite',
    'rhyme',
    'ribbon',
    'ribcage',
    'rice',
    'riches',
    'richly',
    'richness',
    'rickety',
    'ricotta',
    'riddance',
    'ridden',
    'ride',
    'riding',
    'rifling',
    'rift',
    'rigging',
    'rigid',
    'rigor',
    'rimless',
    'rimmed',
    'rind',
    'rink',
    'rinse',
    'rinsing',
    'riot',
    'ripcord',
    'ripeness',
    'ripening',
    'ripping',
    'ripple',
    'rippling',
    'riptide',
    'rise',
    'rising',
    'risk',
    'risotto',
    'ritalin',
    'ritzy',
    'rival',
    'riverbank',
    'riverbed',
    'riverboat',
    'riverside',
    'riveter',
    'riveting',
    'roamer',
    'roaming',
    'roast',
    'robbing',
    'robe',
    'robin',
    'robotics',
    'robust',
    'rockband',
    'rocker',
    'rocket',
    'rockfish',
    'rockiness',
    'rocking',
    'rocklike',
    'rockslide',
    'rockstar',
    'rocky',
    'rogue',
    'roman',
    'romp',
    'rope',
    'roping',
    'roster',
    'rosy',
    'rotten',
    'rotting',
    'rotunda',
    'roulette',
    'rounding',
    'roundish',
    'roundness',
    'roundup',
    'roundworm',
    'routine',
    'routing',
    'rover',
    'roving',
    'royal',
    'rubbed',
    'rubber',
    'rubbing',
    'rubble',
    'rubdown',
    'ruby',
    'ruckus',
    'rudder',
    'rug',
    'ruined',
    'rule',
    'rumble',
    'rumbling',
    'rummage',
    'rumor',
    'runaround',
    'rundown',
    'runner',
    'running',
    'runny',
    'runt',
    'runway',
    'rupture',
    'rural',
    'ruse',
    'rush',
    'rust',
    'rut',
    'sabbath',
    'sabotage',
    'sacrament',
    'sacred',
    'sacrifice',
    'sadden',
    'saddlebag',
    'saddled',
    'saddling',
    'sadly',
    'sadness',
    'safari',
    'safeguard',
    'safehouse',
    'safely',
    'safeness',
    'saffron',
    'saga',
    'sage',
    'sagging',
    'saggy',
    'said',
    'saint',
    'sake',
    'salad',
    'salami',
    'salaried',
    'salary',
    'saline',
    'salon',
    'saloon',
    'salsa',
    'salt',
    'salutary',
    'salute',
    'salvage',
    'salvaging',
    'salvation',
    'same',
    'sample',
    'sampling',
    'sanction',
    'sanctity',
    'sanctuary',
    'sandal',
    'sandbag',
    'sandbank',
    'sandbar',
    'sandblast',
    'sandbox',
    'sanded',
    'sandfish',
    'sanding',
    'sandlot',
    'sandpaper',
    'sandpit',
    'sandstone',
    'sandstorm',
    'sandworm',
    'sandy',
    'sanitary',
    'sanitizer',
    'sank',
    'santa',
    'sapling',
    'sappiness',
    'sappy',
    'sarcasm',
    'sarcastic',
    'sardine',
    'sash',
    'sasquatch',
    'sassy',
    'satchel',
    'satiable',
    'satin',
    'satirical',
    'satisfied',
    'satisfy',
    'saturate',
    'saturday',
    'sauciness',
    'saucy',
    'sauna',
    'savage',
    'savanna',
    'saved',
    'savings',
    'savior',
    'savor',
    'saxophone',
    'say',
    'scabbed',
    'scabby',
    'scalded',
    'scalding',
    'scale',
    'scaling',
    'scallion',
    'scallop',
    'scalping',
    'scam',
    'scandal',
    'scanner',
    'scanning',
    'scant',
    'scapegoat',
    'scarce',
    'scarcity',
    'scarecrow',
    'scared',
    'scarf',
    'scarily',
    'scariness',
    'scarring',
    'scary',
    'scavenger',
    'scenic',
    'schedule',
    'schematic',
    'scheme',
    'scheming',
    'schilling',
    'schnapps',
    'scholar',
    'science',
    'scientist',
    'scion',
    'scoff',
    'scolding',
    'scone',
    'scoop',
    'scooter',
    'scope',
    'scorch',
    'scorebook',
    'scorecard',
    'scored',
    'scoreless',
    'scorer',
    'scoring',
    'scorn',
    'scorpion',
    'scotch',
    'scoundrel',
    'scoured',
    'scouring',
    'scouting',
    'scouts',
    'scowling',
    'scrabble',
    'scraggly',
    'scrambled',
    'scrambler',
    'scrap',
    'scratch',
    'scrawny',
    'screen',
    'scribble',
    'scribe',
    'scribing',
    'scrimmage',
    'script',
    'scroll',
    'scrooge',
    'scrounger',
    'scrubbed',
    'scrubber',
    'scruffy',
    'scrunch',
    'scrutiny',
    'scuba',
    'scuff',
    'sculptor',
    'sculpture',
    'scurvy',
    'scuttle',
    'secluded',
    'secluding',
    'seclusion',
    'second',
    'secrecy',
    'secret',
    'sectional',
    'sector',
    'secular',
    'securely',
    'security',
    'sedan',
    'sedate',
    'sedation',
    'sedative',
    'sediment',
    'seduce',
    'seducing',
    'segment',
    'seismic',
    'seizing',
    'seldom',
    'selected',
    'selection',
    'selective',
    'selector',
    'self',
    'seltzer',
    'semantic',
    'semester',
    'semicolon',
    'semifinal',
    'seminar',
    'semisoft',
    'semisweet',
    'senate',
    'senator',
    'send',
    'senior',
    'senorita',
    'sensation',
    'sensitive',
    'sensitize',
    'sensually',
    'sensuous',
    'sepia',
    'september',
    'septic',
    'septum',
    'sequel',
    'sequence',
    'sequester',
    'series',
    'sermon',
    'serotonin',
    'serpent',
    'serrated',
    'serve',
    'service',
    'serving',
    'sesame',
    'sessions',
    'setback',
    'setting',
    'settle',
    'settling',
    'setup',
    'sevenfold',
    'seventeen',
    'seventh',
    'seventy',
    'severity',
    'shabby',
    'shack',
    'shaded',
    'shadily',
    'shadiness',
    'shading',
    'shadow',
    'shady',
    'shaft',
    'shakable',
    'shakily',
    'shakiness',
    'shaking',
    'shaky',
    'shale',
    'shallot',
    'shallow',
    'shame',
    'shampoo',
    'shamrock',
    'shank',
    'shanty',
    'shape',
    'shaping',
    'share',
    'sharpener',
    'sharper',
    'sharpie',
    'sharply',
    'sharpness',
    'shawl',
    'sheath',
    'shed',
    'sheep',
    'sheet',
    'shelf',
    'shell',
    'shelter',
    'shelve',
    'shelving',
    'sherry',
    'shield',
    'shifter',
    'shifting',
    'shiftless',
    'shifty',
    'shimmer',
    'shimmy',
    'shindig',
    'shine',
    'shingle',
    'shininess',
    'shining',
    'shiny',
    'ship',
    'shirt',
    'shivering',
    'shock',
    'shone',
    'shoplift',
    'shopper',
    'shopping',
    'shoptalk',
    'shore',
    'shortage',
    'shortcake',
    'shortcut',
    'shorten',
    'shorter',
    'shorthand',
    'shortlist',
    'shortly',
    'shortness',
    'shorts',
    'shortwave',
    'shorty',
    'shout',
    'shove',
    'showbiz',
    'showcase',
    'showdown',
    'shower',
    'showgirl',
    'showing',
    'showman',
    'shown',
    'showoff',
    'showpiece',
    'showplace',
    'showroom',
    'showy',
    'shrank',
    'shrapnel',
    'shredder',
    'shredding',
    'shrewdly',
    'shriek',
    'shrill',
    'shrimp',
    'shrine',
    'shrink',
    'shrivel',
    'shrouded',
    'shrubbery',
    'shrubs',
    'shrug',
    'shrunk',
    'shucking',
    'shudder',
    'shuffle',
    'shuffling',
    'shun',
    'shush',
    'shut',
    'shy',
    'siamese',
    'siberian',
    'sibling',
    'siding',
    'sierra',
    'siesta',
    'sift',
    'sighing',
    'silenced',
    'silencer',
    'silent',
    'silica',
    'silicon',
    'silk',
    'silliness',
    'silly',
    'silo',
    'silt',
    'silver',
    'similarly',
    'simile',
    'simmering',
    'simple',
    'simplify',
    'simply',
    'sincere',
    'sincerity',
    'singer',
    'singing',
    'single',
    'singular',
    'sinister',
    'sinless',
    'sinner',
    'sinuous',
    'sip',
    'siren',
    'sister',
    'sitcom',
    'sitter',
    'sitting',
    'situated',
    'situation',
    'sixfold',
    'sixteen',
    'sixth',
    'sixties',
    'sixtieth',
    'sixtyfold',
    'sizable',
    'sizably',
    'size',
    'sizing',
    'sizzle',
    'sizzling',
    'skater',
    'skating',
    'skedaddle',
    'skeletal',
    'skeleton',
    'skeptic',
    'sketch',
    'skewed',
    'skewer',
    'skid',
    'skied',
    'skier',
    'skies',
    'skiing',
    'skilled',
    'skillet',
    'skillful',
    'skimmed',
    'skimmer',
    'skimming',
    'skimpily',
    'skincare',
    'skinhead',
    'skinless',
    'skinning',
    'skinny',
    'skintight',
    'skipper',
    'skipping',
    'skirmish',
    'skirt',
    'skittle',
    'skydiver',
    'skylight',
    'skyline',
    'skype',
    'skyrocket',
    'skyward',
    'slab',
    'slacked',
    'slacker',
    'slacking',
    'slackness',
    'slacks',
    'slain',
    'slam',
    'slander',
    'slang',
    'slapping',
    'slapstick',
    'slashed',
    'slashing',
    'slate',
    'slather',
    'slaw',
    'sled',
    'sleek',
    'sleep',
    'sleet',
    'sleeve',
    'slept',
    'sliceable',
    'sliced',
    'slicer',
    'slicing',
    'slick',
    'slider',
    'slideshow',
    'sliding',
    'slighted',
    'slighting',
    'slightly',
    'slimness',
    'slimy',
    'slinging',
    'slingshot',
    'slinky',
    'slip',
    'slit',
    'sliver',
    'slobbery',
    'slogan',
    'sloped',
    'sloping',
    'sloppily',
    'sloppy',
    'slot',
    'slouching',
    'slouchy',
    'sludge',
    'slug',
    'slum',
    'slurp',
    'slush',
    'sly',
    'small',
    'smartly',
    'smartness',
    'smasher',
    'smashing',
    'smashup',
    'smell',
    'smelting',
    'smile',
    'smilingly',
    'smirk',
    'smite',
    'smith',
    'smitten',
    'smock',
    'smog',
    'smoked',
    'smokeless',
    'smokiness',
    'smoking',
    'smoky',
    'smolder',
    'smooth',
    'smother',
    'smudge',
    'smudgy',
    'smuggler',
    'smuggling',
    'smugly',
    'smugness',
    'snack',
    'snagged',
    'snaking',
    'snap',
    'snare',
    'snarl',
    'snazzy',
    'sneak',
    'sneer',
    'sneeze',
    'sneezing',
    'snide',
    'sniff',
    'snippet',
    'snipping',
    'snitch',
    'snooper',
    'snooze',
    'snore',
    'snoring',
    'snorkel',
    'snort',
    'snout',
    'snowbird',
    'snowboard',
    'snowbound',
    'snowcap',
    'snowdrift',
    'snowdrop',
    'snowfall',
    'snowfield',
    'snowflake',
    'snowiness',
    'snowless',
    'snowman',
    'snowplow',
    'snowshoe',
    'snowstorm',
    'snowsuit',
    'snowy',
    'snub',
    'snuff',
    'snuggle',
    'snugly',
    'snugness',
    'speak',
    'spearfish',
    'spearhead',
    'spearman',
    'spearmint',
    'species',
    'specimen',
    'specked',
    'speckled',
    'specks',
    'spectacle',
    'spectator',
    'spectrum',
    'speculate',
    'speech',
    'speed',
    'spellbind',
    'speller',
    'spelling',
    'spendable',
    'spender',
    'spending',
    'spent',
    'spew',
    'sphere',
    'spherical',
    'sphinx',
    'spider',
    'spied',
    'spiffy',
    'spill',
    'spilt',
    'spinach',
    'spinal',
    'spindle',
    'spinner',
    'spinning',
    'spinout',
    'spinster',
    'spiny',
    'spiral',
    'spirited',
    'spiritism',
    'spirits',
    'spiritual',
    'splashed',
    'splashing',
    'splashy',
    'splatter',
    'spleen',
    'splendid',
    'splendor',
    'splice',
    'splicing',
    'splinter',
    'splotchy',
    'splurge',
    'spoilage',
    'spoiled',
    'spoiler',
    'spoiling',
    'spoils',
    'spoken',
    'spokesman',
    'sponge',
    'spongy',
    'sponsor',
    'spoof',
    'spookily',
    'spooky',
    'spool',
    'spoon',
    'spore',
    'sporting',
    'sports',
    'sporty',
    'spotless',
    'spotlight',
    'spotted',
    'spotter',
    'spotting',
    'spotty',
    'spousal',
    'spouse',
    'spout',
    'sprain',
    'sprang',
    'sprawl',
    'spray',
    'spree',
    'sprig',
    'spring',
    'sprinkled',
    'sprinkler',
    'sprint',
    'sprite',
    'sprout',
    'spruce',
    'sprung',
    'spry',
    'spud',
    'spur',
    'sputter',
    'spyglass',
    'squabble',
    'squad',
    'squall',
    'squander',
    'squash',
    'squatted',
    'squatter',
    'squatting',
    'squeak',
    'squealer',
    'squealing',
    'squeamish',
    'squeegee',
    'squeeze',
    'squeezing',
    'squid',
    'squiggle',
    'squiggly',
    'squint',
    'squire',
    'squirt',
    'squishier',
    'squishy',
    'stability',
    'stabilize',
    'stable',
    'stack',
    'stadium',
    'staff',
    'stage',
    'staging',
    'stagnant',
    'stagnate',
    'stainable',
    'stained',
    'staining',
    'stainless',
    'stalemate',
    'staleness',
    'stalling',
    'stallion',
    'stamina',
    'stammer',
    'stamp',
    'stand',
    'stank',
    'staple',
    'stapling',
    'starboard',
    'starch',
    'stardom',
    'stardust',
    'starfish',
    'stargazer',
    'staring',
    'stark',
    'starless',
    'starlet',
    'starlight',
    'starlit',
    'starring',
    'starry',
    'starship',
    'starter',
    'starting',
    'startle',
    'startling',
    'startup',
    'starved',
    'starving',
    'stash',
    'state',
    'static',
    'statistic',
    'statue',
    'stature',
    'status',
    'statute',
    'statutory',
    'staunch',
    'stays',
    'steadfast',
    'steadier',
    'steadily',
    'steadying',
    'steam',
    'steed',
    'steep',
    'steerable',
    'steering',
    'steersman',
    'stegosaur',
    'stellar',
    'stem',
    'stench',
    'stencil',
    'step',
    'stereo',
    'sterile',
    'sterility',
    'sterilize',
    'sterling',
    'sternness',
    'sternum',
    'stew',
    'stick',
    'stiffen',
    'stiffly',
    'stiffness',
    'stifle',
    'stifling',
    'stillness',
    'stilt',
    'stimulant',
    'stimulate',
    'stimuli',
    'stimulus',
    'stinger',
    'stingily',
    'stinging',
    'stingray',
    'stingy',
    'stinking',
    'stinky',
    'stipend',
    'stipulate',
    'stir',
    'stitch',
    'stock',
    'stoic',
    'stoke',
    'stole',
    'stomp',
    'stonewall',
    'stoneware',
    'stonework',
    'stoning',
    'stony',
    'stood',
    'stooge',
    'stool',
    'stoop',
    'stoplight',
    'stoppable',
    'stoppage',
    'stopped',
    'stopper',
    'stopping',
    'stopwatch',
    'storable',
    'storage',
    'storeroom',
    'storewide',
    'storm',
    'stout',
    'stove',
    'stowaway',
    'stowing',
    'straddle',
    'straggler',
    'strained',
    'strainer',
    'straining',
    'strangely',
    'stranger',
    'strangle',
    'strategic',
    'strategy',
    'stratus',
    'straw',
    'stray',
    'streak',
    'stream',
    'street',
    'strength',
    'strenuous',
    'strep',
    'stress',
    'stretch',
    'strewn',
    'stricken',
    'strict',
    'stride',
    'strife',
    'strike',
    'striking',
    'strive',
    'striving',
    'strobe',
    'strode',
    'stroller',
    'strongbox',
    'strongly',
    'strongman',
    'struck',
    'structure',
    'strudel',
    'struggle',
    'strum',
    'strung',
    'strut',
    'stubbed',
    'stubble',
    'stubbly',
    'stubborn',
    'stucco',
    'stuck',
    'student',
    'studied',
    'studio',
    'study',
    'stuffed',
    'stuffing',
    'stuffy',
    'stumble',
    'stumbling',
    'stump',
    'stung',
    'stunned',
    'stunner',
    'stunning',
    'stunt',
    'stupor',
    'sturdily',
    'sturdy',
    'styling',
    'stylishly',
    'stylist',
    'stylized',
    'stylus',
    'suave',
    'subarctic',
    'subatomic',
    'subdivide',
    'subdued',
    'subduing',
    'subfloor',
    'subgroup',
    'subheader',
    'subject',
    'sublease',
    'sublet',
    'sublevel',
    'sublime',
    'submarine',
    'submerge',
    'submersed',
    'submitter',
    'subpanel',
    'subpar',
    'subplot',
    'subprime',
    'subscribe',
    'subscript',
    'subsector',
    'subside',
    'subsiding',
    'subsidize',
    'subsidy',
    'subsoil',
    'subsonic',
    'substance',
    'subsystem',
    'subtext',
    'subtitle',
    'subtly',
    'subtotal',
    'subtract',
    'subtype',
    'suburb',
    'subway',
    'subwoofer',
    'subzero',
    'succulent',
    'such',
    'suction',
    'sudden',
    'sudoku',
    'suds',
    'sufferer',
    'suffering',
    'suffice',
    'suffix',
    'suffocate',
    'suffrage',
    'sugar',
    'suggest',
    'suing',
    'suitable',
    'suitably',
    'suitcase',
    'suitor',
    'sulfate',
    'sulfide',
    'sulfite',
    'sulfur',
    'sulk',
    'sullen',
    'sulphate',
    'sulphuric',
    'sultry',
    'superbowl',
    'superglue',
    'superhero',
    'superior',
    'superjet',
    'superman',
    'supermom',
    'supernova',
    'supervise',
    'supper',
    'supplier',
    'supply',
    'support',
    'supremacy',
    'supreme',
    'surcharge',
    'surely',
    'sureness',
    'surface',
    'surfacing',
    'surfboard',
    'surfer',
    'surgery',
    'surgical',
    'surging',
    'surname',
    'surpass',
    'surplus',
    'surprise',
    'surreal',
    'surrender',
    'surrogate',
    'surround',
    'survey',
    'survival',
    'survive',
    'surviving',
    'survivor',
    'sushi',
    'suspect',
    'suspend',
    'suspense',
    'sustained',
    'sustainer',
    'swab',
    'swaddling',
    'swagger',
    'swampland',
    'swan',
    'swapping',
    'swarm',
    'sway',
    'swear',
    'sweat',
    'sweep',
    'swell',
    'swept',
    'swerve',
    'swifter',
    'swiftly',
    'swiftness',
    'swimmable',
    'swimmer',
    'swimming',
    'swimsuit',
    'swimwear',
    'swinger',
    'swinging',
    'swipe',
    'swirl',
    'switch',
    'swivel',
    'swizzle',
    'swooned',
    'swoop',
    'swoosh',
    'swore',
    'sworn',
    'swung',
    'sycamore',
    'sympathy',
    'symphonic',
    'symphony',
    'symptom',
    'synapse',
    'syndrome',
    'synergy',
    'synopses',
    'synopsis',
    'synthesis',
    'synthetic',
    'syrup',
    'system',
    't-shirt',
    'tabasco',
    'tabby',
    'tableful',
    'tables',
    'tablet',
    'tableware',
    'tabloid',
    'tackiness',
    'tacking',
    'tackle',
    'tackling',
    'tacky',
    'taco',
    'tactful',
    'tactical',
    'tactics',
    'tactile',
    'tactless',
    'tadpole',
    'taekwondo',
    'tag',
    'tainted',
    'take',
    'taking',
    'talcum',
    'talisman',
    'tall',
    'talon',
    'tamale',
    'tameness',
    'tamer',
    'tamper',
    'tank',
    'tanned',
    'tannery',
    'tanning',
    'tantrum',
    'tapeless',
    'tapered',
    'tapering',
    'tapestry',
    'tapioca',
    'tapping',
    'taps',
    'tarantula',
    'target',
    'tarmac',
    'tarnish',
    'tarot',
    'tartar',
    'tartly',
    'tartness',
    'task',
    'tassel',
    'taste',
    'tastiness',
    'tasting',
    'tasty',
    'tattered',
    'tattle',
    'tattling',
    'tattoo',
    'taunt',
    'tavern',
    'thank',
    'that',
    'thaw',
    'theater',
    'theatrics',
    'thee',
    'theft',
    'theme',
    'theology',
    'theorize',
    'thermal',
    'thermos',
    'thesaurus',
    'these',
    'thesis',
    'thespian',
    'thicken',
    'thicket',
    'thickness',
    'thieving',
    'thievish',
    'thigh',
    'thimble',
    'thing',
    'think',
    'thinly',
    'thinner',
    'thinness',
    'thinning',
    'thirstily',
    'thirsting',
    'thirsty',
    'thirteen',
    'thirty',
    'thong',
    'thorn',
    'those',
    'thousand',
    'thrash',
    'thread',
    'threaten',
    'threefold',
    'thrift',
    'thrill',
    'thrive',
    'thriving',
    'throat',
    'throbbing',
    'throng',
    'throttle',
    'throwaway',
    'throwback',
    'thrower',
    'throwing',
    'thud',
    'thumb',
    'thumping',
    'thursday',
    'thus',
    'thwarting',
    'thyself',
    'tiara',
    'tibia',
    'tidal',
    'tidbit',
    'tidiness',
    'tidings',
    'tidy',
    'tiger',
    'tighten',
    'tightly',
    'tightness',
    'tightrope',
    'tightwad',
    'tigress',
    'tile',
    'tiling',
    'till',
    'tilt',
    'timid',
    'timing',
    'timothy',
    'tinderbox',
    'tinfoil',
    'tingle',
    'tingling',
    'tingly',
    'tinker',
    'tinkling',
    'tinsel',
    'tinsmith',
    'tint',
    'tinwork',
    'tiny',
    'tipoff',
    'tipped',
    'tipper',
    'tipping',
    'tiptoeing',
    'tiptop',
    'tiring',
    'tissue',
    'trace',
    'tracing',
    'track',
    'traction',
    'tractor',
    'trade',
    'trading',
    'tradition',
    'traffic',
    'tragedy',
    'trailing',
    'trailside',
    'train',
    'traitor',
    'trance',
    'tranquil',
    'transfer',
    'transform',
    'translate',
    'transpire',
    'transport',
    'transpose',
    'trapdoor',
    'trapeze',
    'trapezoid',
    'trapped',
    'trapper',
    'trapping',
    'traps',
    'trash',
    'travel',
    'traverse',
    'travesty',
    'tray',
    'treachery',
    'treading',
    'treadmill',
    'treason',
    'treat',
    'treble',
    'tree',
    'trekker',
    'tremble',
    'trembling',
    'tremor',
    'trench',
    'trend',
    'trespass',
    'triage',
    'trial',
    'triangle',
    'tribesman',
    'tribunal',
    'tribune',
    'tributary',
    'tribute',
    'triceps',
    'trickery',
    'trickily',
    'tricking',
    'trickle',
    'trickster',
    'tricky',
    'tricolor',
    'tricycle',
    'trident',
    'tried',
    'trifle',
    'trifocals',
    'trillion',
    'trilogy',
    'trimester',
    'trimmer',
    'trimming',
    'trimness',
    'trinity',
    'trio',
    'tripod',
    'tripping',
    'triumph',
    'trivial',
    'trodden',
    'trolling',
    'trombone',
    'trophy',
    'tropical',
    'tropics',
    'trouble',
    'troubling',
    'trough',
    'trousers',
    'trout',
    'trowel',
    'truce',
    'truck',
    'truffle',
    'trump',
    'trunks',
    'trustable',
    'trustee',
    'trustful',
    'trusting',
    'trustless',
    'truth',
    'try',
    'tubby',
    'tubeless',
    'tubular',
    'tucking',
    'tuesday',
    'tug',
    'tuition',
    'tulip',
    'tumble',
    'tumbling',
    'tummy',
    'turban',
    'turbine',
    'turbofan',
    'turbojet',
    'turbulent',
    'turf',
    'turkey',
    'turmoil',
    'turret',
    'turtle',
    'tusk',
    'tutor',
    'tutu',
    'tux',
    'tweak',
    'tweed',
    'tweet',
    'tweezers',
    'twelve',
    'twentieth',
    'twenty',
    'twerp',
    'twice',
    'twiddle',
    'twiddling',
    'twig',
    'twilight',
    'twine',
    'twins',
    'twirl',
    'twistable',
    'twisted',
    'twister',
    'twisting',
    'twisty',
    'twitch',
    'twitter',
    'tycoon',
    'tying',
    'tyke',
    'udder',
    'ultimate',
    'ultimatum',
    'ultra',
    'umbilical',
    'umbrella',
    'umpire',
    'unabashed',
    'unable',
    'unadorned',
    'unadvised',
    'unafraid',
    'unaired',
    'unaligned',
    'unaltered',
    'unarmored',
    'unashamed',
    'unaudited',
    'unawake',
    'unaware',
    'unbaked',
    'unbalance',
    'unbeaten',
    'unbend',
    'unbent',
    'unbiased',
    'unbitten',
    'unblended',
    'unblessed',
    'unblock',
    'unbolted',
    'unbounded',
    'unboxed',
    'unbraided',
    'unbridle',
    'unbroken',
    'unbuckled',
    'unbundle',
    'unburned',
    'unbutton',
    'uncanny',
    'uncapped',
    'uncaring',
    'uncertain',
    'unchain',
    'unchanged',
    'uncharted',
    'uncheck',
    'uncivil',
    'unclad',
    'unclaimed',
    'unclamped',
    'unclasp',
    'uncle',
    'unclip',
    'uncloak',
    'unclog',
    'unclothed',
    'uncoated',
    'uncoiled',
    'uncolored',
    'uncombed',
    'uncommon',
    'uncooked',
    'uncork',
    'uncorrupt',
    'uncounted',
    'uncouple',
    'uncouth',
    'uncover',
    'uncross',
    'uncrown',
    'uncrushed',
    'uncured',
    'uncurious',
    'uncurled',
    'uncut',
    'undamaged',
    'undated',
    'undaunted',
    'undead',
    'undecided',
    'undefined',
    'underage',
    'underarm',
    'undercoat',
    'undercook',
    'undercut',
    'underdog',
    'underdone',
    'underfed',
    'underfeed',
    'underfoot',
    'undergo',
    'undergrad',
    'underhand',
    'underline',
    'underling',
    'undermine',
    'undermost',
    'underpaid',
    'underpass',
    'underpay',
    'underrate',
    'undertake',
    'undertone',
    'undertook',
    'undertow',
    'underuse',
    'underwear',
    'underwent',
    'underwire',
    'undesired',
    'undiluted',
    'undivided',
    'undocked',
    'undoing',
    'undone',
    'undrafted',
    'undress',
    'undrilled',
    'undusted',
    'undying',
    'unearned',
    'unearth',
    'unease',
    'uneasily',
    'uneasy',
    'uneatable',
    'uneaten',
    'unedited',
    'unelected',
    'unending',
    'unengaged',
    'unenvied',
    'unequal',
    'unethical',
    'uneven',
    'unexpired',
    'unexposed',
    'unfailing',
    'unfair',
    'unfasten',
    'unfazed',
    'unfeeling',
    'unfiled',
    'unfilled',
    'unfitted',
    'unfitting',
    'unfixable',
    'unfixed',
    'unflawed',
    'unfocused',
    'unfold',
    'unfounded',
    'unframed',
    'unfreeze',
    'unfrosted',
    'unfrozen',
    'unfunded',
    'unglazed',
    'ungloved',
    'unglue',
    'ungodly',
    'ungraded',
    'ungreased',
    'unguarded',
    'unguided',
    'unhappily',
    'unhappy',
    'unharmed',
    'unhealthy',
    'unheard',
    'unhearing',
    'unheated',
    'unhelpful',
    'unhidden',
    'unhinge',
    'unhitched',
    'unholy',
    'unhook',
    'unicorn',
    'unicycle',
    'unified',
    'unifier',
    'uniformed',
    'uniformly',
    'unify',
    'unimpeded',
    'uninjured',
    'uninstall',
    'uninsured',
    'uninvited',
    'union',
    'uniquely',
    'unisexual',
    'unison',
    'unissued',
    'unit',
    'universal',
    'universe',
    'unjustly',
    'unkempt',
    'unkind',
    'unknotted',
    'unknowing',
    'unknown',
    'unlaced',
    'unlatch',
    'unlawful',
    'unleaded',
    'unlearned',
    'unleash',
    'unless',
    'unleveled',
    'unlighted',
    'unlikable',
    'unlimited',
    'unlined',
    'unlinked',
    'unlisted',
    'unlit',
    'unlivable',
    'unloaded',
    'unloader',
    'unlocked',
    'unlocking',
    'unlovable',
    'unloved',
    'unlovely',
    'unloving',
    'unluckily',
    'unlucky',
    'unmade',
    'unmanaged',
    'unmanned',
    'unmapped',
    'unmarked',
    'unmasked',
    'unmasking',
    'unmatched',
    'unmindful',
    'unmixable',
    'unmixed',
    'unmolded',
    'unmoral',
    'unmovable',
    'unmoved',
    'unmoving',
    'unnamable',
    'unnamed',
    'unnatural',
    'unneeded',
    'unnerve',
    'unnerving',
    'unnoticed',
    'unopened',
    'unopposed',
    'unpack',
    'unpadded',
    'unpaid',
    'unpainted',
    'unpaired',
    'unpaved',
    'unpeeled',
    'unpicked',
    'unpiloted',
    'unpinned',
    'unplanned',
    'unplanted',
    'unpleased',
    'unpledged',
    'unplowed',
    'unplug',
    'unpopular',
    'unproven',
    'unquote',
    'unranked',
    'unrated',
    'unraveled',
    'unreached',
    'unread',
    'unreal',
    'unreeling',
    'unrefined',
    'unrelated',
    'unrented',
    'unrest',
    'unretired',
    'unrevised',
    'unrigged',
    'unripe',
    'unrivaled',
    'unroasted',
    'unrobed',
    'unroll',
    'unruffled',
    'unruly',
    'unrushed',
    'unsaddle',
    'unsafe',
    'unsaid',
    'unsalted',
    'unsaved',
    'unsavory',
    'unscathed',
    'unscented',
    'unscrew',
    'unsealed',
    'unseated',
    'unsecured',
    'unseeing',
    'unseemly',
    'unseen',
    'unselect',
    'unselfish',
    'unsent',
    'unsettled',
    'unshackle',
    'unshaken',
    'unshaved',
    'unshaven',
    'unsheathe',
    'unshipped',
    'unsightly',
    'unsigned',
    'unskilled',
    'unsliced',
    'unsmooth',
    'unsnap',
    'unsocial',
    'unsoiled',
    'unsold',
    'unsolved',
    'unsorted',
    'unspoiled',
    'unspoken',
    'unstable',
    'unstaffed',
    'unstamped',
    'unsteady',
    'unsterile',
    'unstirred',
    'unstitch',
    'unstopped',
    'unstuck',
    'unstuffed',
    'unstylish',
    'unsubtle',
    'unsubtly',
    'unsuited',
    'unsure',
    'unsworn',
    'untagged',
    'untainted',
    'untaken',
    'untamed',
    'untangled',
    'untapped',
    'untaxed',
    'unthawed',
    'unthread',
    'untidy',
    'untie',
    'until',
    'untimed',
    'untimely',
    'untitled',
    'untoasted',
    'untold',
    'untouched',
    'untracked',
    'untrained',
    'untreated',
    'untried',
    'untrimmed',
    'untrue',
    'untruth',
    'unturned',
    'untwist',
    'untying',
    'unusable',
    'unused',
    'unusual',
    'unvalued',
    'unvaried',
    'unvarying',
    'unveiled',
    'unveiling',
    'unvented',
    'unviable',
    'unvisited',
    'unvocal',
    'unwanted',
    'unwarlike',
    'unwary',
    'unwashed',
    'unwatched',
    'unweave',
    'unwed',
    'unwelcome',
    'unwell',
    'unwieldy',
    'unwilling',
    'unwind',
    'unwired',
    'unwitting',
    'unwomanly',
    'unworldly',
    'unworn',
    'unworried',
    'unworthy',
    'unwound',
    'unwoven',
    'unwrapped',
    'unwritten',
    'unzip',
    'upbeat',
    'upchuck',
    'upcoming',
    'upcountry',
    'update',
    'upfront',
    'upgrade',
    'upheaval',
    'upheld',
    'uphill',
    'uphold',
    'uplifted',
    'uplifting',
    'upload',
    'upon',
    'upper',
    'upright',
    'uprising',
    'upriver',
    'uproar',
    'uproot',
    'upscale',
    'upside',
    'upstage',
    'upstairs',
    'upstart',
    'upstate',
    'upstream',
    'upstroke',
    'upswing',
    'uptake',
    'uptight',
    'uptown',
    'upturned',
    'upward',
    'upwind',
    'uranium',
    'urban',
    'urchin',
    'urethane',
    'urgency',
    'urgent',
    'urging',
    'urologist',
    'urology',
    'usable',
    'usage',
    'useable',
    'used',
    'uselessly',
    'user',
    'usher',
    'usual',
    'utensil',
    'utility',
    'utilize',
    'utmost',
    'utopia',
    'utter',
    'vacancy',
    'vacant',
    'vacate',
    'vacation',
    'vagabond',
    'vagrancy',
    'vagrantly',
    'vaguely',
    'vagueness',
    'valiant',
    'valid',
    'valium',
    'valley',
    'valuables',
    'value',
    'vanilla',
    'vanish',
    'vanity',
    'vanquish',
    'vantage',
    'vaporizer',
    'variable',
    'variably',
    'varied',
    'variety',
    'various',
    'varmint',
    'varnish',
    'varsity',
    'varying',
    'vascular',
    'vaseline',
    'vastly',
    'vastness',
    'veal',
    'vegan',
    'veggie',
    'vehicular',
    'velcro',
    'velocity',
    'velvet',
    'vendetta',
    'vending',
    'vendor',
    'veneering',
    'vengeful',
    'venomous',
    'ventricle',
    'venture',
    'venue',
    'venus',
    'verbalize',
    'verbally',
    'verbose',
    'verdict',
    'verify',
    'verse',
    'version',
    'versus',
    'vertebrae',
    'vertical',
    'vertigo',
    'very',
    'vessel',
    'vest',
    'veteran',
    'veto',
    'vexingly',
    'viability',
    'viable',
    'vibes',
    'vice',
    'vicinity',
    'victory',
    'video',
    'viewable',
    'viewer',
    'viewing',
    'viewless',
    'viewpoint',
    'vigorous',
    'village',
    'villain',
    'vindicate',
    'vineyard',
    'vintage',
    'violate',
    'violation',
    'violator',
    'violet',
    'violin',
    'viper',
    'viral',
    'virtual',
    'virtuous',
    'virus',
    'visa',
    'viscosity',
    'viscous',
    'viselike',
    'visible',
    'visibly',
    'vision',
    'visiting',
    'visitor',
    'visor',
    'vista',
    'vitality',
    'vitalize',
    'vitally',
    'vitamins',
    'vivacious',
    'vividly',
    'vividness',
    'vixen',
    'vocalist',
    'vocalize',
    'vocally',
    'vocation',
    'voice',
    'voicing',
    'void',
    'volatile',
    'volley',
    'voltage',
    'volumes',
    'voter',
    'voting',
    'voucher',
    'vowed',
    'vowel',
    'voyage',
    'wackiness',
    'wad',
    'wafer',
    'waffle',
    'waged',
    'wager',
    'wages',
    'waggle',
    'wagon',
    'wake',
    'waking',
    'walk',
    'walmart',
    'walnut',
    'walrus',
    'waltz',
    'wand',
    'wannabe',
    'wanted',
    'wanting',
    'wasabi',
    'washable',
    'washbasin',
    'washboard',
    'washbowl',
    'washcloth',
    'washday',
    'washed',
    'washer',
    'washhouse',
    'washing',
    'washout',
    'washroom',
    'washstand',
    'washtub',
    'wasp',
    'wasting',
    'watch',
    'water',
    'waviness',
    'waving',
    'wavy',
    'whacking',
    'whacky',
    'wham',
    'wharf',
    'wheat',
    'whenever',
    'whiff',
    'whimsical',
    'whinny',
    'whiny',
    'whisking',
    'whoever',
    'whole',
    'whomever',
    'whoopee',
    'whooping',
    'whoops',
    'why',
    'wick',
    'widely',
    'widen',
    'widget',
    'widow',
    'width',
    'wieldable',
    'wielder',
    'wife',
    'wifi',
    'wikipedia',
    'wildcard',
    'wildcat',
    'wilder',
    'wildfire',
    'wildfowl',
    'wildland',
    'wildlife',
    'wildly',
    'wildness',
    'willed',
    'willfully',
    'willing',
    'willow',
    'willpower',
    'wilt',
    'wimp',
    'wince',
    'wincing',
    'wind',
    'wing',
    'winking',
    'winner',
    'winnings',
    'winter',
    'wipe',
    'wired',
    'wireless',
    'wiring',
    'wiry',
    'wisdom',
    'wise',
    'wish',
    'wisplike',
    'wispy',
    'wistful',
    'wizard',
    'wobble',
    'wobbling',
    'wobbly',
    'wok',
    'wolf',
    'wolverine',
    'womanhood',
    'womankind',
    'womanless',
    'womanlike',
    'womanly',
    'womb',
    'woof',
    'wooing',
    'wool',
    'woozy',
    'word',
    'work',
    'worried',
    'worrier',
    'worrisome',
    'worry',
    'worsening',
    'worshiper',
    'worst',
    'wound',
    'woven',
    'wow',
    'wrangle',
    'wrath',
    'wreath',
    'wreckage',
    'wrecker',
    'wrecking',
    'wrench',
    'wriggle',
    'wriggly',
    'wrinkle',
    'wrinkly',
    'wrist',
    'writing',
    'written',
    'wrongdoer',
    'wronged',
    'wrongful',
    'wrongly',
    'wrongness',
    'wrought',
    'xbox',
    'xerox',
    'yahoo',
    'yam',
    'yanking',
    'yapping',
    'yard',
    'yarn',
    'yeah',
    'yearbook',
    'yearling',
    'yearly',
    'yearning',
    'yeast',
    'yelling',
    'yelp',
    'yen',
    'yesterday',
    'yiddish',
    'yield',
    'yin',
    'yippee',
    'yo-yo',
    'yodel',
    'yoga',
    'yogurt',
    'yonder',
    'yoyo',
    'yummy',
    'zap',
    'zealous',
    'zebra',
    'zen',
    'zeppelin',
    'zero',
    'zestfully',
    'zesty',
    'zigzagged',
    'zipfile',
    'zipping',
    'zippy',
    'zips',
    'zit',
    'zodiac',
    'zombie',
    'zone',
    'zoning',
    'zookeeper',
    'zoologist',
    'zoology',
    'zoom',
];

// CONCATENATED MODULE: ./jslib/src/services/crypto.service.ts
var crypto_service_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var crypto_service_metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var crypto_service_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};










const crypto_service_Keys = {
    key: 'key',
    encOrgKeys: 'encOrgKeys',
    encPrivateKey: 'encPrivateKey',
    encKey: 'encKey',
    keyHash: 'keyHash',
};
class crypto_service_CryptoService {
    constructor(storageService, secureStorageService, cryptoFunctionService) {
        this.storageService = storageService;
        this.secureStorageService = secureStorageService;
        this.cryptoFunctionService = cryptoFunctionService;
    }
    setKey(key) {
        return crypto_service_awaiter(this, void 0, void 0, function* () {
            this.key = key;
            const option = yield this.storageService.get(ConstantsService.vaultTimeoutKey);
            if (option != null) {
                // if we have a lock option set, we do not store the key
                return;
            }
            return this.secureStorageService.save(crypto_service_Keys.key, key.keyB64);
        });
    }
    setKeyHash(keyHash) {
        this.keyHash = keyHash;
        return this.storageService.save(crypto_service_Keys.keyHash, keyHash);
    }
    setEncKey(encKey) {
        return crypto_service_awaiter(this, void 0, void 0, function* () {
            if (encKey == null) {
                return;
            }
            yield this.storageService.save(crypto_service_Keys.encKey, encKey);
            this.encKey = null;
        });
    }
    setEncPrivateKey(encPrivateKey) {
        return crypto_service_awaiter(this, void 0, void 0, function* () {
            if (encPrivateKey == null) {
                return;
            }
            yield this.storageService.save(crypto_service_Keys.encPrivateKey, encPrivateKey);
            this.privateKey = null;
        });
    }
    setOrgKeys(orgs) {
        const orgKeys = {};
        orgs.forEach((org) => {
            orgKeys[org.id] = org.key;
        });
        this.orgKeys = null;
        return this.storageService.save(crypto_service_Keys.encOrgKeys, orgKeys);
    }
    getKey() {
        return crypto_service_awaiter(this, void 0, void 0, function* () {
            if (this.key != null) {
                return this.key;
            }
            const key = yield this.secureStorageService.get(crypto_service_Keys.key);
            if (key != null) {
                this.key = new symmetricCryptoKey_SymmetricCryptoKey(utils_Utils.fromB64ToArray(key).buffer);
            }
            return key == null ? null : this.key;
        });
    }
    getKeyHash() {
        return crypto_service_awaiter(this, void 0, void 0, function* () {
            if (this.keyHash != null) {
                return this.keyHash;
            }
            const keyHash = yield this.storageService.get(crypto_service_Keys.keyHash);
            if (keyHash != null) {
                this.keyHash = keyHash;
            }
            return keyHash == null ? null : this.keyHash;
        });
    }
    getEncKey(key = null) {
        return crypto_service_awaiter(this, void 0, void 0, function* () {
            if (this.encKey != null) {
                return this.encKey;
            }
            const encKey = yield this.storageService.get(crypto_service_Keys.encKey);
            if (encKey == null) {
                return null;
            }
            if (key == null) {
                key = yield this.getKey();
            }
            if (key == null) {
                return null;
            }
            let decEncKey;
            const encKeyCipher = new cipherString_CipherString(encKey);
            if (encKeyCipher.encryptionType === EncryptionType.AesCbc256_B64) {
                decEncKey = yield this.decryptToBytes(encKeyCipher, key);
            }
            else if (encKeyCipher.encryptionType === EncryptionType.AesCbc256_HmacSha256_B64) {
                const newKey = yield this.stretchKey(key);
                decEncKey = yield this.decryptToBytes(encKeyCipher, newKey);
            }
            else {
                throw new Error('Unsupported encKey type.');
            }
            if (decEncKey == null) {
                return null;
            }
            this.encKey = new symmetricCryptoKey_SymmetricCryptoKey(decEncKey);
            return this.encKey;
        });
    }
    getPublicKey() {
        return crypto_service_awaiter(this, void 0, void 0, function* () {
            if (this.publicKey != null) {
                return this.publicKey;
            }
            const privateKey = yield this.getPrivateKey();
            if (privateKey == null) {
                return null;
            }
            this.publicKey = yield this.cryptoFunctionService.rsaExtractPublicKey(privateKey);
            return this.publicKey;
        });
    }
    getPrivateKey() {
        return crypto_service_awaiter(this, void 0, void 0, function* () {
            if (this.privateKey != null) {
                return this.privateKey;
            }
            const encPrivateKey = yield this.storageService.get(crypto_service_Keys.encPrivateKey);
            if (encPrivateKey == null) {
                return null;
            }
            this.privateKey = yield this.decryptToBytes(new cipherString_CipherString(encPrivateKey), null);
            return this.privateKey;
        });
    }
    getFingerprint(userId, publicKey) {
        return crypto_service_awaiter(this, void 0, void 0, function* () {
            if (publicKey == null) {
                publicKey = yield this.getPublicKey();
            }
            if (publicKey === null) {
                throw new Error('No public key available.');
            }
            const keyFingerprint = yield this.cryptoFunctionService.hash(publicKey, 'sha256');
            const userFingerprint = yield this.hkdfExpand(keyFingerprint, utils_Utils.fromUtf8ToArray(userId), 32);
            return this.hashPhrase(userFingerprint.buffer);
        });
    }
    getOrgKeys() {
        return crypto_service_awaiter(this, void 0, void 0, function* () {
            if (this.orgKeys != null && this.orgKeys.size > 0) {
                return this.orgKeys;
            }
            const encOrgKeys = yield this.storageService.get(crypto_service_Keys.encOrgKeys);
            if (encOrgKeys == null) {
                return null;
            }
            const orgKeys = new Map();
            let setKey = false;
            for (const orgId in encOrgKeys) {
                if (!encOrgKeys.hasOwnProperty(orgId)) {
                    continue;
                }
                const decValue = yield this.rsaDecrypt(encOrgKeys[orgId]);
                orgKeys.set(orgId, new symmetricCryptoKey_SymmetricCryptoKey(decValue));
                setKey = true;
            }
            if (setKey) {
                this.orgKeys = orgKeys;
            }
            return this.orgKeys;
        });
    }
    getOrgKey(orgId) {
        return crypto_service_awaiter(this, void 0, void 0, function* () {
            if (orgId == null) {
                return null;
            }
            const orgKeys = yield this.getOrgKeys();
            if (orgKeys == null || !orgKeys.has(orgId)) {
                return null;
            }
            return orgKeys.get(orgId);
        });
    }
    hasKey() {
        return crypto_service_awaiter(this, void 0, void 0, function* () {
            return (yield this.getKey()) != null;
        });
    }
    hasEncKey() {
        return crypto_service_awaiter(this, void 0, void 0, function* () {
            const encKey = yield this.storageService.get(crypto_service_Keys.encKey);
            return encKey != null;
        });
    }
    clearKey() {
        this.key = this.legacyEtmKey = null;
        return this.secureStorageService.remove(crypto_service_Keys.key);
    }
    clearKeyHash() {
        this.keyHash = null;
        return this.storageService.remove(crypto_service_Keys.keyHash);
    }
    clearEncKey(memoryOnly) {
        this.encKey = null;
        if (memoryOnly) {
            return Promise.resolve();
        }
        return this.storageService.remove(crypto_service_Keys.encKey);
    }
    clearKeyPair(memoryOnly) {
        this.privateKey = null;
        this.publicKey = null;
        if (memoryOnly) {
            return Promise.resolve();
        }
        return this.storageService.remove(crypto_service_Keys.encPrivateKey);
    }
    clearOrgKeys(memoryOnly) {
        this.orgKeys = null;
        if (memoryOnly) {
            return Promise.resolve();
        }
        return this.storageService.remove(crypto_service_Keys.encOrgKeys);
    }
    clearPinProtectedKey() {
        return this.storageService.remove(ConstantsService.pinProtectedKey);
    }
    clearKeys() {
        return Promise.all([
            this.clearKey(),
            this.clearKeyHash(),
            this.clearOrgKeys(),
            this.clearEncKey(),
            this.clearKeyPair(),
            this.clearPinProtectedKey(),
        ]);
    }
    toggleKey() {
        return crypto_service_awaiter(this, void 0, void 0, function* () {
            const key = yield this.getKey();
            const option = yield this.storageService.get(ConstantsService.vaultTimeoutKey);
            if (option != null || option === 0) {
                // if we have a lock option set, clear the key
                yield this.clearKey();
                this.key = key;
                return;
            }
            yield this.setKey(key);
        });
    }
    makeKey(password, salt, kdf, kdfIterations) {
        return crypto_service_awaiter(this, void 0, void 0, function* () {
            let key = null;
            if (kdf == null || kdf === KdfType.PBKDF2_SHA256) {
                if (kdfIterations == null) {
                    kdfIterations = 5000;
                }
                else if (kdfIterations < 5000) {
                    throw new Error('PBKDF2 iteration minimum is 5000.');
                }
                key = yield this.cryptoFunctionService.pbkdf2(password, salt, 'sha256', kdfIterations);
            }
            else {
                throw new Error('Unknown Kdf.');
            }
            return new symmetricCryptoKey_SymmetricCryptoKey(key);
        });
    }
    makeKeyFromPin(pin, salt, kdf, kdfIterations, protectedKeyCs = null) {
        return crypto_service_awaiter(this, void 0, void 0, function* () {
            if (protectedKeyCs == null) {
                const pinProtectedKey = yield this.storageService.get(ConstantsService.pinProtectedKey);
                if (pinProtectedKey == null) {
                    throw new Error('No PIN protected key found.');
                }
                protectedKeyCs = new cipherString_CipherString(pinProtectedKey);
            }
            const pinKey = yield this.makePinKey(pin, salt, kdf, kdfIterations);
            const decKey = yield this.decryptToBytes(protectedKeyCs, pinKey);
            return new symmetricCryptoKey_SymmetricCryptoKey(decKey);
        });
    }
    makeShareKey() {
        return crypto_service_awaiter(this, void 0, void 0, function* () {
            const shareKey = yield this.cryptoFunctionService.randomBytes(64);
            const publicKey = yield this.getPublicKey();
            const encShareKey = yield this.rsaEncrypt(shareKey, publicKey);
            return [encShareKey, new symmetricCryptoKey_SymmetricCryptoKey(shareKey)];
        });
    }
    makeKeyPair(key) {
        return crypto_service_awaiter(this, void 0, void 0, function* () {
            const keyPair = yield this.cryptoFunctionService.rsaGenerateKeyPair(2048);
            const publicB64 = utils_Utils.fromBufferToB64(keyPair[0]);
            const privateEnc = yield this.encrypt(keyPair[1], key);
            return [publicB64, privateEnc];
        });
    }
    makePinKey(pin, salt, kdf, kdfIterations) {
        return crypto_service_awaiter(this, void 0, void 0, function* () {
            const pinKey = yield this.makeKey(pin, salt, kdf, kdfIterations);
            return yield this.stretchKey(pinKey);
        });
    }
    hashPassword(password, key) {
        return crypto_service_awaiter(this, void 0, void 0, function* () {
            if (key == null) {
                key = yield this.getKey();
            }
            if (password == null || key == null) {
                throw new Error('Invalid parameters.');
            }
            const hash = yield this.cryptoFunctionService.pbkdf2(key.key, password, 'sha256', 1);
            return utils_Utils.fromBufferToB64(hash);
        });
    }
    makeEncKey(key) {
        return crypto_service_awaiter(this, void 0, void 0, function* () {
            const theKey = yield this.getKeyForEncryption(key);
            const encKey = yield this.cryptoFunctionService.randomBytes(64);
            return this.buildEncKey(theKey, encKey);
        });
    }
    remakeEncKey(key) {
        return crypto_service_awaiter(this, void 0, void 0, function* () {
            const encKey = yield this.getEncKey();
            return this.buildEncKey(key, encKey.key);
        });
    }
    encrypt(plainValue, key) {
        return crypto_service_awaiter(this, void 0, void 0, function* () {
            if (plainValue == null) {
                return Promise.resolve(null);
            }
            let plainBuf;
            if (typeof (plainValue) === 'string') {
                plainBuf = utils_Utils.fromUtf8ToArray(plainValue).buffer;
            }
            else {
                plainBuf = plainValue;
            }
            const encObj = yield this.aesEncrypt(plainBuf, key);
            const iv = utils_Utils.fromBufferToB64(encObj.iv);
            const data = utils_Utils.fromBufferToB64(encObj.data);
            const mac = encObj.mac != null ? utils_Utils.fromBufferToB64(encObj.mac) : null;
            return new cipherString_CipherString(encObj.key.encType, data, iv, mac);
        });
    }
    encryptToBytes(plainValue, key) {
        return crypto_service_awaiter(this, void 0, void 0, function* () {
            const encValue = yield this.aesEncrypt(plainValue, key);
            let macLen = 0;
            if (encValue.mac != null) {
                macLen = encValue.mac.byteLength;
            }
            const encBytes = new Uint8Array(1 + encValue.iv.byteLength + macLen + encValue.data.byteLength);
            encBytes.set([encValue.key.encType]);
            encBytes.set(new Uint8Array(encValue.iv), 1);
            if (encValue.mac != null) {
                encBytes.set(new Uint8Array(encValue.mac), 1 + encValue.iv.byteLength);
            }
            encBytes.set(new Uint8Array(encValue.data), 1 + encValue.iv.byteLength + macLen);
            return encBytes.buffer;
        });
    }
    rsaEncrypt(data, publicKey) {
        return crypto_service_awaiter(this, void 0, void 0, function* () {
            if (publicKey == null) {
                publicKey = yield this.getPublicKey();
            }
            if (publicKey == null) {
                throw new Error('Public key unavailable.');
            }
            const encBytes = yield this.cryptoFunctionService.rsaEncrypt(data, publicKey, 'sha1');
            return new cipherString_CipherString(EncryptionType.Rsa2048_OaepSha1_B64, utils_Utils.fromBufferToB64(encBytes));
        });
    }
    decryptToBytes(cipherString, key) {
        return crypto_service_awaiter(this, void 0, void 0, function* () {
            const iv = utils_Utils.fromB64ToArray(cipherString.iv).buffer;
            const data = utils_Utils.fromB64ToArray(cipherString.data).buffer;
            const mac = cipherString.mac ? utils_Utils.fromB64ToArray(cipherString.mac).buffer : null;
            const decipher = yield this.aesDecryptToBytes(cipherString.encryptionType, data, iv, mac, key);
            if (decipher == null) {
                return null;
            }
            return decipher;
        });
    }
    decryptToUtf8(cipherString, key) {
        return crypto_service_awaiter(this, void 0, void 0, function* () {
            return yield this.aesDecryptToUtf8(cipherString.encryptionType, cipherString.data, cipherString.iv, cipherString.mac, key);
        });
    }
    decryptFromBytes(encBuf, key) {
        return crypto_service_awaiter(this, void 0, void 0, function* () {
            if (encBuf == null) {
                throw new Error('no encBuf.');
            }
            const encBytes = new Uint8Array(encBuf);
            const encType = encBytes[0];
            let ctBytes = null;
            let ivBytes = null;
            let macBytes = null;
            switch (encType) {
                case EncryptionType.AesCbc128_HmacSha256_B64:
                case EncryptionType.AesCbc256_HmacSha256_B64:
                    if (encBytes.length <= 49) { // 1 + 16 + 32 + ctLength
                        return null;
                    }
                    ivBytes = encBytes.slice(1, 17);
                    macBytes = encBytes.slice(17, 49);
                    ctBytes = encBytes.slice(49);
                    break;
                case EncryptionType.AesCbc256_B64:
                    if (encBytes.length <= 17) { // 1 + 16 + ctLength
                        return null;
                    }
                    ivBytes = encBytes.slice(1, 17);
                    ctBytes = encBytes.slice(17);
                    break;
                default:
                    return null;
            }
            return yield this.aesDecryptToBytes(encType, ctBytes.buffer, ivBytes.buffer, macBytes != null ? macBytes.buffer : null, key);
        });
    }
    // EFForg/OpenWireless
    // ref https://github.com/EFForg/OpenWireless/blob/master/app/js/diceware.js
    randomNumber(min, max) {
        return crypto_service_awaiter(this, void 0, void 0, function* () {
            let rval = 0;
            const range = max - min + 1;
            const bitsNeeded = Math.ceil(Math.log2(range));
            if (bitsNeeded > 53) {
                throw new Error('We cannot generate numbers larger than 53 bits.');
            }
            const bytesNeeded = Math.ceil(bitsNeeded / 8);
            const mask = Math.pow(2, bitsNeeded) - 1;
            // 7776 -> (2^13 = 8192) -1 == 8191 or 0x00001111 11111111
            // Fill a byte array with N random numbers
            const byteArray = new Uint8Array(yield this.cryptoFunctionService.randomBytes(bytesNeeded));
            let p = (bytesNeeded - 1) * 8;
            for (let i = 0; i < bytesNeeded; i++) {
                rval += byteArray[i] * Math.pow(2, p);
                p -= 8;
            }
            // Use & to apply the mask and reduce the number of recursive lookups
            // tslint:disable-next-line
            rval = rval & mask;
            if (rval >= range) {
                // Integer out of acceptable range
                return this.randomNumber(min, max);
            }
            // Return an integer that falls within the range
            return min + rval;
        });
    }
    // Helpers
    aesEncrypt(data, key) {
        return crypto_service_awaiter(this, void 0, void 0, function* () {
            const obj = new EncryptedObject();
            obj.key = yield this.getKeyForEncryption(key);
            obj.iv = yield this.cryptoFunctionService.randomBytes(16);
            obj.data = yield this.cryptoFunctionService.aesEncrypt(data, obj.iv, obj.key.encKey);
            if (obj.key.macKey != null) {
                const macData = new Uint8Array(obj.iv.byteLength + obj.data.byteLength);
                macData.set(new Uint8Array(obj.iv), 0);
                macData.set(new Uint8Array(obj.data), obj.iv.byteLength);
                obj.mac = yield this.cryptoFunctionService.hmac(macData.buffer, obj.key.macKey, 'sha256');
            }
            return obj;
        });
    }
    aesDecryptToUtf8(encType, data, iv, mac, key) {
        return crypto_service_awaiter(this, void 0, void 0, function* () {
            const keyForEnc = yield this.getKeyForEncryption(key);
            const theKey = this.resolveLegacyKey(encType, keyForEnc);
            if (theKey.macKey != null && mac == null) {
                // tslint:disable-next-line
                console.error('mac required.');
                return null;
            }
            if (theKey.encType !== encType) {
                // tslint:disable-next-line
                console.error('encType unavailable.');
                return null;
            }
            const fastParams = this.cryptoFunctionService.aesDecryptFastParameters(data, iv, mac, theKey);
            if (fastParams.macKey != null && fastParams.mac != null) {
                const computedMac = yield this.cryptoFunctionService.hmacFast(fastParams.macData, fastParams.macKey, 'sha256');
                const macsEqual = yield this.cryptoFunctionService.compareFast(fastParams.mac, computedMac);
                if (!macsEqual) {
                    // tslint:disable-next-line
                    console.error('mac failed.');
                    return null;
                }
            }
            return this.cryptoFunctionService.aesDecryptFast(fastParams);
        });
    }
    aesDecryptToBytes(encType, data, iv, mac, key) {
        return crypto_service_awaiter(this, void 0, void 0, function* () {
            const keyForEnc = yield this.getKeyForEncryption(key);
            const theKey = this.resolveLegacyKey(encType, keyForEnc);
            if (theKey.macKey != null && mac == null) {
                return null;
            }
            if (theKey.encType !== encType) {
                return null;
            }
            if (theKey.macKey != null && mac != null) {
                const macData = new Uint8Array(iv.byteLength + data.byteLength);
                macData.set(new Uint8Array(iv), 0);
                macData.set(new Uint8Array(data), iv.byteLength);
                const computedMac = yield this.cryptoFunctionService.hmac(macData.buffer, theKey.macKey, 'sha256');
                if (computedMac === null) {
                    return null;
                }
                const macsMatch = yield this.cryptoFunctionService.compare(mac, computedMac);
                if (!macsMatch) {
                    // tslint:disable-next-line
                    console.error('mac failed.');
                    return null;
                }
            }
            return yield this.cryptoFunctionService.aesDecrypt(data, iv, theKey.encKey);
        });
    }
    rsaDecrypt(encValue) {
        return crypto_service_awaiter(this, void 0, void 0, function* () {
            const headerPieces = encValue.split('.');
            let encType = null;
            let encPieces;
            if (headerPieces.length === 1) {
                encType = EncryptionType.Rsa2048_OaepSha256_B64;
                encPieces = [headerPieces[0]];
            }
            else if (headerPieces.length === 2) {
                try {
                    encType = parseInt(headerPieces[0], null);
                    encPieces = headerPieces[1].split('|');
                }
                catch (e) { }
            }
            switch (encType) {
                case EncryptionType.Rsa2048_OaepSha256_B64:
                case EncryptionType.Rsa2048_OaepSha1_B64:
                // HmacSha256 types are deprecated
                case EncryptionType.Rsa2048_OaepSha256_HmacSha256_B64:
                case EncryptionType.Rsa2048_OaepSha1_HmacSha256_B64:
                    break;
                default:
                    throw new Error('encType unavailable.');
            }
            if (encPieces == null || encPieces.length <= 0) {
                throw new Error('encPieces unavailable.');
            }
            const data = utils_Utils.fromB64ToArray(encPieces[0]).buffer;
            const privateKey = yield this.getPrivateKey();
            if (privateKey == null) {
                throw new Error('No private key.');
            }
            let alg = 'sha1';
            switch (encType) {
                case EncryptionType.Rsa2048_OaepSha256_B64:
                case EncryptionType.Rsa2048_OaepSha256_HmacSha256_B64:
                    alg = 'sha256';
                    break;
                case EncryptionType.Rsa2048_OaepSha1_B64:
                case EncryptionType.Rsa2048_OaepSha1_HmacSha256_B64:
                    break;
                default:
                    throw new Error('encType unavailable.');
            }
            return this.cryptoFunctionService.rsaDecrypt(data, privateKey, alg);
        });
    }
    getKeyForEncryption(key) {
        return crypto_service_awaiter(this, void 0, void 0, function* () {
            if (key != null) {
                return key;
            }
            const encKey = yield this.getEncKey();
            if (encKey != null) {
                return encKey;
            }
            return yield this.getKey();
        });
    }
    resolveLegacyKey(encType, key) {
        if (encType === EncryptionType.AesCbc128_HmacSha256_B64 &&
            key.encType === EncryptionType.AesCbc256_B64) {
            // Old encrypt-then-mac scheme, make a new key
            if (this.legacyEtmKey == null) {
                this.legacyEtmKey = new symmetricCryptoKey_SymmetricCryptoKey(key.key, EncryptionType.AesCbc128_HmacSha256_B64);
            }
            return this.legacyEtmKey;
        }
        return key;
    }
    stretchKey(key) {
        return crypto_service_awaiter(this, void 0, void 0, function* () {
            const newKey = new Uint8Array(64);
            newKey.set(yield this.hkdfExpand(key.key, utils_Utils.fromUtf8ToArray('enc'), 32));
            newKey.set(yield this.hkdfExpand(key.key, utils_Utils.fromUtf8ToArray('mac'), 32), 32);
            return new symmetricCryptoKey_SymmetricCryptoKey(newKey.buffer);
        });
    }
    // ref: https://tools.ietf.org/html/rfc5869
    hkdfExpand(prk, info, size) {
        return crypto_service_awaiter(this, void 0, void 0, function* () {
            const hashLen = 32; // sha256
            const okm = new Uint8Array(size);
            let previousT = new Uint8Array(0);
            const n = Math.ceil(size / hashLen);
            for (let i = 0; i < n; i++) {
                const t = new Uint8Array(previousT.length + info.length + 1);
                t.set(previousT);
                t.set(info, previousT.length);
                t.set([i + 1], t.length - 1);
                previousT = new Uint8Array(yield this.cryptoFunctionService.hmac(t.buffer, prk, 'sha256'));
                okm.set(previousT, i * hashLen);
            }
            return okm;
        });
    }
    hashPhrase(hash, minimumEntropy = 64) {
        return crypto_service_awaiter(this, void 0, void 0, function* () {
            const entropyPerWord = Math.log(EEFLongWordList.length) / Math.log(2);
            let numWords = Math.ceil(minimumEntropy / entropyPerWord);
            const hashArr = Array.from(new Uint8Array(hash));
            const entropyAvailable = hashArr.length * 4;
            if (numWords * entropyPerWord > entropyAvailable) {
                throw new Error('Output entropy of hash function is too small');
            }
            const phrase = [];
            let hashNumber = external_big_integer_["fromArray"](hashArr, 256);
            while (numWords--) {
                const remainder = hashNumber.mod(EEFLongWordList.length);
                hashNumber = hashNumber.divide(EEFLongWordList.length);
                phrase.push(EEFLongWordList[remainder]);
            }
            return phrase;
        });
    }
    buildEncKey(key, encKey) {
        return crypto_service_awaiter(this, void 0, void 0, function* () {
            let encKeyEnc = null;
            if (key.key.byteLength === 32) {
                const newKey = yield this.stretchKey(key);
                encKeyEnc = yield this.encrypt(encKey, newKey);
            }
            else if (key.key.byteLength === 64) {
                encKeyEnc = yield this.encrypt(encKey, key);
            }
            else {
                throw new Error('Invalid key size.');
            }
            return [new symmetricCryptoKey_SymmetricCryptoKey(encKey), encKeyEnc];
        });
    }
}
crypto_service_decorate([
    sequentialize(() => 'getEncKey'),
    crypto_service_metadata("design:type", Function),
    crypto_service_metadata("design:paramtypes", [symmetricCryptoKey_SymmetricCryptoKey]),
    crypto_service_metadata("design:returntype", Promise)
], crypto_service_CryptoService.prototype, "getEncKey", null);
crypto_service_decorate([
    sequentialize(() => 'getOrgKeys'),
    crypto_service_metadata("design:type", Function),
    crypto_service_metadata("design:paramtypes", []),
    crypto_service_metadata("design:returntype", Promise)
], crypto_service_CryptoService.prototype, "getOrgKeys", null);

// CONCATENATED MODULE: ./jslib/src/services/environment.service.ts
var environment_service_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};


class environment_service_EnvironmentService {
    constructor(apiService, storageService, notificationsService) {
        this.apiService = apiService;
        this.storageService = storageService;
        this.notificationsService = notificationsService;
    }
    getWebVaultUrl() {
        if (this.webVaultUrl != null) {
            return this.webVaultUrl;
        }
        else if (this.baseUrl) {
            return this.baseUrl;
        }
        return null;
    }
    setUrlsFromStorage() {
        return environment_service_awaiter(this, void 0, void 0, function* () {
            const urlsObj = yield this.storageService.get(ConstantsService.environmentUrlsKey);
            const urls = urlsObj || {
                base: null,
                api: null,
                identity: null,
                icons: null,
                notifications: null,
                events: null,
                webVault: null,
            };
            const envUrls = new EnvironmentUrls();
            if (urls.base) {
                this.baseUrl = envUrls.base = urls.base;
                this.apiService.setUrls(envUrls);
                return;
            }
            this.webVaultUrl = urls.webVault;
            this.apiUrl = envUrls.api = urls.api;
            this.identityUrl = envUrls.identity = urls.identity;
            this.iconsUrl = urls.icons;
            this.notificationsUrl = urls.notifications;
            this.eventsUrl = envUrls.events = urls.events;
            this.apiService.setUrls(envUrls);
        });
    }
    setUrls(urls) {
        return environment_service_awaiter(this, void 0, void 0, function* () {
            urls.base = this.formatUrl(urls.base);
            urls.webVault = this.formatUrl(urls.webVault);
            urls.api = this.formatUrl(urls.api);
            urls.identity = this.formatUrl(urls.identity);
            urls.icons = this.formatUrl(urls.icons);
            urls.notifications = this.formatUrl(urls.notifications);
            urls.events = this.formatUrl(urls.events);
            yield this.storageService.save(ConstantsService.environmentUrlsKey, {
                base: urls.base,
                api: urls.api,
                identity: urls.identity,
                webVault: urls.webVault,
                icons: urls.icons,
                notifications: urls.notifications,
                events: urls.events,
            });
            this.baseUrl = urls.base;
            this.webVaultUrl = urls.webVault;
            this.apiUrl = urls.api;
            this.identityUrl = urls.identity;
            this.iconsUrl = urls.icons;
            this.notificationsUrl = urls.notifications;
            this.eventsUrl = urls.events;
            const envUrls = new EnvironmentUrls();
            if (this.baseUrl) {
                envUrls.base = this.baseUrl;
            }
            else {
                envUrls.api = this.apiUrl;
                envUrls.identity = this.identityUrl;
                envUrls.events = this.eventsUrl;
            }
            this.apiService.setUrls(envUrls);
            if (this.notificationsService != null) {
                this.notificationsService.init(this);
            }
            return urls;
        });
    }
    formatUrl(url) {
        if (url == null || url === '') {
            return null;
        }
        url = url.replace(/\/+$/g, '');
        if (!url.startsWith('http://') && !url.startsWith('https://')) {
            url = 'https://' + url;
        }
        return url.trim();
    }
}

// EXTERNAL MODULE: external "papaparse"
var external_papaparse_ = __webpack_require__(8);

// CONCATENATED MODULE: ./jslib/src/models/export/card.ts

class export_card_Card {
    static template() {
        const req = new export_card_Card();
        req.cardholderName = 'John Doe';
        req.brand = 'visa';
        req.number = '4242424242424242';
        req.expMonth = '04';
        req.expYear = '2023';
        req.code = '123';
        return req;
    }
    static toView(req, view = new CardView()) {
        view.cardholderName = req.cardholderName;
        view.brand = req.brand;
        view.number = req.number;
        view.expMonth = req.expMonth;
        view.expYear = req.expYear;
        view.code = req.code;
        return view;
    }
    constructor(o) {
        if (o == null) {
            return;
        }
        this.cardholderName = o.cardholderName;
        this.brand = o.brand;
        this.number = o.number;
        this.expMonth = o.expMonth;
        this.expYear = o.expYear;
        this.code = o.code;
    }
}

// CONCATENATED MODULE: ./jslib/src/models/export/field.ts


class export_field_Field {
    static template() {
        const req = new export_field_Field();
        req.name = 'Field name';
        req.value = 'Some value';
        req.type = FieldType.Text;
        return req;
    }
    static toView(req, view = new FieldView()) {
        view.type = req.type;
        view.value = req.value;
        view.name = req.name;
        return view;
    }
    constructor(o) {
        if (o == null) {
            return;
        }
        this.name = o.name;
        this.value = o.value;
        this.type = o.type;
    }
}

// CONCATENATED MODULE: ./jslib/src/models/export/identity.ts

class export_identity_Identity {
    static template() {
        const req = new export_identity_Identity();
        req.title = 'Mr';
        req.firstName = 'John';
        req.middleName = 'William';
        req.lastName = 'Doe';
        req.address1 = '123 Any St';
        req.address2 = 'Apt #123';
        req.address3 = null;
        req.city = 'New York';
        req.state = 'NY';
        req.postalCode = '10001';
        req.country = 'US';
        req.company = 'Acme Inc.';
        req.email = 'john@company.com';
        req.phone = '5555551234';
        req.ssn = '000-123-4567';
        req.username = 'jdoe';
        req.passportNumber = 'US-123456789';
        req.licenseNumber = 'D123-12-123-12333';
        return req;
    }
    static toView(req, view = new identityView_IdentityView()) {
        view.title = req.title;
        view.firstName = req.firstName;
        view.middleName = req.middleName;
        view.lastName = req.lastName;
        view.address1 = req.address1;
        view.address2 = req.address2;
        view.address3 = req.address3;
        view.city = req.city;
        view.state = req.state;
        view.postalCode = req.postalCode;
        view.country = req.country;
        view.company = req.company;
        view.email = req.email;
        view.phone = req.phone;
        view.ssn = req.ssn;
        view.username = req.username;
        view.passportNumber = req.passportNumber;
        view.licenseNumber = req.licenseNumber;
        return view;
    }
    constructor(o) {
        if (o == null) {
            return;
        }
        this.title = o.title;
        this.firstName = o.firstName;
        this.middleName = o.middleName;
        this.lastName = o.lastName;
        this.address1 = o.address1;
        this.address2 = o.address2;
        this.address3 = o.address3;
        this.city = o.city;
        this.state = o.state;
        this.postalCode = o.postalCode;
        this.country = o.country;
        this.company = o.company;
        this.email = o.email;
        this.phone = o.phone;
        this.ssn = o.ssn;
        this.username = o.username;
        this.passportNumber = o.passportNumber;
        this.licenseNumber = o.licenseNumber;
    }
}

// CONCATENATED MODULE: ./jslib/src/models/export/loginUri.ts

class export_loginUri_LoginUri {
    constructor(o) {
        this.match = null;
        if (o == null) {
            return;
        }
        this.uri = o.uri;
        this.match = o.match;
    }
    static template() {
        const req = new export_loginUri_LoginUri();
        req.uri = 'https://google.com';
        req.match = null;
        return req;
    }
    static toView(req, view = new loginUriView_LoginUriView()) {
        view.uri = req.uri;
        view.match = req.match;
        return view;
    }
}

// CONCATENATED MODULE: ./jslib/src/models/export/login.ts


class export_login_Login {
    static template() {
        const req = new export_login_Login();
        req.uris = [];
        req.username = 'jdoe';
        req.password = 'myp@ssword123';
        req.totp = 'JBSWY3DPEHPK3PXP';
        return req;
    }
    static toView(req, view = new LoginView()) {
        if (req.uris != null) {
            view.uris = req.uris.map((u) => export_loginUri_LoginUri.toView(u));
        }
        view.username = req.username;
        view.password = req.password;
        view.totp = req.totp;
        return view;
    }
    constructor(o) {
        if (o == null) {
            return;
        }
        if (o.uris != null) {
            this.uris = o.uris.map((u) => new export_loginUri_LoginUri(u));
        }
        this.username = o.username;
        this.password = o.password;
        this.totp = o.totp;
    }
}

// CONCATENATED MODULE: ./jslib/src/enums/secureNoteType.ts
var SecureNoteType;
(function (SecureNoteType) {
    SecureNoteType[SecureNoteType["Generic"] = 0] = "Generic";
})(SecureNoteType || (SecureNoteType = {}));

// CONCATENATED MODULE: ./jslib/src/models/export/secureNote.ts


class export_secureNote_SecureNote {
    static template() {
        const req = new export_secureNote_SecureNote();
        req.type = SecureNoteType.Generic;
        return req;
    }
    static toView(req, view = new SecureNoteView()) {
        view.type = req.type;
        return view;
    }
    constructor(o) {
        if (o == null) {
            return;
        }
        this.type = o.type;
    }
}

// CONCATENATED MODULE: ./jslib/src/models/export/cipher.ts







class export_cipher_Cipher {
    static template() {
        const req = new export_cipher_Cipher();
        req.organizationId = null;
        req.folderId = null;
        req.type = CipherType.Login;
        req.name = 'Item name';
        req.notes = 'Some notes about this item.';
        req.favorite = false;
        req.fields = [];
        req.login = null;
        req.secureNote = null;
        req.card = null;
        req.identity = null;
        return req;
    }
    static toView(req, view = new cipherView_CipherView()) {
        view.type = req.type;
        view.folderId = req.folderId;
        if (view.organizationId == null) {
            view.organizationId = req.organizationId;
        }
        view.name = req.name;
        view.notes = req.notes;
        view.favorite = req.favorite;
        if (req.fields != null) {
            view.fields = req.fields.map((f) => export_field_Field.toView(f));
        }
        switch (req.type) {
            case CipherType.Login:
                view.login = export_login_Login.toView(req.login);
                break;
            case CipherType.SecureNote:
                view.secureNote = export_secureNote_SecureNote.toView(req.secureNote);
                break;
            case CipherType.Card:
                view.card = export_card_Card.toView(req.card);
                break;
            case CipherType.Identity:
                view.identity = export_identity_Identity.toView(req.identity);
                break;
        }
        return view;
    }
    // Use build method instead of ctor so that we can control order of JSON stringify for pretty print
    build(o) {
        this.organizationId = o.organizationId;
        this.folderId = o.folderId;
        this.type = o.type;
        this.name = o.name;
        this.notes = o.notes;
        this.favorite = o.favorite;
        if (o.fields != null) {
            this.fields = o.fields.map((f) => new export_field_Field(f));
        }
        switch (o.type) {
            case CipherType.Login:
                this.login = new export_login_Login(o.login);
                break;
            case CipherType.SecureNote:
                this.secureNote = new export_secureNote_SecureNote(o.secureNote);
                break;
            case CipherType.Card:
                this.card = new export_card_Card(o.card);
                break;
            case CipherType.Identity:
                this.identity = new export_identity_Identity(o.identity);
                break;
        }
    }
}

// CONCATENATED MODULE: ./jslib/src/models/export/cipherWithIds.ts

class cipherWithIds_CipherWithIds extends export_cipher_Cipher {
    // Use build method instead of ctor so that we can control order of JSON stringify for pretty print
    build(o) {
        this.id = o.id;
        super.build(o);
        this.collectionIds = o.collectionIds;
    }
}

// CONCATENATED MODULE: ./jslib/src/models/export/collection.ts

class export_collection_Collection {
    static template() {
        const req = new export_collection_Collection();
        req.organizationId = '00000000-0000-0000-0000-000000000000';
        req.name = 'Collection name';
        req.externalId = null;
        return req;
    }
    static toView(req, view = new collectionView_CollectionView()) {
        view.name = req.name;
        view.externalId = req.externalId;
        if (view.organizationId == null) {
            view.organizationId = req.organizationId;
        }
        return view;
    }
    // Use build method instead of ctor so that we can control order of JSON stringify for pretty print
    build(o) {
        this.organizationId = o.organizationId;
        this.name = o.name;
        this.externalId = o.externalId;
    }
}

// CONCATENATED MODULE: ./jslib/src/models/export/collectionWithId.ts

class collectionWithId_CollectionWithId extends export_collection_Collection {
    // Use build method instead of ctor so that we can control order of JSON stringify for pretty print
    build(o) {
        this.id = o.id;
        super.build(o);
    }
}

// CONCATENATED MODULE: ./jslib/src/models/export/folder.ts

class export_folder_Folder {
    static template() {
        const req = new export_folder_Folder();
        req.name = 'Folder name';
        return req;
    }
    static toView(req, view = new FolderView()) {
        view.name = req.name;
        return view;
    }
    // Use build method instead of ctor so that we can control order of JSON stringify for pretty print
    build(o) {
        this.name = o.name;
    }
}

// CONCATENATED MODULE: ./jslib/src/models/export/folderWithId.ts

class folderWithId_FolderWithId extends export_folder_Folder {
    // Use build method instead of ctor so that we can control order of JSON stringify for pretty print
    build(o) {
        this.id = o.id;
        super.build(o);
    }
}

// CONCATENATED MODULE: ./jslib/src/services/export.service.ts
var export_service_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};









class export_service_ExportService {
    constructor(folderService, cipherService, apiService) {
        this.folderService = folderService;
        this.cipherService = cipherService;
        this.apiService = apiService;
    }
    getExport(format = 'csv') {
        return export_service_awaiter(this, void 0, void 0, function* () {
            let decFolders = [];
            let decCiphers = [];
            const promises = [];
            promises.push(this.folderService.getAllDecrypted().then((folders) => {
                decFolders = folders;
            }));
            promises.push(this.cipherService.getAllDecrypted().then((ciphers) => {
                decCiphers = ciphers;
            }));
            yield Promise.all(promises);
            if (format === 'csv') {
                const foldersMap = new Map();
                decFolders.forEach((f) => {
                    if (f.id != null) {
                        foldersMap.set(f.id, f);
                    }
                });
                const exportCiphers = [];
                decCiphers.forEach((c) => {
                    // only export logins and secure notes
                    if (c.type !== CipherType.Login && c.type !== CipherType.SecureNote) {
                        return;
                    }
                    if (c.organizationId != null) {
                        return;
                    }
                    const cipher = {};
                    cipher.folder = c.folderId != null && foldersMap.has(c.folderId) ?
                        foldersMap.get(c.folderId).name : null;
                    cipher.favorite = c.favorite ? 1 : null;
                    this.buildCommonCipher(cipher, c);
                    exportCiphers.push(cipher);
                });
                return external_papaparse_["unparse"](exportCiphers);
            }
            else {
                const jsonDoc = {
                    folders: [],
                    items: [],
                };
                decFolders.forEach((f) => {
                    if (f.id == null) {
                        return;
                    }
                    const folder = new folderWithId_FolderWithId();
                    folder.build(f);
                    jsonDoc.folders.push(folder);
                });
                decCiphers.forEach((c) => {
                    if (c.organizationId != null) {
                        return;
                    }
                    const cipher = new cipherWithIds_CipherWithIds();
                    cipher.build(c);
                    cipher.collectionIds = null;
                    jsonDoc.items.push(cipher);
                });
                return JSON.stringify(jsonDoc, null, '  ');
            }
        });
    }
    getOrganizationExport(organizationId, format = 'csv') {
        return export_service_awaiter(this, void 0, void 0, function* () {
            const decCollections = [];
            const decCiphers = [];
            const promises = [];
            promises.push(this.apiService.getCollections(organizationId).then((collections) => {
                const collectionPromises = [];
                if (collections != null && collections.data != null && collections.data.length > 0) {
                    collections.data.forEach((c) => {
                        const collection = new collection_Collection(new CollectionData(c));
                        collectionPromises.push(collection.decrypt().then((decCol) => {
                            decCollections.push(decCol);
                        }));
                    });
                }
                return Promise.all(collectionPromises);
            }));
            promises.push(this.apiService.getCiphersOrganization(organizationId).then((ciphers) => {
                const cipherPromises = [];
                if (ciphers != null && ciphers.data != null && ciphers.data.length > 0) {
                    ciphers.data.forEach((c) => {
                        const cipher = new cipher_Cipher(new cipherData_CipherData(c));
                        cipherPromises.push(cipher.decrypt().then((decCipher) => {
                            decCiphers.push(decCipher);
                        }));
                    });
                }
                return Promise.all(cipherPromises);
            }));
            yield Promise.all(promises);
            if (format === 'csv') {
                const collectionsMap = new Map();
                decCollections.forEach((c) => {
                    collectionsMap.set(c.id, c);
                });
                const exportCiphers = [];
                decCiphers.forEach((c) => {
                    // only export logins and secure notes
                    if (c.type !== CipherType.Login && c.type !== CipherType.SecureNote) {
                        return;
                    }
                    const cipher = {};
                    cipher.collections = [];
                    if (c.collectionIds != null) {
                        cipher.collections = c.collectionIds.filter((id) => collectionsMap.has(id))
                            .map((id) => collectionsMap.get(id).name);
                    }
                    this.buildCommonCipher(cipher, c);
                    exportCiphers.push(cipher);
                });
                return external_papaparse_["unparse"](exportCiphers);
            }
            else {
                const jsonDoc = {
                    collections: [],
                    items: [],
                };
                decCollections.forEach((c) => {
                    const collection = new collectionWithId_CollectionWithId();
                    collection.build(c);
                    jsonDoc.collections.push(collection);
                });
                decCiphers.forEach((c) => {
                    const cipher = new cipherWithIds_CipherWithIds();
                    cipher.build(c);
                    jsonDoc.items.push(cipher);
                });
                return JSON.stringify(jsonDoc, null, '  ');
            }
        });
    }
    getFileName(prefix = null, extension = 'csv') {
        const now = new Date();
        const dateString = now.getFullYear() + '' + this.padNumber(now.getMonth() + 1, 2) + '' + this.padNumber(now.getDate(), 2) +
            this.padNumber(now.getHours(), 2) + '' + this.padNumber(now.getMinutes(), 2) +
            this.padNumber(now.getSeconds(), 2);
        return 'bitwarden' + (prefix ? ('_' + prefix) : '') + '_export_' + dateString + '.' + extension;
    }
    padNumber(num, width, padCharacter = '0') {
        const numString = num.toString();
        return numString.length >= width ? numString :
            new Array(width - numString.length + 1).join(padCharacter) + numString;
    }
    buildCommonCipher(cipher, c) {
        cipher.type = null;
        cipher.name = c.name;
        cipher.notes = c.notes;
        cipher.fields = null;
        // Login props
        cipher.login_uri = null;
        cipher.login_username = null;
        cipher.login_password = null;
        cipher.login_totp = null;
        if (c.fields) {
            c.fields.forEach((f) => {
                if (!cipher.fields) {
                    cipher.fields = '';
                }
                else {
                    cipher.fields += '\n';
                }
                cipher.fields += ((f.name || '') + ': ' + f.value);
            });
        }
        switch (c.type) {
            case CipherType.Login:
                cipher.type = 'login';
                cipher.login_username = c.login.username;
                cipher.login_password = c.login.password;
                cipher.login_totp = c.login.totp;
                if (c.login.uris) {
                    cipher.login_uri = [];
                    c.login.uris.forEach((u) => {
                        cipher.login_uri.push(u.uri);
                    });
                }
                break;
            case CipherType.SecureNote:
                cipher.type = 'note';
                break;
            default:
                return;
        }
        return cipher;
    }
}

// CONCATENATED MODULE: ./jslib/src/models/data/folderData.ts
class FolderData {
    constructor(response, userId) {
        this.userId = userId;
        this.name = response.name;
        this.id = response.id;
        this.revisionDate = response.revisionDate;
    }
}

// CONCATENATED MODULE: ./jslib/src/models/request/folderRequest.ts
class FolderRequest {
    constructor(folder) {
        this.name = folder.name ? folder.name.encryptedString : null;
    }
}

// CONCATENATED MODULE: ./jslib/src/services/folder.service.ts
var folder_service_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};






const folder_service_Keys = {
    foldersPrefix: 'folders_',
    ciphersPrefix: 'ciphers_',
};
const folder_service_NestingDelimiter = '/';
class folder_service_FolderService {
    constructor(cryptoService, userService, apiService, storageService, i18nService, cipherService) {
        this.cryptoService = cryptoService;
        this.userService = userService;
        this.apiService = apiService;
        this.storageService = storageService;
        this.i18nService = i18nService;
        this.cipherService = cipherService;
    }
    clearCache() {
        this.decryptedFolderCache = null;
    }
    encrypt(model, key) {
        return folder_service_awaiter(this, void 0, void 0, function* () {
            const folder = new folder_Folder();
            folder.id = model.id;
            folder.name = yield this.cryptoService.encrypt(model.name, key);
            return folder;
        });
    }
    get(id) {
        return folder_service_awaiter(this, void 0, void 0, function* () {
            const userId = yield this.userService.getUserId();
            const folders = yield this.storageService.get(folder_service_Keys.foldersPrefix + userId);
            if (folders == null || !folders.hasOwnProperty(id)) {
                return null;
            }
            return new folder_Folder(folders[id]);
        });
    }
    getAll() {
        return folder_service_awaiter(this, void 0, void 0, function* () {
            const userId = yield this.userService.getUserId();
            const folders = yield this.storageService.get(folder_service_Keys.foldersPrefix + userId);
            const response = [];
            for (const id in folders) {
                if (folders.hasOwnProperty(id)) {
                    response.push(new folder_Folder(folders[id]));
                }
            }
            return response;
        });
    }
    getAllDecrypted() {
        return folder_service_awaiter(this, void 0, void 0, function* () {
            if (this.decryptedFolderCache != null) {
                return this.decryptedFolderCache;
            }
            const hasKey = yield this.cryptoService.hasKey();
            if (!hasKey) {
                throw new Error('No key.');
            }
            const decFolders = [];
            const promises = [];
            const folders = yield this.getAll();
            folders.forEach((folder) => {
                promises.push(folder.decrypt().then((f) => decFolders.push(f)));
            });
            yield Promise.all(promises);
            decFolders.sort(utils_Utils.getSortFunction(this.i18nService, 'name'));
            const noneFolder = new FolderView();
            noneFolder.name = this.i18nService.t('noneFolder');
            decFolders.push(noneFolder);
            this.decryptedFolderCache = decFolders;
            return this.decryptedFolderCache;
        });
    }
    getAllNested() {
        return folder_service_awaiter(this, void 0, void 0, function* () {
            const folders = yield this.getAllDecrypted();
            const nodes = [];
            folders.forEach((f) => {
                const folderCopy = new FolderView();
                folderCopy.id = f.id;
                folderCopy.revisionDate = f.revisionDate;
                const parts = f.name != null ? f.name.replace(/^\/+|\/+$/g, '').split(folder_service_NestingDelimiter) : [];
                serviceUtils_ServiceUtils.nestedTraverse(nodes, 0, parts, folderCopy, null, folder_service_NestingDelimiter);
            });
            return nodes;
        });
    }
    getNested(id) {
        return folder_service_awaiter(this, void 0, void 0, function* () {
            const folders = yield this.getAllNested();
            return serviceUtils_ServiceUtils.getTreeNodeObject(folders, id);
        });
    }
    saveWithServer(folder) {
        return folder_service_awaiter(this, void 0, void 0, function* () {
            const request = new FolderRequest(folder);
            let response;
            if (folder.id == null) {
                response = yield this.apiService.postFolder(request);
                folder.id = response.id;
            }
            else {
                response = yield this.apiService.putFolder(folder.id, request);
            }
            const userId = yield this.userService.getUserId();
            const data = new FolderData(response, userId);
            yield this.upsert(data);
        });
    }
    upsert(folder) {
        return folder_service_awaiter(this, void 0, void 0, function* () {
            const userId = yield this.userService.getUserId();
            let folders = yield this.storageService.get(folder_service_Keys.foldersPrefix + userId);
            if (folders == null) {
                folders = {};
            }
            if (folder instanceof FolderData) {
                const f = folder;
                folders[f.id] = f;
            }
            else {
                folder.forEach((f) => {
                    folders[f.id] = f;
                });
            }
            yield this.storageService.save(folder_service_Keys.foldersPrefix + userId, folders);
            this.decryptedFolderCache = null;
        });
    }
    replace(folders) {
        return folder_service_awaiter(this, void 0, void 0, function* () {
            const userId = yield this.userService.getUserId();
            yield this.storageService.save(folder_service_Keys.foldersPrefix + userId, folders);
            this.decryptedFolderCache = null;
        });
    }
    clear(userId) {
        return folder_service_awaiter(this, void 0, void 0, function* () {
            yield this.storageService.remove(folder_service_Keys.foldersPrefix + userId);
            this.decryptedFolderCache = null;
        });
    }
    delete(id) {
        return folder_service_awaiter(this, void 0, void 0, function* () {
            const userId = yield this.userService.getUserId();
            const folders = yield this.storageService.get(folder_service_Keys.foldersPrefix + userId);
            if (folders == null) {
                return;
            }
            if (typeof id === 'string') {
                if (folders[id] == null) {
                    return;
                }
                delete folders[id];
            }
            else {
                id.forEach((i) => {
                    delete folders[i];
                });
            }
            yield this.storageService.save(folder_service_Keys.foldersPrefix + userId, folders);
            this.decryptedFolderCache = null;
            // Items in a deleted folder are re-assigned to "No Folder"
            const ciphers = yield this.storageService.get(folder_service_Keys.ciphersPrefix + userId);
            if (ciphers != null) {
                const updates = [];
                for (const cId in ciphers) {
                    if (ciphers[cId].folderId === id) {
                        ciphers[cId].folderId = null;
                        updates.push(ciphers[cId]);
                    }
                }
                if (updates.length > 0) {
                    this.cipherService.upsert(updates);
                }
            }
        });
    }
    deleteWithServer(id) {
        return folder_service_awaiter(this, void 0, void 0, function* () {
            yield this.apiService.deleteFolder(id);
            yield this.delete(id);
        });
    }
}

// CONCATENATED MODULE: ./jslib/src/models/request/collectionRequest.ts
class CollectionRequest {
    constructor(collection) {
        this.groups = [];
        if (collection == null) {
            return;
        }
        this.name = collection.name ? collection.name.encryptedString : null;
        this.externalId = collection.externalId;
    }
}

// CONCATENATED MODULE: ./jslib/src/models/request/importCiphersRequest.ts
class ImportCiphersRequest {
    constructor() {
        this.ciphers = [];
        this.folders = [];
        this.folderRelationships = [];
    }
}

// CONCATENATED MODULE: ./jslib/src/models/request/importOrganizationCiphersRequest.ts
class ImportOrganizationCiphersRequest {
    constructor() {
        this.ciphers = [];
        this.collections = [];
        this.collectionRelationships = [];
    }
}

// CONCATENATED MODULE: ./jslib/src/models/request/kvpRequest.ts
class KvpRequest {
    constructor(key, value) {
        this.key = key;
        this.value = value;
    }
}

// CONCATENATED MODULE: ./jslib/src/importers/baseImporter.ts












class baseImporter_BaseImporter {
    constructor() {
        this.organization = false;
        this.newLineRegex = /(?:\r\n|\r|\n)/;
        this.passwordFieldNames = [
            'password', 'pass word', 'passphrase', 'pass phrase',
            'pass', 'code', 'code word', 'codeword',
            'secret', 'secret word', 'personpwd',
            'key', 'keyword', 'key word', 'keyphrase', 'key phrase',
            'form_pw', 'wppassword', 'pin', 'pwd', 'pw', 'pword', 'passwd',
            'p', 'serial', 'serial#', 'license key', 'reg #',
            // Non-English names
            'passwort',
        ];
        this.usernameFieldNames = [
            'user', 'name', 'user name', 'username', 'login name',
            'email', 'e-mail', 'id', 'userid', 'user id',
            'login', 'form_loginname', 'wpname', 'mail',
            'loginid', 'login id', 'log', 'personlogin',
            'first name', 'last name', 'card#', 'account #',
            'member', 'member #',
            // Non-English names
            'nom', 'benutzername',
        ];
        this.notesFieldNames = [
            'note', 'notes', 'comment', 'comments', 'memo',
            'description', 'free form', 'freeform',
            'free text', 'freetext', 'free',
            // Non-English names
            'kommentar',
        ];
        this.uriFieldNames = [
            'url', 'hyper link', 'hyperlink', 'link',
            'host', 'hostname', 'host name', 'server', 'address',
            'hyper ref', 'href', 'web', 'website', 'web site', 'site',
            'web-site', 'uri',
            // Non-English names
            'ort', 'adresse',
        ];
    }
    parseXml(data) {
        const parser = new DOMParser();
        const doc = parser.parseFromString(data, 'application/xml');
        return doc != null && doc.querySelector('parsererror') == null ? doc : null;
    }
    parseCsv(data, header) {
        data = this.splitNewLine(data).join('\n').trim();
        const result = external_papaparse_["parse"](data, {
            header: header,
            encoding: 'UTF-8',
            skipEmptyLines: false,
        });
        if (result.errors != null && result.errors.length > 0) {
            result.errors.forEach((e) => {
                if (e.row != null) {
                    // tslint:disable-next-line
                    console.warn('Error parsing row ' + e.row + ': ' + e.message);
                }
            });
        }
        return result.data && result.data.length > 0 ? result.data : null;
    }
    parseSingleRowCsv(rowData) {
        if (this.isNullOrWhitespace(rowData)) {
            return null;
        }
        const parsedRow = this.parseCsv(rowData, false);
        if (parsedRow != null && parsedRow.length > 0 && parsedRow[0].length > 0) {
            return parsedRow[0];
        }
        return null;
    }
    makeUriArray(uri) {
        if (uri == null) {
            return null;
        }
        if (typeof uri === 'string') {
            const loginUri = new loginUriView_LoginUriView();
            loginUri.uri = this.fixUri(uri);
            if (this.isNullOrWhitespace(loginUri.uri)) {
                return null;
            }
            loginUri.match = null;
            return [loginUri];
        }
        if (uri.length > 0) {
            const returnArr = [];
            uri.forEach((u) => {
                const loginUri = new loginUriView_LoginUriView();
                loginUri.uri = this.fixUri(u);
                if (this.isNullOrWhitespace(loginUri.uri)) {
                    return;
                }
                loginUri.match = null;
                returnArr.push(loginUri);
            });
            return returnArr.length === 0 ? null : returnArr;
        }
        return null;
    }
    fixUri(uri) {
        if (uri == null) {
            return null;
        }
        uri = uri.trim();
        if (uri.indexOf('://') === -1 && uri.indexOf('.') >= 0) {
            uri = 'http://' + uri;
        }
        if (uri.length > 1000) {
            return uri.substring(0, 1000);
        }
        return uri;
    }
    nameFromUrl(url) {
        const hostname = utils_Utils.getHostname(url);
        if (this.isNullOrWhitespace(hostname)) {
            return null;
        }
        return hostname.startsWith('www.') ? hostname.replace('www.', '') : hostname;
    }
    isNullOrWhitespace(str) {
        return utils_Utils.isNullOrWhitespace(str);
    }
    getValueOrDefault(str, defaultValue = null) {
        if (this.isNullOrWhitespace(str)) {
            return defaultValue;
        }
        return str;
    }
    splitNewLine(str) {
        return str.split(this.newLineRegex);
    }
    // ref https://stackoverflow.com/a/5911300
    getCardBrand(cardNum) {
        if (this.isNullOrWhitespace(cardNum)) {
            return null;
        }
        // Visa
        let re = new RegExp('^4');
        if (cardNum.match(re) != null) {
            return 'Visa';
        }
        // Mastercard
        // Updated for Mastercard 2017 BINs expansion
        if (/^(5[1-5][0-9]{14}|2(22[1-9][0-9]{12}|2[3-9][0-9]{13}|[3-6][0-9]{14}|7[0-1][0-9]{13}|720[0-9]{12}))$/
            .test(cardNum)) {
            return 'Mastercard';
        }
        // AMEX
        re = new RegExp('^3[47]');
        if (cardNum.match(re) != null) {
            return 'Amex';
        }
        // Discover
        re = new RegExp('^(6011|622(12[6-9]|1[3-9][0-9]|[2-8][0-9]{2}|9[0-1][0-9]|92[0-5]|64[4-9])|65)');
        if (cardNum.match(re) != null) {
            return 'Discover';
        }
        // Diners
        re = new RegExp('^36');
        if (cardNum.match(re) != null) {
            return 'Diners Club';
        }
        // Diners - Carte Blanche
        re = new RegExp('^30[0-5]');
        if (cardNum.match(re) != null) {
            return 'Diners Club';
        }
        // JCB
        re = new RegExp('^35(2[89]|[3-8][0-9])');
        if (cardNum.match(re) != null) {
            return 'JCB';
        }
        // Visa Electron
        re = new RegExp('^(4026|417500|4508|4844|491(3|7))');
        if (cardNum.match(re) != null) {
            return 'Visa';
        }
        return null;
    }
    setCardExpiration(cipher, expiration) {
        if (!this.isNullOrWhitespace(expiration)) {
            const parts = expiration.split('/');
            if (parts.length === 2) {
                let month = null;
                let year = null;
                if (parts[0].length === 1 || parts[0].length === 2) {
                    month = parts[0];
                    if (month.length === 2 && month[0] === '0') {
                        month = month.substr(1, 1);
                    }
                }
                if (parts[1].length === 2 || parts[1].length === 4) {
                    year = month.length === 2 ? '20' + parts[1] : parts[1];
                }
                if (month != null && year != null) {
                    cipher.card.expMonth = month;
                    cipher.card.expYear = year;
                    return true;
                }
            }
        }
        return false;
    }
    moveFoldersToCollections(result) {
        result.folderRelationships.forEach((r) => result.collectionRelationships.push(r));
        result.collections = result.folders.map((f) => {
            const collection = new collectionView_CollectionView();
            collection.name = f.name;
            return collection;
        });
        result.folderRelationships = [];
        result.folders = [];
    }
    querySelectorDirectChild(parentEl, query) {
        const els = this.querySelectorAllDirectChild(parentEl, query);
        return els.length === 0 ? null : els[0];
    }
    querySelectorAllDirectChild(parentEl, query) {
        return Array.from(parentEl.querySelectorAll(query)).filter((el) => el.parentNode === parentEl);
    }
    initLoginCipher() {
        const cipher = new cipherView_CipherView();
        cipher.favorite = false;
        cipher.notes = '';
        cipher.fields = [];
        cipher.login = new LoginView();
        cipher.type = CipherType.Login;
        return cipher;
    }
    cleanupCipher(cipher) {
        if (cipher == null) {
            return;
        }
        if (cipher.type !== CipherType.Login) {
            cipher.login = null;
        }
        if (this.isNullOrWhitespace(cipher.name)) {
            cipher.name = '--';
        }
        if (this.isNullOrWhitespace(cipher.notes)) {
            cipher.notes = null;
        }
        else {
            cipher.notes = cipher.notes.trim();
        }
        if (cipher.fields != null && cipher.fields.length === 0) {
            cipher.fields = null;
        }
    }
    processKvp(cipher, key, value, type = FieldType.Text) {
        if (this.isNullOrWhitespace(value)) {
            return;
        }
        if (this.isNullOrWhitespace(key)) {
            key = '';
        }
        if (value.length > 200 || value.trim().search(this.newLineRegex) > -1) {
            if (cipher.notes == null) {
                cipher.notes = '';
            }
            cipher.notes += (key + ': ' + this.splitNewLine(value).join('\n') + '\n');
        }
        else {
            if (cipher.fields == null) {
                cipher.fields = [];
            }
            const field = new FieldView();
            field.type = type;
            field.name = key;
            field.value = value;
            cipher.fields.push(field);
        }
    }
    processFolder(result, folderName) {
        let folderIndex = result.folders.length;
        const hasFolder = !this.isNullOrWhitespace(folderName);
        let addFolder = hasFolder;
        if (hasFolder) {
            for (let i = 0; i < result.folders.length; i++) {
                if (result.folders[i].name === folderName) {
                    addFolder = false;
                    folderIndex = i;
                    break;
                }
            }
        }
        if (addFolder) {
            const f = new FolderView();
            f.name = folderName;
            result.folders.push(f);
        }
        if (hasFolder) {
            result.folderRelationships.push([result.ciphers.length, folderIndex]);
        }
    }
    convertToNoteIfNeeded(cipher) {
        if (cipher.type === CipherType.Login && this.isNullOrWhitespace(cipher.login.username) &&
            this.isNullOrWhitespace(cipher.login.password) &&
            (cipher.login.uris == null || cipher.login.uris.length === 0)) {
            cipher.type = CipherType.SecureNote;
            cipher.secureNote = new SecureNoteView();
            cipher.secureNote.type = SecureNoteType.Generic;
        }
    }
}

// CONCATENATED MODULE: ./jslib/src/models/domain/importResult.ts
class ImportResult {
    constructor() {
        this.success = false;
        this.ciphers = [];
        this.folders = [];
        this.folderRelationships = [];
        this.collections = [];
        this.collectionRelationships = [];
    }
}

// CONCATENATED MODULE: ./jslib/src/importers/ascendoCsvImporter.ts


class ascendoCsvImporter_AscendoCsvImporter extends baseImporter_BaseImporter {
    parse(data) {
        const result = new ImportResult();
        const results = this.parseCsv(data, false);
        if (results == null) {
            result.success = false;
            return result;
        }
        results.forEach((value) => {
            if (value.length < 2) {
                return;
            }
            const cipher = this.initLoginCipher();
            cipher.notes = this.getValueOrDefault(value[value.length - 1]);
            cipher.name = this.getValueOrDefault(value[0], '--');
            if (value.length > 2 && (value.length % 2) === 0) {
                for (let i = 0; i < value.length - 2; i += 2) {
                    const val = value[i + 2];
                    const field = value[i + 1];
                    if (this.isNullOrWhitespace(val) || this.isNullOrWhitespace(field)) {
                        continue;
                    }
                    const fieldLower = field.toLowerCase();
                    if (cipher.login.password == null && this.passwordFieldNames.indexOf(fieldLower) > -1) {
                        cipher.login.password = this.getValueOrDefault(val);
                    }
                    else if (cipher.login.username == null &&
                        this.usernameFieldNames.indexOf(fieldLower) > -1) {
                        cipher.login.username = this.getValueOrDefault(val);
                    }
                    else if ((cipher.login.uris == null || cipher.login.uris.length === 0) &&
                        this.uriFieldNames.indexOf(fieldLower) > -1) {
                        cipher.login.uris = this.makeUriArray(val);
                    }
                    else {
                        this.processKvp(cipher, field, val);
                    }
                }
            }
            this.convertToNoteIfNeeded(cipher);
            this.cleanupCipher(cipher);
            result.ciphers.push(cipher);
        });
        result.success = true;
        return result;
    }
}

// CONCATENATED MODULE: ./jslib/src/importers/avastCsvImporter.ts


class avastCsvImporter_AvastCsvImporter extends baseImporter_BaseImporter {
    parse(data) {
        const result = new ImportResult();
        const results = this.parseCsv(data, true);
        if (results == null) {
            result.success = false;
            return result;
        }
        results.forEach((value) => {
            const cipher = this.initLoginCipher();
            cipher.name = this.getValueOrDefault(value.name);
            cipher.login.uris = this.makeUriArray(value.web);
            cipher.login.password = this.getValueOrDefault(value.password);
            cipher.login.username = this.getValueOrDefault(value.login);
            this.cleanupCipher(cipher);
            result.ciphers.push(cipher);
        });
        result.success = true;
        return result;
    }
}

// CONCATENATED MODULE: ./jslib/src/importers/avastJsonImporter.ts




class avastJsonImporter_AvastJsonImporter extends baseImporter_BaseImporter {
    parse(data) {
        const result = new ImportResult();
        const results = JSON.parse(data);
        if (results == null) {
            result.success = false;
            return result;
        }
        if (results.logins != null) {
            results.logins.forEach((value) => {
                const cipher = this.initLoginCipher();
                cipher.name = this.getValueOrDefault(value.custName);
                cipher.notes = this.getValueOrDefault(value.note);
                cipher.login.uris = this.makeUriArray(value.url);
                cipher.login.password = this.getValueOrDefault(value.pwd);
                cipher.login.username = this.getValueOrDefault(value.loginName);
                this.cleanupCipher(cipher);
                result.ciphers.push(cipher);
            });
        }
        if (results.notes != null) {
            results.notes.forEach((value) => {
                const cipher = this.initLoginCipher();
                cipher.type = CipherType.SecureNote;
                cipher.secureNote.type = SecureNoteType.Generic;
                cipher.name = this.getValueOrDefault(value.label);
                cipher.notes = this.getValueOrDefault(value.text);
                this.cleanupCipher(cipher);
                result.ciphers.push(cipher);
            });
        }
        if (results.cards != null) {
            results.cards.forEach((value) => {
                const cipher = this.initLoginCipher();
                cipher.type = CipherType.Card;
                cipher.name = this.getValueOrDefault(value.custName);
                cipher.notes = this.getValueOrDefault(value.note);
                cipher.card.cardholderName = this.getValueOrDefault(value.holderName);
                cipher.card.number = this.getValueOrDefault(value.cardNumber);
                cipher.card.code = this.getValueOrDefault(value.cvv);
                cipher.card.brand = this.getCardBrand(cipher.card.number);
                if (value.expirationDate != null) {
                    if (value.expirationDate.month != null) {
                        cipher.card.expMonth = value.expirationDate.month + '';
                    }
                    if (value.expirationDate.year != null) {
                        cipher.card.expYear = value.expirationDate.year + '';
                    }
                }
                this.cleanupCipher(cipher);
                result.ciphers.push(cipher);
            });
        }
        result.success = true;
        return result;
    }
}

// CONCATENATED MODULE: ./jslib/src/importers/aviraCsvImporter.ts


class aviraCsvImporter_AviraCsvImporter extends baseImporter_BaseImporter {
    parse(data) {
        const result = new ImportResult();
        const results = this.parseCsv(data, true);
        if (results == null) {
            result.success = false;
            return result;
        }
        results.forEach((value) => {
            const cipher = this.initLoginCipher();
            cipher.name = this.getValueOrDefault(value.name, this.getValueOrDefault(this.nameFromUrl(value.website), '--'));
            cipher.login.uris = this.makeUriArray(value.website);
            cipher.login.password = this.getValueOrDefault(value.password);
            if (this.isNullOrWhitespace(value.username) && !this.isNullOrWhitespace(value.secondary_username)) {
                cipher.login.username = value.secondary_username;
            }
            else {
                cipher.login.username = this.getValueOrDefault(value.username);
                cipher.notes = this.getValueOrDefault(value.secondary_username);
            }
            this.cleanupCipher(cipher);
            result.ciphers.push(cipher);
        });
        result.success = true;
        return result;
    }
}

// CONCATENATED MODULE: ./jslib/src/importers/bitwardenCsvImporter.ts










class bitwardenCsvImporter_BitwardenCsvImporter extends baseImporter_BaseImporter {
    parse(data) {
        const result = new ImportResult();
        const results = this.parseCsv(data, true);
        if (results == null) {
            result.success = false;
            return result;
        }
        results.forEach((value) => {
            if (this.organization && !this.isNullOrWhitespace(value.collections)) {
                const collections = value.collections.split(',');
                collections.forEach((col) => {
                    let addCollection = true;
                    let collectionIndex = result.collections.length;
                    for (let i = 0; i < result.collections.length; i++) {
                        if (result.collections[i].name === col) {
                            addCollection = false;
                            collectionIndex = i;
                            break;
                        }
                    }
                    if (addCollection) {
                        const collection = new collectionView_CollectionView();
                        collection.name = col;
                        result.collections.push(collection);
                    }
                    result.collectionRelationships.push([result.ciphers.length, collectionIndex]);
                });
            }
            else if (!this.organization) {
                this.processFolder(result, value.folder);
            }
            const cipher = new cipherView_CipherView();
            cipher.favorite = !this.organization && this.getValueOrDefault(value.favorite, '0') !== '0' ? true : false;
            cipher.type = CipherType.Login;
            cipher.notes = this.getValueOrDefault(value.notes);
            cipher.name = this.getValueOrDefault(value.name, '--');
            if (!this.isNullOrWhitespace(value.fields)) {
                const fields = this.splitNewLine(value.fields);
                for (let i = 0; i < fields.length; i++) {
                    if (this.isNullOrWhitespace(fields[i])) {
                        continue;
                    }
                    const delimPosition = fields[i].lastIndexOf(': ');
                    if (delimPosition === -1) {
                        continue;
                    }
                    if (cipher.fields == null) {
                        cipher.fields = [];
                    }
                    const field = new FieldView();
                    field.name = fields[i].substr(0, delimPosition);
                    field.value = null;
                    field.type = FieldType.Text;
                    if (fields[i].length > (delimPosition + 2)) {
                        field.value = fields[i].substr(delimPosition + 2);
                    }
                    cipher.fields.push(field);
                }
            }
            const valueType = value.type != null ? value.type.toLowerCase() : null;
            switch (valueType) {
                case 'note':
                    cipher.type = CipherType.SecureNote;
                    cipher.secureNote = new SecureNoteView();
                    cipher.secureNote.type = SecureNoteType.Generic;
                    break;
                default:
                    cipher.type = CipherType.Login;
                    cipher.login = new LoginView();
                    cipher.login.totp = this.getValueOrDefault(value.login_totp || value.totp);
                    cipher.login.username = this.getValueOrDefault(value.login_username || value.username);
                    cipher.login.password = this.getValueOrDefault(value.login_password || value.password);
                    const uris = this.parseSingleRowCsv(value.login_uri || value.uri);
                    cipher.login.uris = this.makeUriArray(uris);
                    break;
            }
            result.ciphers.push(cipher);
        });
        result.success = true;
        return result;
    }
}

// CONCATENATED MODULE: ./jslib/src/importers/bitwardenJsonImporter.ts





class bitwardenJsonImporter_BitwardenJsonImporter extends baseImporter_BaseImporter {
    parse(data) {
        const result = new ImportResult();
        const results = JSON.parse(data);
        if (results == null || results.items == null || results.items.length === 0) {
            result.success = false;
            return result;
        }
        const groupingsMap = new Map();
        if (this.organization && results.collections != null) {
            results.collections.forEach((c) => {
                const collection = collectionWithId_CollectionWithId.toView(c);
                if (collection != null) {
                    collection.id = null;
                    collection.organizationId = null;
                    groupingsMap.set(c.id, result.collections.length);
                    result.collections.push(collection);
                }
            });
        }
        else if (!this.organization && results.folders != null) {
            results.folders.forEach((f) => {
                const folder = folderWithId_FolderWithId.toView(f);
                if (folder != null) {
                    folder.id = null;
                    groupingsMap.set(f.id, result.folders.length);
                    result.folders.push(folder);
                }
            });
        }
        results.items.forEach((c) => {
            const cipher = cipherWithIds_CipherWithIds.toView(c);
            // reset ids incase they were set for some reason
            cipher.id = null;
            cipher.folderId = null;
            cipher.organizationId = null;
            cipher.collectionIds = null;
            // make sure password history is limited
            if (cipher.passwordHistory != null && cipher.passwordHistory.length > 5) {
                cipher.passwordHistory = cipher.passwordHistory.slice(0, 5);
            }
            if (!this.organization && c.folderId != null && groupingsMap.has(c.folderId)) {
                result.folderRelationships.push([result.ciphers.length, groupingsMap.get(c.folderId)]);
            }
            else if (this.organization && c.collectionIds != null) {
                c.collectionIds.forEach((cId) => {
                    if (groupingsMap.has(cId)) {
                        result.collectionRelationships.push([result.ciphers.length, groupingsMap.get(cId)]);
                    }
                });
            }
            this.cleanupCipher(cipher);
            result.ciphers.push(cipher);
        });
        result.success = true;
        return result;
    }
}

// CONCATENATED MODULE: ./jslib/src/importers/blackBerryCsvImporter.ts


class blackBerryCsvImporter_BlackBerryCsvImporter extends baseImporter_BaseImporter {
    parse(data) {
        const result = new ImportResult();
        const results = this.parseCsv(data, true);
        if (results == null) {
            result.success = false;
            return result;
        }
        results.forEach((value) => {
            if (value.grouping === 'list') {
                return;
            }
            const cipher = this.initLoginCipher();
            cipher.favorite = value.fav === '1';
            cipher.name = this.getValueOrDefault(value.name);
            cipher.notes = this.getValueOrDefault(value.extra);
            if (value.grouping !== 'note') {
                cipher.login.uris = this.makeUriArray(value.url);
                cipher.login.password = this.getValueOrDefault(value.password);
                cipher.login.username = this.getValueOrDefault(value.username);
            }
            this.convertToNoteIfNeeded(cipher);
            this.cleanupCipher(cipher);
            result.ciphers.push(cipher);
        });
        result.success = true;
        return result;
    }
}

// CONCATENATED MODULE: ./jslib/src/importers/blurCsvImporter.ts


class blurCsvImporter_BlurCsvImporter extends baseImporter_BaseImporter {
    parse(data) {
        const result = new ImportResult();
        const results = this.parseCsv(data, true);
        if (results == null) {
            result.success = false;
            return result;
        }
        results.forEach((value) => {
            if (value.label === 'null') {
                value.label = null;
            }
            const cipher = this.initLoginCipher();
            cipher.name = this.getValueOrDefault(value.label, this.getValueOrDefault(this.nameFromUrl(value.domain), '--'));
            cipher.login.uris = this.makeUriArray(value.domain);
            cipher.login.password = this.getValueOrDefault(value.password);
            if (this.isNullOrWhitespace(value.email) && !this.isNullOrWhitespace(value.username)) {
                cipher.login.username = value.username;
            }
            else {
                cipher.login.username = this.getValueOrDefault(value.email);
                cipher.notes = this.getValueOrDefault(value.username);
            }
            this.cleanupCipher(cipher);
            result.ciphers.push(cipher);
        });
        result.success = true;
        return result;
    }
}

// CONCATENATED MODULE: ./jslib/src/importers/buttercupCsvImporter.ts


const OfficialProps = [
    '!group_id', '!group_name', 'title', 'username', 'password', 'URL', 'id',
];
class buttercupCsvImporter_ButtercupCsvImporter extends baseImporter_BaseImporter {
    parse(data) {
        const result = new ImportResult();
        const results = this.parseCsv(data, true);
        if (results == null) {
            result.success = false;
            return result;
        }
        results.forEach((value) => {
            this.processFolder(result, this.getValueOrDefault(value['!group_name']));
            const cipher = this.initLoginCipher();
            cipher.name = this.getValueOrDefault(value.title, '--');
            cipher.login.username = this.getValueOrDefault(value.username);
            cipher.login.password = this.getValueOrDefault(value.password);
            cipher.login.uris = this.makeUriArray(value.URL);
            let processingCustomFields = false;
            for (const prop in value) {
                if (value.hasOwnProperty(prop)) {
                    if (!processingCustomFields && OfficialProps.indexOf(prop) === -1) {
                        processingCustomFields = true;
                    }
                    if (processingCustomFields) {
                        this.processKvp(cipher, prop, value[prop]);
                    }
                }
            }
            this.cleanupCipher(cipher);
            result.ciphers.push(cipher);
        });
        if (this.organization) {
            this.moveFoldersToCollections(result);
        }
        result.success = true;
        return result;
    }
}

// CONCATENATED MODULE: ./jslib/src/importers/chromeCsvImporter.ts


class chromeCsvImporter_ChromeCsvImporter extends baseImporter_BaseImporter {
    parse(data) {
        const result = new ImportResult();
        const results = this.parseCsv(data, true);
        if (results == null) {
            result.success = false;
            return result;
        }
        results.forEach((value) => {
            const cipher = this.initLoginCipher();
            cipher.name = this.getValueOrDefault(value.name, '--');
            cipher.login.username = this.getValueOrDefault(value.username);
            cipher.login.password = this.getValueOrDefault(value.password);
            cipher.login.uris = this.makeUriArray(value.url);
            this.cleanupCipher(cipher);
            result.ciphers.push(cipher);
        });
        result.success = true;
        return result;
    }
}

// CONCATENATED MODULE: ./jslib/src/importers/clipperzHtmlImporter.ts


class clipperzHtmlImporter_ClipperzHtmlImporter extends baseImporter_BaseImporter {
    parse(data) {
        const result = new ImportResult();
        const doc = this.parseXml(data);
        if (doc == null) {
            result.success = false;
            return result;
        }
        const textarea = doc.querySelector('textarea');
        if (textarea == null || this.isNullOrWhitespace(textarea.textContent)) {
            result.errorMessage = 'Missing textarea.';
            result.success = false;
            return result;
        }
        const entries = JSON.parse(textarea.textContent);
        entries.forEach((entry) => {
            const cipher = this.initLoginCipher();
            if (!this.isNullOrWhitespace(entry.label)) {
                cipher.name = entry.label.split(' ')[0];
            }
            if (entry.data != null && !this.isNullOrWhitespace(entry.data.notes)) {
                cipher.notes = entry.data.notes.split('\\n').join('\n');
            }
            if (entry.currentVersion != null && entry.currentVersion.fields != null) {
                for (const property in entry.currentVersion.fields) {
                    if (!entry.currentVersion.fields.hasOwnProperty(property)) {
                        continue;
                    }
                    const field = entry.currentVersion.fields[property];
                    const actionType = field.actionType != null ? field.actionType.toLowerCase() : null;
                    switch (actionType) {
                        case 'password':
                            cipher.login.password = this.getValueOrDefault(field.value);
                            break;
                        case 'email':
                        case 'username':
                        case 'user':
                        case 'name':
                            cipher.login.username = this.getValueOrDefault(field.value);
                            break;
                        case 'url':
                            cipher.login.uris = this.makeUriArray(field.value);
                            break;
                        default:
                            const labelLower = field.label != null ? field.label.toLowerCase() : null;
                            if (cipher.login.password == null && this.passwordFieldNames.indexOf(labelLower) > -1) {
                                cipher.login.password = this.getValueOrDefault(field.value);
                            }
                            else if (cipher.login.username == null &&
                                this.usernameFieldNames.indexOf(labelLower) > -1) {
                                cipher.login.username = this.getValueOrDefault(field.value);
                            }
                            else if ((cipher.login.uris == null || cipher.login.uris.length === 0) &&
                                this.uriFieldNames.indexOf(labelLower) > -1) {
                                cipher.login.uris = this.makeUriArray(field.value);
                            }
                            else {
                                this.processKvp(cipher, field.label, field.value);
                            }
                            break;
                    }
                }
            }
            this.convertToNoteIfNeeded(cipher);
            this.cleanupCipher(cipher);
            result.ciphers.push(cipher);
        });
        result.success = true;
        return result;
    }
}

// CONCATENATED MODULE: ./jslib/src/importers/codebookCsvImporter.ts


class codebookCsvImporter_CodebookCsvImporter extends baseImporter_BaseImporter {
    parse(data) {
        const result = new ImportResult();
        const results = this.parseCsv(data, true);
        if (results == null) {
            result.success = false;
            return result;
        }
        results.forEach((value) => {
            this.processFolder(result, this.getValueOrDefault(value.Category));
            const cipher = this.initLoginCipher();
            cipher.favorite = this.getValueOrDefault(value.Favorite) === 'True';
            cipher.name = this.getValueOrDefault(value.Entry, '--');
            cipher.notes = this.getValueOrDefault(value.Note);
            cipher.login.username = this.getValueOrDefault(value.Username, value.Email);
            cipher.login.password = this.getValueOrDefault(value.Password);
            cipher.login.totp = this.getValueOrDefault(value.TOTP);
            cipher.login.uris = this.makeUriArray(value.Website);
            if (!this.isNullOrWhitespace(value.Username)) {
                this.processKvp(cipher, 'Email', value.Email);
            }
            this.processKvp(cipher, 'Phone', value.Phone);
            this.processKvp(cipher, 'PIN', value.PIN);
            this.processKvp(cipher, 'Account', value.Account);
            this.processKvp(cipher, 'Date', value.Date);
            this.convertToNoteIfNeeded(cipher);
            this.cleanupCipher(cipher);
            result.ciphers.push(cipher);
        });
        if (this.organization) {
            this.moveFoldersToCollections(result);
        }
        result.success = true;
        return result;
    }
}

// CONCATENATED MODULE: ./jslib/src/importers/dashlaneJsonImporter.ts








const HandledResults = new Set(['ADDRESS', 'AUTHENTIFIANT', 'BANKSTATEMENT', 'IDCARD', 'IDENTITY',
    'PAYMENTMEANS_CREDITCARD', 'PAYMENTMEAN_PAYPAL', 'EMAIL']);
class dashlaneJsonImporter_DashlaneJsonImporter extends baseImporter_BaseImporter {
    parse(data) {
        this.result = new ImportResult();
        const results = JSON.parse(data);
        if (results == null || results.length === 0) {
            this.result.success = false;
            return this.result;
        }
        if (results.ADDRESS != null) {
            this.processAddress(results.ADDRESS);
        }
        if (results.AUTHENTIFIANT != null) {
            this.processAuth(results.AUTHENTIFIANT);
        }
        if (results.BANKSTATEMENT != null) {
            this.processNote(results.BANKSTATEMENT, 'BankAccountName');
        }
        if (results.IDCARD != null) {
            this.processNote(results.IDCARD, 'Fullname');
        }
        if (results.PAYMENTMEANS_CREDITCARD != null) {
            this.processCard(results.PAYMENTMEANS_CREDITCARD);
        }
        if (results.IDENTITY != null) {
            this.processIdentity(results.IDENTITY);
        }
        for (const key in results) {
            if (results.hasOwnProperty(key) && !HandledResults.has(key)) {
                this.processNote(results[key], null, 'Generic Note');
            }
        }
        this.result.success = true;
        return this.result;
    }
    processAuth(results) {
        results.forEach((credential) => {
            const cipher = this.initLoginCipher();
            cipher.name = this.getValueOrDefault(credential.title);
            cipher.login.username = this.getValueOrDefault(credential.login, this.getValueOrDefault(credential.secondaryLogin));
            if (this.isNullOrWhitespace(cipher.login.username)) {
                cipher.login.username = this.getValueOrDefault(credential.email);
            }
            else if (!this.isNullOrWhitespace(credential.email)) {
                cipher.notes = ('Email: ' + credential.email + '\n');
            }
            cipher.login.password = this.getValueOrDefault(credential.password);
            cipher.login.uris = this.makeUriArray(credential.domain);
            cipher.notes += this.getValueOrDefault(credential.note, '');
            this.convertToNoteIfNeeded(cipher);
            this.cleanupCipher(cipher);
            this.result.ciphers.push(cipher);
        });
    }
    processIdentity(results) {
        results.forEach((obj) => {
            const cipher = new cipherView_CipherView();
            cipher.identity = new identityView_IdentityView();
            cipher.type = CipherType.Identity;
            cipher.name = this.getValueOrDefault(obj.fullName, '');
            const nameParts = cipher.name.split(' ');
            if (nameParts.length > 0) {
                cipher.identity.firstName = this.getValueOrDefault(nameParts[0]);
            }
            if (nameParts.length === 2) {
                cipher.identity.lastName = this.getValueOrDefault(nameParts[1]);
            }
            else if (nameParts.length === 3) {
                cipher.identity.middleName = this.getValueOrDefault(nameParts[1]);
                cipher.identity.lastName = this.getValueOrDefault(nameParts[2]);
            }
            cipher.identity.username = this.getValueOrDefault(obj.pseudo);
            this.cleanupCipher(cipher);
            this.result.ciphers.push(cipher);
        });
    }
    processAddress(results) {
        results.forEach((obj) => {
            const cipher = new cipherView_CipherView();
            cipher.identity = new identityView_IdentityView();
            cipher.type = CipherType.Identity;
            cipher.name = this.getValueOrDefault(obj.addressName);
            cipher.identity.address1 = this.getValueOrDefault(obj.addressFull);
            cipher.identity.city = this.getValueOrDefault(obj.city);
            cipher.identity.state = this.getValueOrDefault(obj.state);
            cipher.identity.postalCode = this.getValueOrDefault(obj.zipcode);
            cipher.identity.country = this.getValueOrDefault(obj.country);
            if (cipher.identity.country != null) {
                cipher.identity.country = cipher.identity.country.toUpperCase();
            }
            this.cleanupCipher(cipher);
            this.result.ciphers.push(cipher);
        });
    }
    processCard(results) {
        results.forEach((obj) => {
            const cipher = new cipherView_CipherView();
            cipher.card = new CardView();
            cipher.type = CipherType.Card;
            cipher.name = this.getValueOrDefault(obj.bank);
            cipher.card.number = this.getValueOrDefault(obj.cardNumber);
            cipher.card.brand = this.getCardBrand(cipher.card.number);
            cipher.card.cardholderName = this.getValueOrDefault(obj.owner);
            if (!this.isNullOrWhitespace(cipher.card.brand)) {
                if (this.isNullOrWhitespace(cipher.name)) {
                    cipher.name = cipher.card.brand;
                }
                else {
                    cipher.name += (' - ' + cipher.card.brand);
                }
            }
            this.cleanupCipher(cipher);
            this.result.ciphers.push(cipher);
        });
    }
    processNote(results, nameProperty, name = null) {
        results.forEach((obj) => {
            const cipher = new cipherView_CipherView();
            cipher.secureNote = new SecureNoteView();
            cipher.type = CipherType.SecureNote;
            cipher.secureNote.type = SecureNoteType.Generic;
            if (name != null) {
                cipher.name = name;
            }
            else {
                cipher.name = this.getValueOrDefault(obj[nameProperty]);
            }
            for (const key in obj) {
                if (obj.hasOwnProperty(key) && key !== nameProperty) {
                    this.processKvp(cipher, key, obj[key].toString());
                }
            }
            this.cleanupCipher(cipher);
            this.result.ciphers.push(cipher);
        });
    }
}

// CONCATENATED MODULE: ./jslib/src/importers/encryptrCsvImporter.ts




class encryptrCsvImporter_EncryptrCsvImporter extends baseImporter_BaseImporter {
    parse(data) {
        const result = new ImportResult();
        const results = this.parseCsv(data, true);
        if (results == null) {
            result.success = false;
            return result;
        }
        results.forEach((value) => {
            const cipher = this.initLoginCipher();
            cipher.name = this.getValueOrDefault(value.Label, '--');
            cipher.notes = this.getValueOrDefault(value.Notes);
            const text = this.getValueOrDefault(value.Text);
            if (!this.isNullOrWhitespace(text)) {
                if (this.isNullOrWhitespace(cipher.notes)) {
                    cipher.notes = text;
                }
                else {
                    cipher.notes += ('\n\n' + text);
                }
            }
            const type = value['Entry Type'];
            if (type === 'Password') {
                cipher.login.username = this.getValueOrDefault(value.Username);
                cipher.login.password = this.getValueOrDefault(value.Password);
                cipher.login.uris = this.makeUriArray(value['Site URL']);
            }
            else if (type === 'Credit Card') {
                cipher.type = CipherType.Card;
                cipher.card = new CardView();
                cipher.card.cardholderName = this.getValueOrDefault(value['Name on card']);
                cipher.card.number = this.getValueOrDefault(value['Card Number']);
                cipher.card.brand = this.getCardBrand(cipher.card.number);
                cipher.card.code = this.getValueOrDefault(value.CVV);
                const expiry = this.getValueOrDefault(value.Expiry);
                if (!this.isNullOrWhitespace(expiry)) {
                    const expParts = expiry.split('/');
                    if (expParts.length > 1) {
                        cipher.card.expMonth = parseInt(expParts[0], null).toString();
                        cipher.card.expYear = (2000 + parseInt(expParts[1], null)).toString();
                    }
                }
            }
            this.convertToNoteIfNeeded(cipher);
            this.cleanupCipher(cipher);
            result.ciphers.push(cipher);
        });
        result.success = true;
        return result;
    }
}

// CONCATENATED MODULE: ./jslib/src/importers/enpassCsvImporter.ts






class enpassCsvImporter_EnpassCsvImporter extends baseImporter_BaseImporter {
    parse(data) {
        const result = new ImportResult();
        const results = this.parseCsv(data, false);
        if (results == null) {
            result.success = false;
            return result;
        }
        let firstRow = true;
        results.forEach((value) => {
            if (value.length < 2 || (firstRow && (value[0] === 'Title' || value[0] === 'title'))) {
                firstRow = false;
                return;
            }
            const cipher = this.initLoginCipher();
            cipher.notes = this.getValueOrDefault(value[value.length - 1]);
            cipher.name = this.getValueOrDefault(value[0], '--');
            if (value.length === 2 || (!this.containsField(value, 'username') &&
                !this.containsField(value, 'password') && !this.containsField(value, 'email') &&
                !this.containsField(value, 'url'))) {
                cipher.type = CipherType.SecureNote;
                cipher.secureNote = new SecureNoteView();
                cipher.secureNote.type = SecureNoteType.Generic;
            }
            if (this.containsField(value, 'cardholder') && this.containsField(value, 'number') &&
                this.containsField(value, 'expiry date')) {
                cipher.type = CipherType.Card;
                cipher.card = new CardView();
            }
            if (value.length > 2 && (value.length % 2) === 0) {
                for (let i = 0; i < value.length - 2; i += 2) {
                    const fieldValue = value[i + 2];
                    if (this.isNullOrWhitespace(fieldValue)) {
                        continue;
                    }
                    const fieldName = value[i + 1];
                    const fieldNameLower = fieldName.toLowerCase();
                    if (cipher.type === CipherType.Login) {
                        if (fieldNameLower === 'url' && (cipher.login.uris == null || cipher.login.uris.length === 0)) {
                            cipher.login.uris = this.makeUriArray(fieldValue);
                            continue;
                        }
                        else if ((fieldNameLower === 'username' || fieldNameLower === 'email') &&
                            this.isNullOrWhitespace(cipher.login.username)) {
                            cipher.login.username = fieldValue;
                            continue;
                        }
                        else if (fieldNameLower === 'password' && this.isNullOrWhitespace(cipher.login.password)) {
                            cipher.login.password = fieldValue;
                            continue;
                        }
                        else if (fieldNameLower === 'totp' && this.isNullOrWhitespace(cipher.login.totp)) {
                            cipher.login.totp = fieldValue;
                            continue;
                        }
                    }
                    else if (cipher.type === CipherType.Card) {
                        if (fieldNameLower === 'cardholder' && this.isNullOrWhitespace(cipher.card.cardholderName)) {
                            cipher.card.cardholderName = fieldValue;
                            continue;
                        }
                        else if (fieldNameLower === 'number' && this.isNullOrWhitespace(cipher.card.number)) {
                            cipher.card.number = fieldValue;
                            cipher.card.brand = this.getCardBrand(fieldValue);
                            continue;
                        }
                        else if (fieldNameLower === 'cvc' && this.isNullOrWhitespace(cipher.card.code)) {
                            cipher.card.code = fieldValue;
                            continue;
                        }
                        else if (fieldNameLower === 'expiry date' && this.isNullOrWhitespace(cipher.card.expMonth) &&
                            this.isNullOrWhitespace(cipher.card.expYear)) {
                            if (this.setCardExpiration(cipher, fieldValue)) {
                                continue;
                            }
                        }
                        else if (fieldNameLower === 'type') {
                            // Skip since brand was determined from number above
                            continue;
                        }
                    }
                    this.processKvp(cipher, fieldName, fieldValue);
                }
            }
            this.cleanupCipher(cipher);
            result.ciphers.push(cipher);
        });
        result.success = true;
        return result;
    }
    containsField(fields, name) {
        if (fields == null || name == null) {
            return false;
        }
        return fields.filter((f) => !this.isNullOrWhitespace(f) &&
            f.toLowerCase() === name.toLowerCase()).length > 0;
    }
}

// CONCATENATED MODULE: ./jslib/src/importers/enpassJsonImporter.ts






class enpassJsonImporter_EnpassJsonImporter extends baseImporter_BaseImporter {
    parse(data) {
        const result = new ImportResult();
        const results = JSON.parse(data);
        if (results == null || results.items == null || results.items.length === 0) {
            result.success = false;
            return result;
        }
        const foldersMap = new Map();
        const foldersIndexMap = new Map();
        const folderTree = this.buildFolderTree(results.folders);
        this.flattenFolderTree(null, folderTree, foldersMap);
        foldersMap.forEach((val, key) => {
            foldersIndexMap.set(key, result.folders.length);
            const f = new FolderView();
            f.name = val;
            result.folders.push(f);
        });
        results.items.forEach((item) => {
            if (item.folders != null && item.folders.length > 0 && foldersIndexMap.has(item.folders[0])) {
                result.folderRelationships.push([result.ciphers.length, foldersIndexMap.get(item.folders[0])]);
            }
            const cipher = this.initLoginCipher();
            cipher.name = this.getValueOrDefault(item.title);
            cipher.favorite = item.favorite > 0;
            if (item.template_type != null && item.fields != null && item.fields.length > 0) {
                if (item.template_type.indexOf('login.') === 0 || item.template_type.indexOf('password.') === 0) {
                    this.processLogin(cipher, item.fields);
                }
                else if (item.template_type.indexOf('creditcard.') === 0) {
                    this.processCard(cipher, item.fields);
                }
                else if (item.template_type.indexOf('identity.') < 0 &&
                    item.fields.some((f) => f.type === 'password' && !this.isNullOrWhitespace(f.value))) {
                    this.processLogin(cipher, item.fields);
                }
                else {
                    this.processNote(cipher, item.fields);
                }
            }
            cipher.notes += ('\n' + this.getValueOrDefault(item.note, ''));
            this.convertToNoteIfNeeded(cipher);
            this.cleanupCipher(cipher);
            result.ciphers.push(cipher);
        });
        result.success = true;
        return result;
    }
    processLogin(cipher, fields) {
        const urls = [];
        fields.forEach((field) => {
            if (this.isNullOrWhitespace(field.value) || field.type === 'section') {
                return;
            }
            if ((field.type === 'username' || field.type === 'email') &&
                this.isNullOrWhitespace(cipher.login.username)) {
                cipher.login.username = field.value;
            }
            else if (field.type === 'password' && this.isNullOrWhitespace(cipher.login.password)) {
                cipher.login.password = field.value;
            }
            else if (field.type === 'totp' && this.isNullOrWhitespace(cipher.login.totp)) {
                cipher.login.totp = field.value;
            }
            else if (field.type === 'url') {
                urls.push(field.value);
            }
            else {
                this.processKvp(cipher, field.label, field.value, field.sensitive === 1 ? FieldType.Hidden : FieldType.Text);
            }
        });
        cipher.login.uris = this.makeUriArray(urls);
    }
    processCard(cipher, fields) {
        cipher.card = new CardView();
        cipher.type = CipherType.Card;
        fields.forEach((field) => {
            if (this.isNullOrWhitespace(field.value) || field.type === 'section' || field.type === 'ccType') {
                return;
            }
            if (field.type === 'ccName' && this.isNullOrWhitespace(cipher.card.cardholderName)) {
                cipher.card.cardholderName = field.value;
            }
            else if (field.type === 'ccNumber' && this.isNullOrWhitespace(cipher.card.number)) {
                cipher.card.number = field.value;
                cipher.card.brand = this.getCardBrand(cipher.card.number);
            }
            else if (field.type === 'ccCvc' && this.isNullOrWhitespace(cipher.card.code)) {
                cipher.card.code = field.value;
            }
            else if (field.type === 'ccExpiry' && this.isNullOrWhitespace(cipher.card.expYear)) {
                if (!this.setCardExpiration(cipher, field.value)) {
                    this.processKvp(cipher, field.label, field.value, field.sensitive === 1 ? FieldType.Hidden : FieldType.Text);
                }
            }
            else {
                this.processKvp(cipher, field.label, field.value, field.sensitive === 1 ? FieldType.Hidden : FieldType.Text);
            }
        });
    }
    processNote(cipher, fields) {
        fields.forEach((field) => {
            if (this.isNullOrWhitespace(field.value) || field.type === 'section') {
                return;
            }
            this.processKvp(cipher, field.label, field.value, field.sensitive === 1 ? FieldType.Hidden : FieldType.Text);
        });
    }
    buildFolderTree(folders) {
        if (folders == null) {
            return [];
        }
        const folderTree = [];
        const map = new Map([]);
        folders.forEach((obj) => {
            map.set(obj.uuid, obj);
            obj.children = [];
        });
        folders.forEach((obj) => {
            if (obj.parent_uuid != null && obj.parent_uuid !== '' && map.has(obj.parent_uuid)) {
                map.get(obj.parent_uuid).children.push(obj);
            }
            else {
                folderTree.push(obj);
            }
        });
        return folderTree;
    }
    flattenFolderTree(titlePrefix, tree, map) {
        if (tree == null) {
            return;
        }
        tree.forEach((f) => {
            if (f.title != null && f.title.trim() !== '') {
                let title = f.title.trim();
                if (titlePrefix != null && titlePrefix.trim() !== '') {
                    title = titlePrefix + '/' + title;
                }
                map.set(f.uuid, title);
                if (f.children != null && f.children.length !== 0) {
                    this.flattenFolderTree(title, f.children, map);
                }
            }
        });
    }
}

// CONCATENATED MODULE: ./jslib/src/importers/firefoxCsvImporter.ts


class firefoxCsvImporter_FirefoxCsvImporter extends baseImporter_BaseImporter {
    parse(data) {
        const result = new ImportResult();
        const results = this.parseCsv(data, true);
        if (results == null) {
            result.success = false;
            return result;
        }
        results.forEach((value) => {
            const cipher = this.initLoginCipher();
            cipher.name = this.getValueOrDefault(this.nameFromUrl(value.hostname), '--');
            cipher.login.username = this.getValueOrDefault(value.username);
            cipher.login.password = this.getValueOrDefault(value.password);
            cipher.login.uris = this.makeUriArray(value.hostname);
            this.cleanupCipher(cipher);
            result.ciphers.push(cipher);
        });
        result.success = true;
        return result;
    }
}

// CONCATENATED MODULE: ./jslib/src/importers/fsecureFskImporter.ts




class fsecureFskImporter_FSecureFskImporter extends baseImporter_BaseImporter {
    parse(data) {
        const result = new ImportResult();
        const results = JSON.parse(data);
        if (results == null || results.data == null) {
            result.success = false;
            return result;
        }
        for (const key in results.data) {
            if (!results.data.hasOwnProperty(key)) {
                continue;
            }
            const value = results.data[key];
            const cipher = this.initLoginCipher();
            cipher.name = this.getValueOrDefault(value.service);
            cipher.notes = this.getValueOrDefault(value.notes);
            if (value.style === 'website') {
                cipher.login.username = this.getValueOrDefault(value.username);
                cipher.login.password = this.getValueOrDefault(value.password);
                cipher.login.uris = this.makeUriArray(value.url);
            }
            else if (value.style === 'creditcard') {
                cipher.type = CipherType.Card;
                cipher.card = new CardView();
                cipher.card.cardholderName = this.getValueOrDefault(value.username);
                cipher.card.number = this.getValueOrDefault(value.creditNumber);
                cipher.card.brand = this.getCardBrand(cipher.card.number);
                cipher.card.code = this.getValueOrDefault(value.creditCvv);
                if (!this.isNullOrWhitespace(value.creditExpiry)) {
                    if (!this.setCardExpiration(cipher, value.creditExpiry)) {
                        this.processKvp(cipher, 'Expiration', value.creditExpiry);
                    }
                }
                if (!this.isNullOrWhitespace(value.password)) {
                    this.processKvp(cipher, 'PIN', value.password);
                }
            }
            else {
                continue;
            }
            this.convertToNoteIfNeeded(cipher);
            this.cleanupCipher(cipher);
            result.ciphers.push(cipher);
        }
        result.success = true;
        return result;
    }
}

// CONCATENATED MODULE: ./jslib/src/importers/gnomeJsonImporter.ts


class gnomeJsonImporter_GnomeJsonImporter extends baseImporter_BaseImporter {
    parse(data) {
        const result = new ImportResult();
        const results = JSON.parse(data);
        if (results == null || Object.keys(results).length === 0) {
            result.success = false;
            return result;
        }
        for (const keyRing in results) {
            if (!results.hasOwnProperty(keyRing) || this.isNullOrWhitespace(keyRing) ||
                results[keyRing].length === 0) {
                continue;
            }
            results[keyRing].forEach((value) => {
                if (this.isNullOrWhitespace(value.display_name) || value.display_name.indexOf('http') !== 0) {
                    return;
                }
                this.processFolder(result, keyRing);
                const cipher = this.initLoginCipher();
                cipher.name = value.display_name.replace('http://', '').replace('https://', '');
                if (cipher.name.length > 30) {
                    cipher.name = cipher.name.substring(0, 30);
                }
                cipher.login.password = this.getValueOrDefault(value.secret);
                cipher.login.uris = this.makeUriArray(value.display_name);
                if (value.attributes != null) {
                    cipher.login.username = value.attributes != null ?
                        this.getValueOrDefault(value.attributes.username_value) : null;
                    for (const attr in value.attributes) {
                        if (!value.attributes.hasOwnProperty(attr) || attr === 'username_value' ||
                            attr === 'xdg:schema') {
                            continue;
                        }
                        this.processKvp(cipher, attr, value.attributes[attr]);
                    }
                }
                this.convertToNoteIfNeeded(cipher);
                this.cleanupCipher(cipher);
                result.ciphers.push(cipher);
            });
        }
        if (this.organization) {
            this.moveFoldersToCollections(result);
        }
        result.success = true;
        return result;
    }
}

// CONCATENATED MODULE: ./jslib/src/importers/kasperskyTxtImporter.ts


const NotesHeader = 'Notes\n\n';
const ApplicationsHeader = 'Applications\n\n';
const WebsitesHeader = 'Websites\n\n';
const Delimiter = '\n---\n';
class kasperskyTxtImporter_KasperskyTxtImporter extends baseImporter_BaseImporter {
    parse(data) {
        const result = new ImportResult();
        let notesData;
        let applicationsData;
        let websitesData;
        let workingData = this.splitNewLine(data).join('\n');
        if (workingData.indexOf(NotesHeader) !== -1) {
            const parts = workingData.split(NotesHeader);
            if (parts.length > 1) {
                workingData = parts[0];
                notesData = parts[1];
            }
        }
        if (workingData.indexOf(ApplicationsHeader) !== -1) {
            const parts = workingData.split(ApplicationsHeader);
            if (parts.length > 1) {
                workingData = parts[0];
                applicationsData = parts[1];
            }
        }
        if (workingData.indexOf(WebsitesHeader) === 0) {
            const parts = workingData.split(WebsitesHeader);
            if (parts.length > 1) {
                workingData = parts[0];
                websitesData = parts[1];
            }
        }
        const notes = this.parseDataCategory(notesData);
        const applications = this.parseDataCategory(applicationsData);
        const websites = this.parseDataCategory(websitesData);
        notes.forEach((n) => {
            const cipher = this.initLoginCipher();
            cipher.name = this.getValueOrDefault(n.get('Name'));
            cipher.notes = this.getValueOrDefault(n.get('Text'));
            this.cleanupCipher(cipher);
            result.ciphers.push(cipher);
        });
        websites.concat(applications).forEach((w) => {
            const cipher = this.initLoginCipher();
            const nameKey = w.has('Website name') ? 'Website name' : 'Application';
            cipher.name = this.getValueOrDefault(w.get(nameKey), '');
            if (!this.isNullOrWhitespace(w.get('Login name'))) {
                if (!this.isNullOrWhitespace(cipher.name)) {
                    cipher.name += ': ';
                }
                cipher.name += w.get('Login name');
            }
            cipher.notes = this.getValueOrDefault(w.get('Comment'));
            if (w.has('Website URL')) {
                cipher.login.uris = this.makeUriArray(w.get('Website URL'));
            }
            cipher.login.username = this.getValueOrDefault(w.get('Login'));
            cipher.login.password = this.getValueOrDefault(w.get('Password'));
            this.cleanupCipher(cipher);
            result.ciphers.push(cipher);
        });
        result.success = true;
        return result;
    }
    parseDataCategory(data) {
        if (this.isNullOrWhitespace(data) || data.indexOf(Delimiter) === -1) {
            return [];
        }
        const items = [];
        data.split(Delimiter).forEach((p) => {
            if (p.indexOf('\n') === -1) {
                return;
            }
            const item = new Map();
            let itemComment;
            let itemCommentKey;
            p.split('\n').forEach((l) => {
                if (itemComment != null) {
                    itemComment += ('\n' + l);
                    return;
                }
                const colonIndex = l.indexOf(':');
                let key;
                let val;
                if (colonIndex === -1) {
                    return;
                }
                else {
                    key = l.substring(0, colonIndex);
                    if (l.length > colonIndex + 1) {
                        val = l.substring(colonIndex + 2);
                    }
                }
                if (key != null) {
                    item.set(key, val);
                }
                if (key === 'Comment' || key === 'Text') {
                    itemComment = val;
                    itemCommentKey = key;
                }
            });
            if (itemComment != null && itemCommentKey != null) {
                item.set(itemCommentKey, itemComment);
            }
            if (item.size === 0) {
                return;
            }
            items.push(item);
        });
        return items;
    }
}

// CONCATENATED MODULE: ./jslib/src/importers/keepass2XmlImporter.ts




class keepass2XmlImporter_KeePass2XmlImporter extends baseImporter_BaseImporter {
    constructor() {
        super(...arguments);
        this.result = new ImportResult();
    }
    parse(data) {
        const doc = this.parseXml(data);
        if (doc == null) {
            this.result.success = false;
            return this.result;
        }
        const rootGroup = doc.querySelector('KeePassFile > Root > Group');
        if (rootGroup == null) {
            this.result.errorMessage = 'Missing `KeePassFile > Root > Group` node.';
            this.result.success = false;
            return this.result;
        }
        this.traverse(rootGroup, true, '');
        if (this.organization) {
            this.moveFoldersToCollections(this.result);
        }
        this.result.success = true;
        return this.result;
    }
    traverse(node, isRootNode, groupPrefixName) {
        const folderIndex = this.result.folders.length;
        let groupName = groupPrefixName;
        if (!isRootNode) {
            if (groupName !== '') {
                groupName += '/';
            }
            const nameEl = this.querySelectorDirectChild(node, 'Name');
            groupName += nameEl == null ? '-' : nameEl.textContent;
            const folder = new FolderView();
            folder.name = groupName;
            this.result.folders.push(folder);
        }
        this.querySelectorAllDirectChild(node, 'Entry').forEach((entry) => {
            const cipherIndex = this.result.ciphers.length;
            const cipher = this.initLoginCipher();
            this.querySelectorAllDirectChild(entry, 'String').forEach((entryString) => {
                const valueEl = this.querySelectorDirectChild(entryString, 'Value');
                const value = valueEl != null ? valueEl.textContent : null;
                if (this.isNullOrWhitespace(value)) {
                    return;
                }
                const keyEl = this.querySelectorDirectChild(entryString, 'Key');
                const key = keyEl != null ? keyEl.textContent : null;
                if (key === 'URL') {
                    cipher.login.uris = this.makeUriArray(value);
                }
                else if (key === 'UserName') {
                    cipher.login.username = value;
                }
                else if (key === 'Password') {
                    cipher.login.password = value;
                }
                else if (key === 'Title') {
                    cipher.name = value;
                }
                else if (key === 'Notes') {
                    cipher.notes += (value + '\n');
                }
                else {
                    let type = FieldType.Text;
                    const attrs = valueEl.attributes;
                    if (attrs.length > 0 && attrs.ProtectInMemory != null &&
                        attrs.ProtectInMemory.value === 'True') {
                        type = FieldType.Hidden;
                    }
                    this.processKvp(cipher, key, value, type);
                }
            });
            this.cleanupCipher(cipher);
            this.result.ciphers.push(cipher);
            if (!isRootNode) {
                this.result.folderRelationships.push([cipherIndex, folderIndex]);
            }
        });
        this.querySelectorAllDirectChild(node, 'Group').forEach((group) => {
            this.traverse(group, false, groupName);
        });
    }
}

// CONCATENATED MODULE: ./jslib/src/importers/keepassxCsvImporter.ts


class keepassxCsvImporter_KeePassXCsvImporter extends baseImporter_BaseImporter {
    parse(data) {
        const result = new ImportResult();
        const results = this.parseCsv(data, true);
        if (results == null) {
            result.success = false;
            return result;
        }
        results.forEach((value) => {
            if (this.isNullOrWhitespace(value.Title)) {
                return;
            }
            value.Group = !this.isNullOrWhitespace(value.Group) && value.Group.startsWith('Root/') ?
                value.Group.replace('Root/', '') : value.Group;
            const groupName = !this.isNullOrWhitespace(value.Group) ? value.Group : null;
            this.processFolder(result, groupName);
            const cipher = this.initLoginCipher();
            cipher.notes = this.getValueOrDefault(value.Notes);
            cipher.name = this.getValueOrDefault(value.Title, '--');
            cipher.login.username = this.getValueOrDefault(value.Username);
            cipher.login.password = this.getValueOrDefault(value.Password);
            cipher.login.uris = this.makeUriArray(value.URL);
            this.cleanupCipher(cipher);
            result.ciphers.push(cipher);
        });
        if (this.organization) {
            this.moveFoldersToCollections(result);
        }
        result.success = true;
        return result;
    }
}

// CONCATENATED MODULE: ./jslib/src/importers/keeperCsvImporter.ts


class keeperCsvImporter_KeeperCsvImporter extends baseImporter_BaseImporter {
    parse(data) {
        const result = new ImportResult();
        const results = this.parseCsv(data, false);
        if (results == null) {
            result.success = false;
            return result;
        }
        results.forEach((value) => {
            if (value.length < 6) {
                return;
            }
            this.processFolder(result, value[0]);
            const cipher = this.initLoginCipher();
            cipher.notes = this.getValueOrDefault(value[5]) + '\n';
            cipher.name = this.getValueOrDefault(value[1], '--');
            cipher.login.username = this.getValueOrDefault(value[2]);
            cipher.login.password = this.getValueOrDefault(value[3]);
            cipher.login.uris = this.makeUriArray(value[4]);
            if (value.length > 7) {
                // we have some custom fields.
                for (let i = 7; i < value.length; i = i + 2) {
                    this.processKvp(cipher, value[i], value[i + 1]);
                }
            }
            this.cleanupCipher(cipher);
            result.ciphers.push(cipher);
        });
        if (this.organization) {
            this.moveFoldersToCollections(result);
        }
        result.success = true;
        return result;
    }
}

// CONCATENATED MODULE: ./jslib/src/importers/lastpassCsvImporter.ts










class lastpassCsvImporter_LastPassCsvImporter extends baseImporter_BaseImporter {
    parse(data) {
        const result = new ImportResult();
        const results = this.parseCsv(data, true);
        if (results == null) {
            result.success = false;
            return result;
        }
        results.forEach((value, index) => {
            const cipherIndex = result.ciphers.length;
            let folderIndex = result.folders.length;
            let grouping = value.grouping;
            if (grouping != null) {
                grouping = grouping.replace(/\\/g, '/').replace(/[\x00-\x1F\x7F-\x9F]/g, '');
            }
            const hasFolder = this.getValueOrDefault(grouping, '(none)') !== '(none)';
            let addFolder = hasFolder;
            if (hasFolder) {
                for (let i = 0; i < result.folders.length; i++) {
                    if (result.folders[i].name === grouping) {
                        addFolder = false;
                        folderIndex = i;
                        break;
                    }
                }
            }
            const cipher = this.buildBaseCipher(value);
            if (cipher.type === CipherType.Login) {
                cipher.notes = this.getValueOrDefault(value.extra);
                cipher.login = new LoginView();
                cipher.login.uris = this.makeUriArray(value.url);
                cipher.login.username = this.getValueOrDefault(value.username);
                cipher.login.password = this.getValueOrDefault(value.password);
            }
            else if (cipher.type === CipherType.SecureNote) {
                this.parseSecureNote(value, cipher);
            }
            else if (cipher.type === CipherType.Card) {
                cipher.card = this.parseCard(value);
                cipher.notes = this.getValueOrDefault(value.notes);
            }
            else if (cipher.type === CipherType.Identity) {
                cipher.identity = this.parseIdentity(value);
                cipher.notes = this.getValueOrDefault(value.notes);
                if (!this.isNullOrWhitespace(value.ccnum)) {
                    // there is a card on this identity too
                    const cardCipher = this.buildBaseCipher(value);
                    cardCipher.identity = null;
                    cardCipher.type = CipherType.Card;
                    cardCipher.card = this.parseCard(value);
                    result.ciphers.push(cardCipher);
                }
            }
            result.ciphers.push(cipher);
            if (addFolder) {
                const f = new FolderView();
                f.name = grouping;
                result.folders.push(f);
            }
            if (hasFolder) {
                result.folderRelationships.push([cipherIndex, folderIndex]);
            }
        });
        if (this.organization) {
            this.moveFoldersToCollections(result);
        }
        result.success = true;
        return result;
    }
    buildBaseCipher(value) {
        const cipher = new cipherView_CipherView();
        if (value.hasOwnProperty('profilename') && value.hasOwnProperty('profilelanguage')) {
            // form fill
            cipher.favorite = false;
            cipher.name = this.getValueOrDefault(value.profilename, '--');
            cipher.type = CipherType.Card;
            if (!this.isNullOrWhitespace(value.title) || !this.isNullOrWhitespace(value.firstname) ||
                !this.isNullOrWhitespace(value.lastname) || !this.isNullOrWhitespace(value.address1) ||
                !this.isNullOrWhitespace(value.phone) || !this.isNullOrWhitespace(value.username) ||
                !this.isNullOrWhitespace(value.email)) {
                cipher.type = CipherType.Identity;
            }
        }
        else {
            // site or secure note
            cipher.favorite = !this.organization && this.getValueOrDefault(value.fav, '0') === '1';
            cipher.name = this.getValueOrDefault(value.name, '--');
            cipher.type = value.url === 'http://sn' ? CipherType.SecureNote : CipherType.Login;
        }
        return cipher;
    }
    parseCard(value) {
        const card = new CardView();
        card.cardholderName = this.getValueOrDefault(value.ccname);
        card.number = this.getValueOrDefault(value.ccnum);
        card.code = this.getValueOrDefault(value.cccsc);
        card.brand = this.getCardBrand(value.ccnum);
        if (!this.isNullOrWhitespace(value.ccexp) && value.ccexp.indexOf('-') > -1) {
            const ccexpParts = value.ccexp.split('-');
            if (ccexpParts.length > 1) {
                card.expYear = ccexpParts[0];
                card.expMonth = ccexpParts[1];
                if (card.expMonth.length === 2 && card.expMonth[0] === '0') {
                    card.expMonth = card.expMonth[1];
                }
            }
        }
        return card;
    }
    parseIdentity(value) {
        const identity = new identityView_IdentityView();
        identity.title = this.getValueOrDefault(value.title);
        identity.firstName = this.getValueOrDefault(value.firstname);
        identity.middleName = this.getValueOrDefault(value.middlename);
        identity.lastName = this.getValueOrDefault(value.lastname);
        identity.username = this.getValueOrDefault(value.username);
        identity.company = this.getValueOrDefault(value.company);
        identity.ssn = this.getValueOrDefault(value.ssn);
        identity.address1 = this.getValueOrDefault(value.address1);
        identity.address2 = this.getValueOrDefault(value.address2);
        identity.address3 = this.getValueOrDefault(value.address3);
        identity.city = this.getValueOrDefault(value.city);
        identity.state = this.getValueOrDefault(value.state);
        identity.postalCode = this.getValueOrDefault(value.zip);
        identity.country = this.getValueOrDefault(value.country);
        identity.email = this.getValueOrDefault(value.email);
        identity.phone = this.getValueOrDefault(value.phone);
        if (!this.isNullOrWhitespace(identity.title)) {
            identity.title = identity.title.charAt(0).toUpperCase() + identity.title.slice(1);
        }
        return identity;
    }
    parseSecureNote(value, cipher) {
        const extraParts = this.splitNewLine(value.extra);
        let processedNote = false;
        if (extraParts.length) {
            const typeParts = extraParts[0].split(':');
            if (typeParts.length > 1 && typeParts[0] === 'NoteType' &&
                (typeParts[1] === 'Credit Card' || typeParts[1] === 'Address')) {
                if (typeParts[1] === 'Credit Card') {
                    const mappedData = this.parseSecureNoteMapping(cipher, extraParts, {
                        'Number': 'number',
                        'Name on Card': 'cardholderName',
                        'Security Code': 'code',
                        // LP provides date in a format like 'June,2020'
                        // Store in expMonth, then parse and modify
                        'Expiration Date': 'expMonth',
                    });
                    if (this.isNullOrWhitespace(mappedData.expMonth) || mappedData.expMonth === ',') {
                        // No expiration data
                        mappedData.expMonth = undefined;
                    }
                    else {
                        const [monthString, year] = mappedData.expMonth.split(',');
                        // Parse month name into number
                        if (!this.isNullOrWhitespace(monthString)) {
                            const month = new Date(Date.parse(monthString.trim() + ' 1, 2012')).getMonth() + 1;
                            if (isNaN(month)) {
                                mappedData.expMonth = undefined;
                            }
                            else {
                                mappedData.expMonth = month.toString();
                            }
                        }
                        else {
                            mappedData.expMonth = undefined;
                        }
                        if (!this.isNullOrWhitespace(year)) {
                            mappedData.expYear = year;
                        }
                    }
                    cipher.type = CipherType.Card;
                    cipher.card = mappedData;
                }
                else if (typeParts[1] === 'Address') {
                    const mappedData = this.parseSecureNoteMapping(cipher, extraParts, {
                        'Title': 'title',
                        'First Name': 'firstName',
                        'Last Name': 'lastName',
                        'Middle Name': 'middleName',
                        'Company': 'company',
                        'Address 1': 'address1',
                        'Address 2': 'address2',
                        'Address 3': 'address3',
                        'City / Town': 'city',
                        'State': 'state',
                        'Zip / Postal Code': 'postalCode',
                        'Country': 'country',
                        'Email Address': 'email',
                        'Username': 'username',
                    });
                    cipher.type = CipherType.Identity;
                    cipher.identity = mappedData;
                }
                processedNote = true;
            }
        }
        if (!processedNote) {
            cipher.secureNote = new SecureNoteView();
            cipher.secureNote.type = SecureNoteType.Generic;
            cipher.notes = this.getValueOrDefault(value.extra);
        }
    }
    parseSecureNoteMapping(cipher, extraParts, map) {
        const dataObj = {};
        let processingNotes = false;
        extraParts.forEach((extraPart) => {
            let key = null;
            let val = null;
            if (!processingNotes) {
                if (this.isNullOrWhitespace(extraPart)) {
                    return;
                }
                const colonIndex = extraPart.indexOf(':');
                if (colonIndex === -1) {
                    key = extraPart;
                }
                else {
                    key = extraPart.substring(0, colonIndex);
                    if (extraPart.length > colonIndex) {
                        val = extraPart.substring(colonIndex + 1);
                    }
                }
                if (this.isNullOrWhitespace(key) || this.isNullOrWhitespace(val) || key === 'NoteType') {
                    return;
                }
            }
            if (processingNotes) {
                cipher.notes += ('\n' + extraPart);
            }
            else if (key === 'Notes') {
                if (!this.isNullOrWhitespace(cipher.notes)) {
                    cipher.notes += ('\n' + val);
                }
                else {
                    cipher.notes = val;
                }
                processingNotes = true;
            }
            else if (map.hasOwnProperty(key)) {
                dataObj[map[key]] = val;
            }
            else {
                this.processKvp(cipher, key, val);
            }
        });
        return dataObj;
    }
}

// CONCATENATED MODULE: ./jslib/src/importers/logMeOnceCsvImporter.ts


class logMeOnceCsvImporter_LogMeOnceCsvImporter extends baseImporter_BaseImporter {
    parse(data) {
        const result = new ImportResult();
        const results = this.parseCsv(data, false);
        if (results == null) {
            result.success = false;
            return result;
        }
        results.forEach((value) => {
            if (value.length < 4) {
                return;
            }
            const cipher = this.initLoginCipher();
            cipher.name = this.getValueOrDefault(value[0], '--');
            cipher.login.username = this.getValueOrDefault(value[2]);
            cipher.login.password = this.getValueOrDefault(value[3]);
            cipher.login.uris = this.makeUriArray(value[1]);
            this.cleanupCipher(cipher);
            result.ciphers.push(cipher);
        });
        result.success = true;
        return result;
    }
}

// CONCATENATED MODULE: ./jslib/src/importers/meldiumCsvImporter.ts


class meldiumCsvImporter_MeldiumCsvImporter extends baseImporter_BaseImporter {
    parse(data) {
        const result = new ImportResult();
        const results = this.parseCsv(data, true);
        if (results == null) {
            result.success = false;
            return result;
        }
        results.forEach((value) => {
            const cipher = this.initLoginCipher();
            cipher.name = this.getValueOrDefault(value.DisplayName, '--');
            cipher.notes = this.getValueOrDefault(value.Notes);
            cipher.login.username = this.getValueOrDefault(value.UserName);
            cipher.login.password = this.getValueOrDefault(value.Password);
            cipher.login.uris = this.makeUriArray(value.Url);
            this.cleanupCipher(cipher);
            result.ciphers.push(cipher);
        });
        result.success = true;
        return result;
    }
}

// CONCATENATED MODULE: ./jslib/src/importers/msecureCsvImporter.ts





class msecureCsvImporter_MSecureCsvImporter extends baseImporter_BaseImporter {
    parse(data) {
        const result = new ImportResult();
        const results = this.parseCsv(data, false);
        if (results == null) {
            result.success = false;
            return result;
        }
        results.forEach((value) => {
            if (value.length < 3) {
                return;
            }
            const folderName = this.getValueOrDefault(value[0], 'Unassigned') !== 'Unassigned' ? value[0] : null;
            this.processFolder(result, folderName);
            const cipher = this.initLoginCipher();
            cipher.name = this.getValueOrDefault(value[2], '--');
            if (value[1] === 'Web Logins' || value[1] === 'Login') {
                cipher.login.uris = this.makeUriArray(value[4]);
                cipher.login.username = this.getValueOrDefault(value[5]);
                cipher.login.password = this.getValueOrDefault(value[6]);
                cipher.notes = !this.isNullOrWhitespace(value[3]) ? value[3].split('\\n').join('\n') : null;
            }
            else if (value.length > 3) {
                cipher.type = CipherType.SecureNote;
                cipher.secureNote = new SecureNoteView();
                cipher.secureNote.type = SecureNoteType.Generic;
                for (let i = 3; i < value.length; i++) {
                    if (!this.isNullOrWhitespace(value[i])) {
                        cipher.notes += (value[i] + '\n');
                    }
                }
            }
            if (!this.isNullOrWhitespace(value[1]) && cipher.type !== CipherType.Login) {
                cipher.name = value[1] + ': ' + cipher.name;
            }
            this.cleanupCipher(cipher);
            result.ciphers.push(cipher);
        });
        if (this.organization) {
            this.moveFoldersToCollections(result);
        }
        result.success = true;
        return result;
    }
}

// CONCATENATED MODULE: ./jslib/src/importers/mykiCsvImporter.ts







class mykiCsvImporter_MykiCsvImporter extends baseImporter_BaseImporter {
    parse(data) {
        const result = new ImportResult();
        const results = this.parseCsv(data, true);
        if (results == null) {
            result.success = false;
            return result;
        }
        results.forEach((value) => {
            const cipher = this.initLoginCipher();
            cipher.name = this.getValueOrDefault(value.nickname, '--');
            cipher.notes = this.getValueOrDefault(value.additionalInfo);
            if (value.url !== undefined) {
                // Accounts
                cipher.login.uris = this.makeUriArray(value.url);
                cipher.login.username = this.getValueOrDefault(value.username);
                cipher.login.password = this.getValueOrDefault(value.password);
                cipher.login.totp = this.getValueOrDefault(value.twoFactAuthToken);
            }
            else if (value.cardNumber !== undefined) {
                // Cards
                cipher.card = new CardView();
                cipher.type = CipherType.Card;
                cipher.card.cardholderName = this.getValueOrDefault(value.cardName);
                cipher.card.number = this.getValueOrDefault(value.cardNumber);
                cipher.card.brand = this.getCardBrand(cipher.card.number);
                cipher.card.expMonth = this.getValueOrDefault(value.exp_month);
                cipher.card.expYear = this.getValueOrDefault(value.exp_year);
                cipher.card.code = this.getValueOrDefault(value.cvv);
            }
            else if (value.firstName !== undefined) {
                // Identities
                cipher.identity = new identityView_IdentityView();
                cipher.type = CipherType.Identity;
                cipher.identity.title = this.getValueOrDefault(value.title);
                cipher.identity.firstName = this.getValueOrDefault(value.firstName);
                cipher.identity.middleName = this.getValueOrDefault(value.middleName);
                cipher.identity.lastName = this.getValueOrDefault(value.lastName);
                cipher.identity.phone = this.getValueOrDefault(value.number);
                cipher.identity.email = this.getValueOrDefault(value.email);
                cipher.identity.address1 = this.getValueOrDefault(value.firstAddressLine);
                cipher.identity.address2 = this.getValueOrDefault(value.secondAddressLine);
                cipher.identity.city = this.getValueOrDefault(value.city);
                cipher.identity.country = this.getValueOrDefault(value.country);
                cipher.identity.postalCode = this.getValueOrDefault(value.zipCode);
            }
            else if (value.content !== undefined) {
                // Notes
                cipher.secureNote = new SecureNoteView();
                cipher.type = CipherType.SecureNote;
                cipher.secureNote.type = SecureNoteType.Generic;
                cipher.name = this.getValueOrDefault(value.title, '--');
                cipher.notes = this.getValueOrDefault(value.content);
            }
            else {
                return;
            }
            this.cleanupCipher(cipher);
            result.ciphers.push(cipher);
        });
        result.success = true;
        return result;
    }
}

// CONCATENATED MODULE: ./jslib/src/importers/onepassword1PifImporter.ts









class onepassword1PifImporter_OnePassword1PifImporter extends baseImporter_BaseImporter {
    constructor() {
        super(...arguments);
        this.result = new ImportResult();
    }
    parse(data) {
        data.split(this.newLineRegex).forEach((line) => {
            if (this.isNullOrWhitespace(line) || line[0] !== '{') {
                return;
            }
            const item = JSON.parse(line);
            if (item.trashed === true) {
                return;
            }
            const cipher = this.initLoginCipher();
            if (this.isNullOrWhitespace(item.hmac)) {
                this.processStandardItem(item, cipher);
            }
            else {
                this.processWinOpVaultItem(item, cipher);
            }
            this.convertToNoteIfNeeded(cipher);
            this.cleanupCipher(cipher);
            this.result.ciphers.push(cipher);
        });
        this.result.success = true;
        return this.result;
    }
    processWinOpVaultItem(item, cipher) {
        if (item.overview != null) {
            cipher.name = this.getValueOrDefault(item.overview.title);
            if (item.overview.URLs != null) {
                const urls = [];
                item.overview.URLs.forEach((url) => {
                    if (!this.isNullOrWhitespace(url.u)) {
                        urls.push(url.u);
                    }
                });
                cipher.login.uris = this.makeUriArray(urls);
            }
        }
        if (item.details != null) {
            if (item.details.passwordHistory != null) {
                this.parsePasswordHistory(item.details.passwordHistory, cipher);
            }
            if (!this.isNullOrWhitespace(item.details.ccnum) || !this.isNullOrWhitespace(item.details.cvv)) {
                cipher.type = CipherType.Card;
                cipher.card = new CardView();
            }
            else if (!this.isNullOrWhitespace(item.details.firstname) ||
                !this.isNullOrWhitespace(item.details.address1)) {
                cipher.type = CipherType.Identity;
                cipher.identity = new identityView_IdentityView();
            }
            if (cipher.type === CipherType.Login && !this.isNullOrWhitespace(item.details.password)) {
                cipher.login.password = item.details.password;
            }
            if (!this.isNullOrWhitespace(item.details.notesPlain)) {
                cipher.notes = item.details.notesPlain.split(this.newLineRegex).join('\n') + '\n';
            }
            if (item.details.fields != null) {
                this.parseFields(item.details.fields, cipher, 'designation', 'value', 'name');
            }
            if (item.details.sections != null) {
                item.details.sections.forEach((section) => {
                    if (section.fields != null) {
                        this.parseFields(section.fields, cipher, 'n', 'v', 't');
                    }
                });
            }
        }
    }
    processStandardItem(item, cipher) {
        cipher.favorite = item.openContents && item.openContents.faveIndex ? true : false;
        cipher.name = this.getValueOrDefault(item.title);
        if (item.typeName === 'securenotes.SecureNote') {
            cipher.type = CipherType.SecureNote;
            cipher.secureNote = new SecureNoteView();
            cipher.secureNote.type = SecureNoteType.Generic;
        }
        else if (item.typeName === 'wallet.financial.CreditCard') {
            cipher.type = CipherType.Card;
            cipher.card = new CardView();
        }
        else if (item.typeName === 'identities.Identity') {
            cipher.type = CipherType.Identity;
            cipher.identity = new identityView_IdentityView();
        }
        else {
            cipher.login.uris = this.makeUriArray(item.location);
        }
        if (item.secureContents != null) {
            if (item.secureContents.passwordHistory != null) {
                this.parsePasswordHistory(item.secureContents.passwordHistory, cipher);
            }
            if (!this.isNullOrWhitespace(item.secureContents.notesPlain)) {
                cipher.notes = item.secureContents.notesPlain.split(this.newLineRegex).join('\n') + '\n';
            }
            if (cipher.type === CipherType.Login) {
                if (!this.isNullOrWhitespace(item.secureContents.password)) {
                    cipher.login.password = item.secureContents.password;
                }
                if (item.secureContents.URLs != null) {
                    const urls = [];
                    item.secureContents.URLs.forEach((u) => {
                        if (!this.isNullOrWhitespace(u.url)) {
                            urls.push(u.url);
                        }
                    });
                    if (urls.length > 0) {
                        cipher.login.uris = this.makeUriArray(urls);
                    }
                }
            }
            if (item.secureContents.fields != null) {
                this.parseFields(item.secureContents.fields, cipher, 'designation', 'value', 'name');
            }
            if (item.secureContents.sections != null) {
                item.secureContents.sections.forEach((section) => {
                    if (section.fields != null) {
                        this.parseFields(section.fields, cipher, 'n', 'v', 't');
                    }
                });
            }
        }
    }
    parsePasswordHistory(items, cipher) {
        const maxSize = items.length > 5 ? 5 : items.length;
        cipher.passwordHistory = items
            .filter((h) => !this.isNullOrWhitespace(h.value) && h.time != null)
            .sort((a, b) => b.time - a.time)
            .slice(0, maxSize)
            .map((h) => {
            const ph = new PasswordHistoryView();
            ph.password = h.value;
            ph.lastUsedDate = new Date(('' + h.time).length >= 13 ? h.time : h.time * 1000);
            return ph;
        });
    }
    parseFields(fields, cipher, designationKey, valueKey, nameKey) {
        fields.forEach((field) => {
            if (field[valueKey] == null || field[valueKey].toString().trim() === '') {
                return;
            }
            const fieldValue = field[valueKey].toString();
            const fieldDesignation = field[designationKey] != null ? field[designationKey].toString() : null;
            if (cipher.type === CipherType.Login) {
                if (this.isNullOrWhitespace(cipher.login.username) && fieldDesignation === 'username') {
                    cipher.login.username = fieldValue;
                    return;
                }
                else if (this.isNullOrWhitespace(cipher.login.password) && fieldDesignation === 'password') {
                    cipher.login.password = fieldValue;
                    return;
                }
                else if (this.isNullOrWhitespace(cipher.login.totp) && fieldDesignation != null &&
                    fieldDesignation.startsWith('TOTP_')) {
                    cipher.login.totp = fieldValue;
                    return;
                }
            }
            else if (cipher.type === CipherType.Card) {
                if (this.isNullOrWhitespace(cipher.card.number) && fieldDesignation === 'ccnum') {
                    cipher.card.number = fieldValue;
                    cipher.card.brand = this.getCardBrand(fieldValue);
                    return;
                }
                else if (this.isNullOrWhitespace(cipher.card.code) && fieldDesignation === 'cvv') {
                    cipher.card.code = fieldValue;
                    return;
                }
                else if (this.isNullOrWhitespace(cipher.card.cardholderName) && fieldDesignation === 'cardholder') {
                    cipher.card.cardholderName = fieldValue;
                    return;
                }
                else if (this.isNullOrWhitespace(cipher.card.expiration) && fieldDesignation === 'expiry' &&
                    fieldValue.length === 6) {
                    cipher.card.expMonth = fieldValue.substr(4, 2);
                    if (cipher.card.expMonth[0] === '0') {
                        cipher.card.expMonth = cipher.card.expMonth.substr(1, 1);
                    }
                    cipher.card.expYear = fieldValue.substr(0, 4);
                    return;
                }
                else if (fieldDesignation === 'type') {
                    // Skip since brand was determined from number above
                    return;
                }
            }
            else if (cipher.type === CipherType.Identity) {
                const identity = cipher.identity;
                if (this.isNullOrWhitespace(identity.firstName) && fieldDesignation === 'firstname') {
                    identity.firstName = fieldValue;
                    return;
                }
                else if (this.isNullOrWhitespace(identity.lastName) && fieldDesignation === 'lastname') {
                    identity.lastName = fieldValue;
                    return;
                }
                else if (this.isNullOrWhitespace(identity.middleName) && fieldDesignation === 'initial') {
                    identity.middleName = fieldValue;
                    return;
                }
                else if (this.isNullOrWhitespace(identity.phone) && fieldDesignation === 'defphone') {
                    identity.phone = fieldValue;
                    return;
                }
                else if (this.isNullOrWhitespace(identity.company) && fieldDesignation === 'company') {
                    identity.company = fieldValue;
                    return;
                }
                else if (this.isNullOrWhitespace(identity.email) && fieldDesignation === 'email') {
                    identity.email = fieldValue;
                    return;
                }
                else if (this.isNullOrWhitespace(identity.username) && fieldDesignation === 'username') {
                    identity.username = fieldValue;
                    return;
                }
                else if (fieldDesignation === 'address') {
                    // fieldValue is an object casted into a string, so access the plain value instead
                    const { street, city, country, zip } = field[valueKey];
                    identity.address1 = this.getValueOrDefault(street);
                    identity.city = this.getValueOrDefault(city);
                    if (!this.isNullOrWhitespace(country)) {
                        identity.country = country.toUpperCase();
                    }
                    identity.postalCode = this.getValueOrDefault(zip);
                    return;
                }
            }
            const fieldName = this.isNullOrWhitespace(field[nameKey]) ? 'no_name' : field[nameKey];
            if (fieldName === 'password' && cipher.passwordHistory != null &&
                cipher.passwordHistory.some((h) => h.password === fieldValue)) {
                return;
            }
            const fieldType = field.k === 'concealed' ? FieldType.Hidden : FieldType.Text;
            this.processKvp(cipher, fieldName, fieldValue, fieldType);
        });
    }
}

// CONCATENATED MODULE: ./jslib/src/models/view/view.ts
class View {
}

// CONCATENATED MODULE: ./jslib/src/models/view/index.ts










// CONCATENATED MODULE: ./jslib/src/importers/onepasswordWinCsvImporter.ts




const IgnoredProperties = ['ainfo', 'autosubmit', 'notesplain', 'ps', 'scope', 'tags', 'title', 'uuid'];
class onepasswordWinCsvImporter_OnePasswordWinCsvImporter extends baseImporter_BaseImporter {
    parse(data) {
        const result = new ImportResult();
        const results = this.parseCsv(data, true);
        if (results == null) {
            result.success = false;
            return result;
        }
        results.forEach((value) => {
            if (this.isNullOrWhitespace(this.getProp(value, 'title'))) {
                return;
            }
            const cipher = this.initLoginCipher();
            cipher.name = this.getValueOrDefault(this.getProp(value, 'title'), '--');
            cipher.notes = this.getValueOrDefault(this.getProp(value, 'notesPlain'), '') + '\n';
            if (!this.isNullOrWhitespace(this.getProp(value, 'number')) &&
                !this.isNullOrWhitespace(this.getProp(value, 'expiry date'))) {
                cipher.type = CipherType.Card;
                cipher.card = new CardView();
            }
            let altUsername = null;
            for (const property in value) {
                if (!value.hasOwnProperty(property) || this.isNullOrWhitespace(value[property])) {
                    continue;
                }
                const lowerProp = property.toLowerCase();
                if (cipher.type === CipherType.Login) {
                    if (this.isNullOrWhitespace(cipher.login.password) && lowerProp === 'password') {
                        cipher.login.password = value[property];
                        continue;
                    }
                    else if (this.isNullOrWhitespace(cipher.login.username) && lowerProp === 'username') {
                        cipher.login.username = value[property];
                        continue;
                    }
                    else if ((cipher.login.uris == null || cipher.login.uri.length === 0) && lowerProp === 'urls') {
                        const urls = value[property].split(this.newLineRegex);
                        cipher.login.uris = this.makeUriArray(urls);
                        continue;
                    }
                }
                else if (cipher.type === CipherType.Card) {
                    if (this.isNullOrWhitespace(cipher.card.number) && lowerProp === 'number') {
                        cipher.card.number = value[property];
                        cipher.card.brand = this.getCardBrand(this.getProp(value, 'number'));
                        continue;
                    }
                    else if (this.isNullOrWhitespace(cipher.card.code) && lowerProp === 'verification number') {
                        cipher.card.code = value[property];
                        continue;
                    }
                    else if (this.isNullOrWhitespace(cipher.card.cardholderName) && lowerProp === 'cardholder name') {
                        cipher.card.cardholderName = value[property];
                        continue;
                    }
                    else if (this.isNullOrWhitespace(cipher.card.expiration) && lowerProp === 'expiry date' &&
                        value[property].length === 6) {
                        cipher.card.expMonth = value[property].substr(4, 2);
                        if (cipher.card.expMonth[0] === '0') {
                            cipher.card.expMonth = cipher.card.expMonth.substr(1, 1);
                        }
                        cipher.card.expYear = value[property].substr(0, 4);
                        continue;
                    }
                    else if (lowerProp === 'type') {
                        // Skip since brand was determined from number above
                        continue;
                    }
                }
                if (IgnoredProperties.indexOf(lowerProp) === -1 && !lowerProp.startsWith('section:') &&
                    !lowerProp.startsWith('section ')) {
                    if (altUsername == null && lowerProp === 'email') {
                        altUsername = value[property];
                    }
                    this.processKvp(cipher, property, value[property]);
                }
            }
            if (cipher.type === CipherType.Login && !this.isNullOrWhitespace(altUsername) &&
                this.isNullOrWhitespace(cipher.login.username) && altUsername.indexOf('://') === -1) {
                cipher.login.username = altUsername;
            }
            this.convertToNoteIfNeeded(cipher);
            this.cleanupCipher(cipher);
            result.ciphers.push(cipher);
        });
        result.success = true;
        return result;
    }
    getProp(obj, name) {
        return obj[name] || obj[name.toUpperCase()];
    }
}

// CONCATENATED MODULE: ./jslib/src/importers/padlockCsvImporter.ts



class padlockCsvImporter_PadlockCsvImporter extends baseImporter_BaseImporter {
    parse(data) {
        const result = new ImportResult();
        const results = this.parseCsv(data, false);
        if (results == null) {
            result.success = false;
            return result;
        }
        let headers = null;
        results.forEach((value) => {
            if (headers == null) {
                headers = value.map((v) => v);
                return;
            }
            if (value.length < 2 || value.length !== headers.length) {
                return;
            }
            if (!this.isNullOrWhitespace(value[1])) {
                if (this.organization) {
                    const tags = value[1].split(',');
                    tags.forEach((tag) => {
                        tag = tag.trim();
                        let addCollection = true;
                        let collectionIndex = result.collections.length;
                        for (let i = 0; i < result.collections.length; i++) {
                            if (result.collections[i].name === tag) {
                                addCollection = false;
                                collectionIndex = i;
                                break;
                            }
                        }
                        if (addCollection) {
                            const collection = new collectionView_CollectionView();
                            collection.name = tag;
                            result.collections.push(collection);
                        }
                        result.collectionRelationships.push([result.ciphers.length, collectionIndex]);
                    });
                }
                else {
                    const tags = value[1].split(',');
                    const tag = tags.length > 0 ? tags[0].trim() : null;
                    this.processFolder(result, tag);
                }
            }
            const cipher = this.initLoginCipher();
            cipher.name = this.getValueOrDefault(value[0], '--');
            for (let i = 2; i < value.length; i++) {
                const header = headers[i].trim().toLowerCase();
                if (this.isNullOrWhitespace(value[i]) || this.isNullOrWhitespace(header)) {
                    continue;
                }
                if (this.usernameFieldNames.indexOf(header) > -1) {
                    cipher.login.username = value[i];
                }
                else if (this.passwordFieldNames.indexOf(header) > -1) {
                    cipher.login.password = value[i];
                }
                else if (this.uriFieldNames.indexOf(header) > -1) {
                    cipher.login.uris = this.makeUriArray(value[i]);
                }
                else {
                    this.processKvp(cipher, headers[i], value[i]);
                }
            }
            this.cleanupCipher(cipher);
            result.ciphers.push(cipher);
        });
        result.success = true;
        return result;
    }
}

// CONCATENATED MODULE: ./jslib/src/importers/passkeepCsvImporter.ts


class passkeepCsvImporter_PassKeepCsvImporter extends baseImporter_BaseImporter {
    parse(data) {
        const result = new ImportResult();
        const results = this.parseCsv(data, true);
        if (results == null) {
            result.success = false;
            return result;
        }
        results.forEach((value) => {
            this.processFolder(result, this.getValue('category', value));
            const cipher = this.initLoginCipher();
            cipher.notes = this.getValue('description', value);
            cipher.name = this.getValueOrDefault(this.getValue('title', value), '--');
            cipher.login.username = this.getValue('username', value);
            cipher.login.password = this.getValue('password', value);
            cipher.login.uris = this.makeUriArray(this.getValue('site', value));
            this.processKvp(cipher, 'Password 2', this.getValue('password2', value));
            this.cleanupCipher(cipher);
            result.ciphers.push(cipher);
        });
        if (this.organization) {
            this.moveFoldersToCollections(result);
        }
        result.success = true;
        return result;
    }
    getValue(key, value) {
        return this.getValueOrDefault(value[key], this.getValueOrDefault(value[(' ' + key)]));
    }
}

// CONCATENATED MODULE: ./jslib/src/importers/passmanJsonImporter.ts


class passmanJsonImporter_PassmanJsonImporter extends baseImporter_BaseImporter {
    parse(data) {
        const result = new ImportResult();
        const results = JSON.parse(data);
        if (results == null || results.length === 0) {
            result.success = false;
            return result;
        }
        results.forEach((credential) => {
            if (credential.tags != null && credential.tags.length > 0) {
                const folderName = credential.tags[0].text;
                this.processFolder(result, folderName);
            }
            const cipher = this.initLoginCipher();
            cipher.name = credential.label;
            cipher.login.username = this.getValueOrDefault(credential.username);
            if (this.isNullOrWhitespace(cipher.login.username)) {
                cipher.login.username = this.getValueOrDefault(credential.email);
            }
            else if (!this.isNullOrWhitespace(credential.email)) {
                cipher.notes = ('Email: ' + credential.email + '\n');
            }
            cipher.login.password = this.getValueOrDefault(credential.password);
            cipher.login.uris = this.makeUriArray(credential.url);
            cipher.notes += this.getValueOrDefault(credential.description, '');
            if (credential.otp != null) {
                cipher.login.totp = this.getValueOrDefault(credential.otp.secret);
            }
            if (credential.custom_fields != null) {
                credential.custom_fields.forEach((customField) => {
                    switch (customField.field_type) {
                        case 'text':
                        case 'password':
                            this.processKvp(cipher, customField.label, customField.value);
                            break;
                    }
                });
            }
            this.convertToNoteIfNeeded(cipher);
            this.cleanupCipher(cipher);
            result.ciphers.push(cipher);
        });
        if (this.organization) {
            this.moveFoldersToCollections(result);
        }
        result.success = true;
        return result;
    }
}

// CONCATENATED MODULE: ./jslib/src/importers/passpackCsvImporter.ts



class passpackCsvImporter_PasspackCsvImporter extends baseImporter_BaseImporter {
    parse(data) {
        const result = new ImportResult();
        const results = this.parseCsv(data, true);
        if (results == null) {
            result.success = false;
            return result;
        }
        results.forEach((value) => {
            const tagsJson = !this.isNullOrWhitespace(value.Tags) ? JSON.parse(value.Tags) : null;
            const tags = tagsJson != null && tagsJson.tags != null && tagsJson.tags.length > 0 ?
                tagsJson.tags.map((tagJson) => {
                    try {
                        const t = JSON.parse(tagJson);
                        return this.getValueOrDefault(t.tag);
                    }
                    catch (_a) { }
                    return null;
                }).filter((t) => !this.isNullOrWhitespace(t)) : null;
            if (this.organization && tags != null && tags.length > 0) {
                tags.forEach((tag) => {
                    let addCollection = true;
                    let collectionIndex = result.collections.length;
                    for (let i = 0; i < result.collections.length; i++) {
                        if (result.collections[i].name === tag) {
                            addCollection = false;
                            collectionIndex = i;
                            break;
                        }
                    }
                    if (addCollection) {
                        const collection = new collectionView_CollectionView();
                        collection.name = tag;
                        result.collections.push(collection);
                    }
                    result.collectionRelationships.push([result.ciphers.length, collectionIndex]);
                });
            }
            else if (!this.organization && tags != null && tags.length > 0) {
                this.processFolder(result, tags[0]);
            }
            const cipher = this.initLoginCipher();
            cipher.notes = this.getValueOrDefault(value.Notes, '');
            cipher.notes += ('\n\n' + this.getValueOrDefault(value['Shared Notes'], '') + '\n');
            cipher.name = this.getValueOrDefault(value['Entry Name'], '--');
            cipher.login.username = this.getValueOrDefault(value['User ID']);
            cipher.login.password = this.getValueOrDefault(value.Password);
            cipher.login.uris = this.makeUriArray(value.URL);
            if (value.__parsed_extra != null && value.__parsed_extra.length > 0) {
                value.__parsed_extra.forEach((extra) => {
                    if (!this.isNullOrWhitespace(extra)) {
                        cipher.notes += ('\n' + extra);
                    }
                });
            }
            const fieldsJson = !this.isNullOrWhitespace(value['Extra Fields']) ?
                JSON.parse(value['Extra Fields']) : null;
            const fields = fieldsJson != null && fieldsJson.extraFields != null &&
                fieldsJson.extraFields.length > 0 ? fieldsJson.extraFields.map((fieldJson) => {
                try {
                    return JSON.parse(fieldJson);
                }
                catch (_a) { }
                return null;
            }) : null;
            if (fields != null) {
                fields.forEach((f) => {
                    if (f != null) {
                        this.processKvp(cipher, f.name, f.data);
                    }
                });
            }
            this.cleanupCipher(cipher);
            result.ciphers.push(cipher);
        });
        result.success = true;
        return result;
    }
}

// CONCATENATED MODULE: ./jslib/src/importers/passwordAgentCsvImporter.ts


class passwordAgentCsvImporter_PasswordAgentCsvImporter extends baseImporter_BaseImporter {
    parse(data) {
        const result = new ImportResult();
        const results = this.parseCsv(data, false);
        if (results == null) {
            result.success = false;
            return result;
        }
        let newVersion = true;
        results.forEach((value) => {
            if (value.length !== 5 && value.length < 9) {
                return;
            }
            const altFormat = value.length === 10 && value[0] === '0';
            const cipher = this.initLoginCipher();
            cipher.name = this.getValueOrDefault(value[altFormat ? 1 : 0], '--');
            cipher.login.username = this.getValueOrDefault(value[altFormat ? 2 : 1]);
            cipher.login.password = this.getValueOrDefault(value[altFormat ? 3 : 2]);
            if (value.length === 5) {
                newVersion = false;
                cipher.notes = this.getValueOrDefault(value[4]);
                cipher.login.uris = this.makeUriArray(value[3]);
            }
            else {
                const folder = this.getValueOrDefault(value[altFormat ? 9 : 8], '(None)');
                let folderName = folder !== '(None)' ? folder.split('\\').join('/') : null;
                if (folderName != null) {
                    folderName = folder.split(' > ').join('/');
                    folderName = folder.split('>').join('/');
                }
                this.processFolder(result, folderName);
                cipher.notes = this.getValueOrDefault(value[altFormat ? 5 : 3]);
                cipher.login.uris = this.makeUriArray(value[4]);
            }
            this.convertToNoteIfNeeded(cipher);
            this.cleanupCipher(cipher);
            result.ciphers.push(cipher);
        });
        if (newVersion && this.organization) {
            this.moveFoldersToCollections(result);
        }
        result.success = true;
        return result;
    }
}

// CONCATENATED MODULE: ./jslib/src/importers/passwordBossJsonImporter.ts





class passwordBossJsonImporter_PasswordBossJsonImporter extends baseImporter_BaseImporter {
    parse(data) {
        const result = new ImportResult();
        const results = JSON.parse(data);
        if (results == null || results.items == null) {
            result.success = false;
            return result;
        }
        const foldersMap = new Map();
        results.folders.forEach((value) => {
            foldersMap.set(value.id, value.name);
        });
        const foldersIndexMap = new Map();
        foldersMap.forEach((val, key) => {
            foldersIndexMap.set(key, result.folders.length);
            const f = new FolderView();
            f.name = val;
            result.folders.push(f);
        });
        results.items.forEach((value) => {
            const cipher = this.initLoginCipher();
            cipher.name = this.getValueOrDefault(value.name, '--');
            cipher.login.uris = this.makeUriArray(value.login_url);
            if (value.folder != null && foldersIndexMap.has(value.folder)) {
                result.folderRelationships.push([result.ciphers.length, foldersIndexMap.get(value.folder)]);
            }
            if (value.identifiers == null) {
                return;
            }
            if (!this.isNullOrWhitespace(value.identifiers.notes)) {
                cipher.notes = value.identifiers.notes.split('\\r\\n').join('\n').split('\\n').join('\n');
            }
            if (value.type === 'CreditCard') {
                cipher.card = new CardView();
                cipher.type = CipherType.Card;
            }
            for (const property in value.identifiers) {
                if (!value.identifiers.hasOwnProperty(property)) {
                    continue;
                }
                const valObj = value.identifiers[property];
                const val = valObj != null ? valObj.toString() : null;
                if (this.isNullOrWhitespace(val) || property === 'notes' || property === 'ignoreItemInSecurityScore') {
                    continue;
                }
                if (property === 'custom_fields') {
                    valObj.forEach((cf) => {
                        this.processKvp(cipher, cf.name, cf.value);
                    });
                    continue;
                }
                if (cipher.type === CipherType.Card) {
                    if (property === 'cardNumber') {
                        cipher.card.number = val;
                        cipher.card.brand = this.getCardBrand(val);
                        continue;
                    }
                    else if (property === 'nameOnCard') {
                        cipher.card.cardholderName = val;
                        continue;
                    }
                    else if (property === 'security_code') {
                        cipher.card.code = val;
                        continue;
                    }
                    else if (property === 'expires') {
                        try {
                            const expDate = new Date(val);
                            cipher.card.expYear = expDate.getFullYear().toString();
                            cipher.card.expMonth = (expDate.getMonth() + 1).toString();
                        }
                        catch (_a) { }
                        continue;
                    }
                    else if (property === 'cardType') {
                        continue;
                    }
                }
                else {
                    if ((property === 'username' || property === 'email') &&
                        this.isNullOrWhitespace(cipher.login.username)) {
                        cipher.login.username = val;
                        continue;
                    }
                    else if (property === 'password') {
                        cipher.login.password = val;
                        continue;
                    }
                    else if (property === 'totp') {
                        cipher.login.totp = val;
                        continue;
                    }
                    else if ((cipher.login.uris == null || cipher.login.uris.length === 0) &&
                        this.uriFieldNames.indexOf(property) > -1) {
                        cipher.login.uris = this.makeUriArray(val);
                        continue;
                    }
                }
                this.processKvp(cipher, property, val);
            }
            this.convertToNoteIfNeeded(cipher);
            this.cleanupCipher(cipher);
            result.ciphers.push(cipher);
        });
        result.success = true;
        return result;
    }
}

// CONCATENATED MODULE: ./jslib/src/importers/passwordDragonXmlImporter.ts


class passwordDragonXmlImporter_PasswordDragonXmlImporter extends baseImporter_BaseImporter {
    parse(data) {
        const result = new ImportResult();
        const doc = this.parseXml(data);
        if (doc == null) {
            result.success = false;
            return result;
        }
        const records = doc.querySelectorAll('PasswordManager > record');
        Array.from(records).forEach((record) => {
            const category = this.querySelectorDirectChild(record, 'Category');
            const categoryText = category != null && !this.isNullOrWhitespace(category.textContent) &&
                category.textContent !== 'Unfiled' ? category.textContent : null;
            this.processFolder(result, categoryText);
            const accountName = this.querySelectorDirectChild(record, 'Account-Name');
            const userId = this.querySelectorDirectChild(record, 'User-Id');
            const password = this.querySelectorDirectChild(record, 'Password');
            const url = this.querySelectorDirectChild(record, 'URL');
            const notes = this.querySelectorDirectChild(record, 'Notes');
            const cipher = this.initLoginCipher();
            cipher.name = accountName != null ? this.getValueOrDefault(accountName.textContent, '--') : '--';
            cipher.notes = notes != null ? this.getValueOrDefault(notes.textContent) : '';
            cipher.login.username = userId != null ? this.getValueOrDefault(userId.textContent) : null;
            cipher.login.password = password != null ? this.getValueOrDefault(password.textContent) : null;
            cipher.login.uris = url != null ? this.makeUriArray(url.textContent) : null;
            const attributes = [];
            for (let i = 1; i <= 10; i++) {
                attributes.push('Attribute-' + i);
            }
            this.querySelectorAllDirectChild(record, attributes.join(',')).forEach((attr) => {
                if (this.isNullOrWhitespace(attr.textContent) || attr.textContent === 'null') {
                    return;
                }
                this.processKvp(cipher, attr.tagName, attr.textContent);
            });
            this.cleanupCipher(cipher);
            result.ciphers.push(cipher);
        });
        if (this.organization) {
            this.moveFoldersToCollections(result);
        }
        result.success = true;
        return result;
    }
}

// CONCATENATED MODULE: ./jslib/src/importers/passwordSafeXmlImporter.ts


class passwordSafeXmlImporter_PasswordSafeXmlImporter extends baseImporter_BaseImporter {
    parse(data) {
        const result = new ImportResult();
        const doc = this.parseXml(data);
        if (doc == null) {
            result.success = false;
            return result;
        }
        const passwordSafe = doc.querySelector('passwordsafe');
        if (passwordSafe == null) {
            result.errorMessage = 'Missing `passwordsafe` node.';
            result.success = false;
            return result;
        }
        const notesDelimiter = passwordSafe.getAttribute('delimiter');
        const entries = doc.querySelectorAll('passwordsafe > entry');
        Array.from(entries).forEach((entry) => {
            const group = this.querySelectorDirectChild(entry, 'group');
            const groupText = group != null && !this.isNullOrWhitespace(group.textContent) ?
                group.textContent.split('.').join('/') : null;
            this.processFolder(result, groupText);
            const title = this.querySelectorDirectChild(entry, 'title');
            const username = this.querySelectorDirectChild(entry, 'username');
            const email = this.querySelectorDirectChild(entry, 'email');
            const password = this.querySelectorDirectChild(entry, 'password');
            const url = this.querySelectorDirectChild(entry, 'url');
            const notes = this.querySelectorDirectChild(entry, 'notes');
            const cipher = this.initLoginCipher();
            cipher.name = title != null ? this.getValueOrDefault(title.textContent, '--') : '--';
            cipher.notes = notes != null ?
                this.getValueOrDefault(notes.textContent, '').split(notesDelimiter).join('\n') : null;
            cipher.login.username = username != null ? this.getValueOrDefault(username.textContent) : null;
            cipher.login.password = password != null ? this.getValueOrDefault(password.textContent) : null;
            cipher.login.uris = url != null ? this.makeUriArray(url.textContent) : null;
            if (this.isNullOrWhitespace(cipher.login.username) && email != null) {
                cipher.login.username = this.getValueOrDefault(email.textContent);
            }
            else if (email != null && !this.isNullOrWhitespace(email.textContent)) {
                cipher.notes = this.isNullOrWhitespace(cipher.notes) ? 'Email: ' + email.textContent
                    : (cipher.notes + '\n' + 'Email: ' + email.textContent);
            }
            this.cleanupCipher(cipher);
            result.ciphers.push(cipher);
        });
        if (this.organization) {
            this.moveFoldersToCollections(result);
        }
        result.success = true;
        return result;
    }
}

// CONCATENATED MODULE: ./jslib/src/importers/passwordWalletTxtImporter.ts


class passwordWalletTxtImporter_PasswordWalletTxtImporter extends baseImporter_BaseImporter {
    parse(data) {
        const result = new ImportResult();
        const results = this.parseCsv(data, false);
        if (results == null) {
            result.success = false;
            return result;
        }
        results.forEach((value) => {
            if (value.length < 1) {
                return;
            }
            if (value.length > 5) {
                this.processFolder(result, value[5]);
            }
            const cipher = this.initLoginCipher();
            cipher.name = this.getValueOrDefault(value[0], '--');
            if (value.length > 4) {
                cipher.notes = this.getValueOrDefault(value[4], '').split('¬').join('\n');
            }
            if (value.length > 2) {
                cipher.login.username = this.getValueOrDefault(value[2]);
            }
            if (value.length > 3) {
                cipher.login.password = this.getValueOrDefault(value[3]);
            }
            if (value.length > 1) {
                cipher.login.uris = this.makeUriArray(value[1]);
            }
            this.cleanupCipher(cipher);
            result.ciphers.push(cipher);
        });
        if (this.organization) {
            this.moveFoldersToCollections(result);
        }
        result.success = true;
        return result;
    }
}

// CONCATENATED MODULE: ./jslib/src/importers/rememBearCsvImporter.ts




class rememBearCsvImporter_RememBearCsvImporter extends baseImporter_BaseImporter {
    parse(data) {
        const result = new ImportResult();
        const results = this.parseCsv(data, true);
        if (results == null) {
            result.success = false;
            return result;
        }
        results.forEach((value) => {
            if (value.trash === 'true') {
                return;
            }
            const cipher = this.initLoginCipher();
            cipher.name = this.getValueOrDefault(value.name);
            cipher.notes = this.getValueOrDefault(value.notes);
            if (value.type === 'LoginItem') {
                cipher.login.uris = this.makeUriArray(value.website);
                cipher.login.password = this.getValueOrDefault(value.password);
                cipher.login.username = this.getValueOrDefault(value.username);
            }
            else if (value.type === 'CreditCardItem') {
                cipher.type = CipherType.Card;
                cipher.card = new CardView();
                cipher.card.cardholderName = this.getValueOrDefault(value.cardholder);
                cipher.card.number = this.getValueOrDefault(value.number);
                cipher.card.brand = this.getCardBrand(cipher.card.number);
                cipher.card.code = this.getValueOrDefault(value.verification);
                try {
                    const expMonth = this.getValueOrDefault(value.expiryMonth);
                    if (expMonth != null) {
                        const expMonthNumber = parseInt(expMonth, null);
                        if (expMonthNumber != null && expMonthNumber >= 1 && expMonthNumber <= 12) {
                            cipher.card.expMonth = expMonthNumber.toString();
                        }
                    }
                }
                catch (_a) { }
                try {
                    const expYear = this.getValueOrDefault(value.expiryYear);
                    if (expYear != null) {
                        const expYearNumber = parseInt(expYear, null);
                        if (expYearNumber != null) {
                            cipher.card.expYear = expYearNumber.toString();
                        }
                    }
                }
                catch (_b) { }
                const pin = this.getValueOrDefault(value.pin);
                if (pin != null) {
                    this.processKvp(cipher, 'PIN', pin);
                }
                const zip = this.getValueOrDefault(value.zipCode);
                if (zip != null) {
                    this.processKvp(cipher, 'Zip Code', zip);
                }
            }
            this.cleanupCipher(cipher);
            result.ciphers.push(cipher);
        });
        result.success = true;
        return result;
    }
}

// CONCATENATED MODULE: ./jslib/src/importers/roboformCsvImporter.ts


class roboformCsvImporter_RoboFormCsvImporter extends baseImporter_BaseImporter {
    parse(data) {
        const result = new ImportResult();
        const results = this.parseCsv(data, true);
        if (results == null) {
            result.success = false;
            return result;
        }
        let i = 1;
        results.forEach((value) => {
            const folder = !this.isNullOrWhitespace(value.Folder) && value.Folder.startsWith('/') ?
                value.Folder.replace('/', '') : value.Folder;
            const folderName = !this.isNullOrWhitespace(folder) ? folder : null;
            this.processFolder(result, folderName);
            const cipher = this.initLoginCipher();
            cipher.notes = this.getValueOrDefault(value.Note);
            cipher.name = this.getValueOrDefault(value.Name, '--');
            cipher.login.username = this.getValueOrDefault(value.Login);
            cipher.login.password = this.getValueOrDefault(value.Pwd);
            cipher.login.uris = this.makeUriArray(value.Url);
            if (!this.isNullOrWhitespace(value.Rf_fields)) {
                let fields = [value.Rf_fields];
                if (value.__parsed_extra != null && value.__parsed_extra.length > 0) {
                    fields = fields.concat(value.__parsed_extra);
                }
                fields.forEach((field) => {
                    const parts = field.split(':');
                    if (parts.length < 3) {
                        return;
                    }
                    const key = parts[0] === '-no-name-' ? null : parts[0];
                    const val = parts.length === 4 && parts[2] === 'rck' ? parts[1] : parts[2];
                    this.processKvp(cipher, key, val);
                });
            }
            this.convertToNoteIfNeeded(cipher);
            this.cleanupCipher(cipher);
            if (i === results.length && cipher.name === '--' && this.isNullOrWhitespace(cipher.login.password)) {
                return;
            }
            result.ciphers.push(cipher);
            i++;
        });
        if (this.organization) {
            this.moveFoldersToCollections(result);
        }
        result.success = true;
        return result;
    }
}

// CONCATENATED MODULE: ./jslib/src/importers/safeInCloudXmlImporter.ts






class safeInCloudXmlImporter_SafeInCloudXmlImporter extends baseImporter_BaseImporter {
    parse(data) {
        const result = new ImportResult();
        const doc = this.parseXml(data);
        if (doc == null) {
            result.success = false;
            return result;
        }
        const db = doc.querySelector('database');
        if (db == null) {
            result.errorMessage = 'Missing `database` node.';
            result.success = false;
            return result;
        }
        const foldersMap = new Map();
        Array.from(doc.querySelectorAll('database > label')).forEach((labelEl) => {
            const name = labelEl.getAttribute('name');
            const id = labelEl.getAttribute('id');
            if (!this.isNullOrWhitespace(name) && !this.isNullOrWhitespace(id)) {
                foldersMap.set(id, result.folders.length);
                const folder = new FolderView();
                folder.name = name;
                result.folders.push(folder);
            }
        });
        Array.from(doc.querySelectorAll('database > card')).forEach((cardEl) => {
            if (cardEl.getAttribute('template') === 'true') {
                return;
            }
            const labelIdEl = this.querySelectorDirectChild(cardEl, 'label_id');
            if (labelIdEl != null) {
                const labelId = labelIdEl.textContent;
                if (!this.isNullOrWhitespace(labelId) && foldersMap.has(labelId)) {
                    result.folderRelationships.push([result.ciphers.length, foldersMap.get(labelId)]);
                }
            }
            const cipher = this.initLoginCipher();
            cipher.name = this.getValueOrDefault(cardEl.getAttribute('title'), '--');
            const cardType = cardEl.getAttribute('type');
            if (cardType === 'note') {
                cipher.type = CipherType.SecureNote;
                cipher.secureNote = new SecureNoteView();
                cipher.secureNote.type = SecureNoteType.Generic;
            }
            else {
                Array.from(this.querySelectorAllDirectChild(cardEl, 'field')).forEach((fieldEl) => {
                    const text = fieldEl.textContent;
                    if (this.isNullOrWhitespace(text)) {
                        return;
                    }
                    const name = fieldEl.getAttribute('name');
                    const fieldType = this.getValueOrDefault(fieldEl.getAttribute('type'), '').toLowerCase();
                    if (fieldType === 'login') {
                        cipher.login.username = text;
                    }
                    else if (fieldType === 'password') {
                        cipher.login.password = text;
                    }
                    else if (fieldType === 'one_time_password') {
                        cipher.login.totp = text;
                    }
                    else if (fieldType === 'notes') {
                        cipher.notes += (text + '\n');
                    }
                    else if (fieldType === 'weblogin' || fieldType === 'website') {
                        cipher.login.uris = this.makeUriArray(text);
                    }
                    else {
                        this.processKvp(cipher, name, text);
                    }
                });
            }
            Array.from(this.querySelectorAllDirectChild(cardEl, 'notes')).forEach((notesEl) => {
                cipher.notes += (notesEl.textContent + '\n');
            });
            this.cleanupCipher(cipher);
            result.ciphers.push(cipher);
        });
        if (this.organization) {
            this.moveFoldersToCollections(result);
        }
        result.success = true;
        return result;
    }
}

// CONCATENATED MODULE: ./jslib/src/importers/saferpassCsvImport.ts


class saferpassCsvImport_SaferPassCsvImporter extends baseImporter_BaseImporter {
    parse(data) {
        const result = new ImportResult();
        const results = this.parseCsv(data, true);
        if (results == null) {
            result.success = false;
            return result;
        }
        results.forEach((value) => {
            const cipher = this.initLoginCipher();
            cipher.name = this.getValueOrDefault(this.nameFromUrl(value.url), '--');
            cipher.notes = this.getValueOrDefault(value.notes);
            cipher.login.username = this.getValueOrDefault(value.username);
            cipher.login.password = this.getValueOrDefault(value.password);
            cipher.login.uris = this.makeUriArray(value.url);
            this.cleanupCipher(cipher);
            result.ciphers.push(cipher);
        });
        result.success = true;
        return result;
    }
}

// CONCATENATED MODULE: ./jslib/src/importers/secureSafeCsvImporter.ts


class secureSafeCsvImporter_SecureSafeCsvImporter extends baseImporter_BaseImporter {
    parse(data) {
        const result = new ImportResult();
        const results = this.parseCsv(data, true);
        if (results == null) {
            result.success = false;
            return result;
        }
        results.forEach((value) => {
            const cipher = this.initLoginCipher();
            cipher.name = this.getValueOrDefault(value.Title);
            cipher.notes = this.getValueOrDefault(value.Comment);
            cipher.login.uris = this.makeUriArray(value.Url);
            cipher.login.password = this.getValueOrDefault(value.Password);
            cipher.login.username = this.getValueOrDefault(value.Username);
            this.cleanupCipher(cipher);
            result.ciphers.push(cipher);
        });
        result.success = true;
        return result;
    }
}

// CONCATENATED MODULE: ./jslib/src/importers/splashIdCsvImporter.ts


class splashIdCsvImporter_SplashIdCsvImporter extends baseImporter_BaseImporter {
    parse(data) {
        const result = new ImportResult();
        const results = this.parseCsv(data, false);
        if (results == null) {
            result.success = false;
            return result;
        }
        results.forEach((value) => {
            if (value.length < 3) {
                return;
            }
            this.processFolder(result, this.getValueOrDefault(value[value.length - 1]));
            const cipher = this.initLoginCipher();
            cipher.notes = this.getValueOrDefault(value[value.length - 2], '');
            cipher.name = this.getValueOrDefault(value[1], '--');
            if (value[0] === 'Web Logins' || value[0] === 'Servers' || value[0] === 'Email Accounts') {
                cipher.login.username = this.getValueOrDefault(value[2]);
                cipher.login.password = this.getValueOrDefault(value[3]);
                cipher.login.uris = this.makeUriArray(value[4]);
                this.parseFieldsToNotes(cipher, 5, value);
            }
            else {
                this.parseFieldsToNotes(cipher, 2, value);
            }
            this.convertToNoteIfNeeded(cipher);
            this.cleanupCipher(cipher);
            result.ciphers.push(cipher);
        });
        if (this.organization) {
            this.moveFoldersToCollections(result);
        }
        result.success = true;
        return result;
    }
    parseFieldsToNotes(cipher, startIndex, value) {
        // last 3 rows do not get parsed
        for (let i = startIndex; i < value.length - 3; i++) {
            if (this.isNullOrWhitespace(value[i])) {
                continue;
            }
            cipher.notes += (value[i] + '\n');
        }
    }
}

// CONCATENATED MODULE: ./jslib/src/importers/stickyPasswordXmlImporter.ts


class stickyPasswordXmlImporter_StickyPasswordXmlImporter extends baseImporter_BaseImporter {
    parse(data) {
        const result = new ImportResult();
        const doc = this.parseXml(data);
        if (doc == null) {
            result.success = false;
            return result;
        }
        const loginNodes = doc.querySelectorAll('root > Database > Logins > Login');
        Array.from(loginNodes).forEach((loginNode) => {
            const accountId = loginNode.getAttribute('ID');
            if (this.isNullOrWhitespace(accountId)) {
                return;
            }
            const usernameText = loginNode.getAttribute('Name');
            const passwordText = loginNode.getAttribute('Password');
            let titleText = null;
            let linkText = null;
            let notesText = null;
            let groupId = null;
            let groupText = null;
            const accountLogin = doc.querySelector('root > Database > Accounts > Account > ' +
                'LoginLinks > Login[SourceLoginID="' + accountId + '"]');
            if (accountLogin != null) {
                const account = accountLogin.parentElement.parentElement;
                if (account != null) {
                    titleText = account.getAttribute('Name');
                    linkText = account.getAttribute('Link');
                    groupId = account.getAttribute('ParentID');
                    notesText = account.getAttribute('Comments');
                    if (!this.isNullOrWhitespace(notesText)) {
                        notesText = notesText.split('/n').join('\n');
                    }
                }
            }
            if (!this.isNullOrWhitespace(groupId)) {
                groupText = this.buildGroupText(doc, groupId, '');
                this.processFolder(result, groupText);
            }
            const cipher = this.initLoginCipher();
            cipher.name = this.getValueOrDefault(titleText, '--');
            cipher.notes = this.getValueOrDefault(notesText);
            cipher.login.username = this.getValueOrDefault(usernameText);
            cipher.login.password = this.getValueOrDefault(passwordText);
            cipher.login.uris = this.makeUriArray(linkText);
            this.cleanupCipher(cipher);
            result.ciphers.push(cipher);
        });
        if (this.organization) {
            this.moveFoldersToCollections(result);
        }
        result.success = true;
        return result;
    }
    buildGroupText(doc, groupId, groupText) {
        const group = doc.querySelector('root > Database > Groups > Group[ID="' + groupId + '"]');
        if (group == null) {
            return groupText;
        }
        if (!this.isNullOrWhitespace(groupText)) {
            groupText = '/' + groupText;
        }
        groupText = group.getAttribute('Name') + groupText;
        return this.buildGroupText(doc, group.getAttribute('ParentID'), groupText);
    }
}

// CONCATENATED MODULE: ./jslib/src/importers/truekeyCsvImporter.ts






const PropertiesToIgnore = ['kind', 'autologin', 'favorite', 'hexcolor', 'protectedwithpassword', 'subdomainonly',
    'type', 'tk_export_version', 'note', 'title', 'document_content',
];
class truekeyCsvImporter_TrueKeyCsvImporter extends baseImporter_BaseImporter {
    parse(data) {
        const result = new ImportResult();
        const results = this.parseCsv(data, true);
        if (results == null) {
            result.success = false;
            return result;
        }
        results.forEach((value) => {
            const cipher = this.initLoginCipher();
            cipher.favorite = this.getValueOrDefault(value.favorite, '').toLowerCase() === 'true';
            cipher.name = this.getValueOrDefault(value.name, '--');
            cipher.notes = this.getValueOrDefault(value.memo, '');
            cipher.login.username = this.getValueOrDefault(value.login);
            cipher.login.password = this.getValueOrDefault(value.password);
            cipher.login.uris = this.makeUriArray(value.url);
            if (value.kind !== 'login') {
                cipher.name = this.getValueOrDefault(value.title, '--');
                cipher.notes = this.getValueOrDefault(value.note, '');
            }
            if (value.kind === 'cc') {
                cipher.type = CipherType.Card;
                cipher.card = new CardView();
                cipher.card.cardholderName = this.getValueOrDefault(value.cardholder);
                cipher.card.number = this.getValueOrDefault(value.number);
                cipher.card.brand = this.getCardBrand(cipher.card.number);
                if (!this.isNullOrWhitespace(value.expiryDate)) {
                    try {
                        const expDate = new Date(value.expiryDate);
                        cipher.card.expYear = expDate.getFullYear().toString();
                        cipher.card.expMonth = (expDate.getMonth() + 1).toString();
                    }
                    catch (_a) { }
                }
            }
            else if (value.kind !== 'login') {
                cipher.type = CipherType.SecureNote;
                cipher.secureNote = new SecureNoteView();
                cipher.secureNote.type = SecureNoteType.Generic;
                if (!this.isNullOrWhitespace(cipher.notes)) {
                    cipher.notes = this.getValueOrDefault(value.document_content, '');
                }
                for (const property in value) {
                    if (value.hasOwnProperty(property) && PropertiesToIgnore.indexOf(property.toLowerCase()) < 0 &&
                        !this.isNullOrWhitespace(value[property])) {
                        this.processKvp(cipher, property, value[property]);
                    }
                }
            }
            this.cleanupCipher(cipher);
            result.ciphers.push(cipher);
        });
        result.success = true;
        return result;
    }
}

// CONCATENATED MODULE: ./jslib/src/importers/upmCsvImporter.ts


class upmCsvImporter_UpmCsvImporter extends baseImporter_BaseImporter {
    parse(data) {
        const result = new ImportResult();
        const results = this.parseCsv(data, false);
        if (results == null) {
            result.success = false;
            return result;
        }
        results.forEach((value) => {
            if (value.length !== 5) {
                return;
            }
            const cipher = this.initLoginCipher();
            cipher.name = this.getValueOrDefault(value[0], '--');
            cipher.notes = this.getValueOrDefault(value[4]);
            cipher.login.username = this.getValueOrDefault(value[1]);
            cipher.login.password = this.getValueOrDefault(value[2]);
            cipher.login.uris = this.makeUriArray(value[3]);
            this.cleanupCipher(cipher);
            result.ciphers.push(cipher);
        });
        result.success = true;
        return result;
    }
}

// CONCATENATED MODULE: ./jslib/src/importers/zohoVaultCsvImporter.ts


class zohoVaultCsvImporter_ZohoVaultCsvImporter extends baseImporter_BaseImporter {
    parse(data) {
        const result = new ImportResult();
        const results = this.parseCsv(data, true);
        if (results == null) {
            result.success = false;
            return result;
        }
        results.forEach((value) => {
            if (this.isNullOrWhitespace(value['Password Name']) && this.isNullOrWhitespace(value['Secret Name'])) {
                return;
            }
            this.processFolder(result, this.getValueOrDefault(value.ChamberName));
            const cipher = this.initLoginCipher();
            cipher.favorite = this.getValueOrDefault(value.Favorite, '0') === '1';
            cipher.notes = this.getValueOrDefault(value.Notes);
            cipher.name = this.getValueOrDefault(value['Password Name'], this.getValueOrDefault(value['Secret Name'], '--'));
            cipher.login.uris = this.makeUriArray(this.getValueOrDefault(value['Password URL'], this.getValueOrDefault(value['Secret URL'])));
            this.parseData(cipher, value.SecretData);
            this.parseData(cipher, value.CustomData);
            this.convertToNoteIfNeeded(cipher);
            this.cleanupCipher(cipher);
            result.ciphers.push(cipher);
        });
        if (this.organization) {
            this.moveFoldersToCollections(result);
        }
        result.success = true;
        return result;
    }
    parseData(cipher, data) {
        if (this.isNullOrWhitespace(data)) {
            return;
        }
        const dataLines = this.splitNewLine(data);
        dataLines.forEach((line) => {
            const delimPosition = line.indexOf(':');
            if (delimPosition < 0) {
                return;
            }
            const field = line.substring(0, delimPosition);
            const value = line.length > delimPosition ? line.substring(delimPosition + 1) : null;
            if (this.isNullOrWhitespace(field) || this.isNullOrWhitespace(value) || field === 'SecretType') {
                return;
            }
            const fieldLower = field.toLowerCase();
            if (cipher.login.username == null && this.usernameFieldNames.indexOf(fieldLower) > -1) {
                cipher.login.username = value;
            }
            else if (cipher.login.password == null && this.passwordFieldNames.indexOf(fieldLower) > -1) {
                cipher.login.password = value;
            }
            else {
                this.processKvp(cipher, field, value);
            }
        });
    }
}

// CONCATENATED MODULE: ./jslib/src/services/import.service.ts
var import_service_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};

























































class import_service_ImportService {
    constructor(cipherService, folderService, apiService, i18nService, collectionService) {
        this.cipherService = cipherService;
        this.folderService = folderService;
        this.apiService = apiService;
        this.i18nService = i18nService;
        this.collectionService = collectionService;
        this.featuredImportOptions = [
            { id: 'bitwardenjson', name: 'Bitwarden (json)' },
            { id: 'bitwardencsv', name: 'Bitwarden (csv)' },
            { id: 'lastpasscsv', name: 'LastPass (csv)' },
            { id: 'chromecsv', name: 'Chrome (csv)' },
            { id: 'firefoxcsv', name: 'Firefox (csv)' },
            { id: 'keepass2xml', name: 'KeePass 2 (xml)' },
            { id: '1password1pif', name: '1Password (1pif)' },
            { id: 'dashlanejson', name: 'Dashlane (json)' },
        ];
        this.regularImportOptions = [
            { id: 'keepassxcsv', name: 'KeePassX (csv)' },
            { id: '1passwordwincsv', name: '1Password 6 and 7 Windows (csv)' },
            { id: 'roboformcsv', name: 'RoboForm (csv)' },
            { id: 'keepercsv', name: 'Keeper (csv)' },
            { id: 'enpasscsv', name: 'Enpass (csv)' },
            { id: 'enpassjson', name: 'Enpass (json)' },
            { id: 'safeincloudxml', name: 'SafeInCloud (xml)' },
            { id: 'pwsafexml', name: 'Password Safe (xml)' },
            { id: 'stickypasswordxml', name: 'Sticky Password (xml)' },
            { id: 'msecurecsv', name: 'mSecure (csv)' },
            { id: 'truekeycsv', name: 'True Key (csv)' },
            { id: 'passwordbossjson', name: 'Password Boss (json)' },
            { id: 'zohovaultcsv', name: 'Zoho Vault (csv)' },
            { id: 'splashidcsv', name: 'SplashID (csv)' },
            { id: 'passworddragonxml', name: 'Password Dragon (xml)' },
            { id: 'padlockcsv', name: 'Padlock (csv)' },
            { id: 'passboltcsv', name: 'Passbolt (csv)' },
            { id: 'clipperzhtml', name: 'Clipperz (html)' },
            { id: 'aviracsv', name: 'Avira (csv)' },
            { id: 'saferpasscsv', name: 'SaferPass (csv)' },
            { id: 'upmcsv', name: 'Universal Password Manager (csv)' },
            { id: 'ascendocsv', name: 'Ascendo DataVault (csv)' },
            { id: 'meldiumcsv', name: 'Meldium (csv)' },
            { id: 'passkeepcsv', name: 'PassKeep (csv)' },
            { id: 'operacsv', name: 'Opera (csv)' },
            { id: 'vivaldicsv', name: 'Vivaldi (csv)' },
            { id: 'gnomejson', name: 'GNOME Passwords and Keys/Seahorse (json)' },
            { id: 'blurcsv', name: 'Blur (csv)' },
            { id: 'passwordagentcsv', name: 'Password Agent (csv)' },
            { id: 'passpackcsv', name: 'Passpack (csv)' },
            { id: 'passmanjson', name: 'Passman (json)' },
            { id: 'avastcsv', name: 'Avast Passwords (csv)' },
            { id: 'avastjson', name: 'Avast Passwords (json)' },
            { id: 'fsecurefsk', name: 'F-Secure KEY (fsk)' },
            { id: 'kasperskytxt', name: 'Kaspersky Password Manager (txt)' },
            { id: 'remembearcsv', name: 'RememBear (csv)' },
            { id: 'passwordwallettxt', name: 'PasswordWallet (txt)' },
            { id: 'mykicsv', name: 'Myki (csv)' },
            { id: 'securesafecsv', name: 'SecureSafe (csv)' },
            { id: 'logmeoncecsv', name: 'LogMeOnce (csv)' },
            { id: 'blackberrycsv', name: 'BlackBerry Password Keeper (csv)' },
            { id: 'buttercupcsv', name: 'Buttercup (csv)' },
            { id: 'codebookcsv', name: 'Codebook (csv)' },
            { id: 'encryptrcsv', name: 'Encryptr (csv)' },
        ];
    }
    getImportOptions() {
        return this.featuredImportOptions.concat(this.regularImportOptions);
    }
    import(importer, fileContents, organizationId = null) {
        return import_service_awaiter(this, void 0, void 0, function* () {
            const importResult = yield importer.parse(fileContents);
            if (importResult.success) {
                if (importResult.folders.length === 0 && importResult.ciphers.length === 0) {
                    return new Error(this.i18nService.t('importNothingError'));
                }
                else if (importResult.ciphers.length > 0) {
                    const halfway = Math.floor(importResult.ciphers.length / 2);
                    const last = importResult.ciphers.length - 1;
                    if (this.badData(importResult.ciphers[0]) &&
                        this.badData(importResult.ciphers[halfway]) &&
                        this.badData(importResult.ciphers[last])) {
                        return new Error(this.i18nService.t('importFormatError'));
                    }
                }
                yield this.postImport(importResult, organizationId);
                return null;
            }
            else {
                return new Error(this.i18nService.t('importFormatError'));
            }
        });
    }
    getImporter(format, organization = false) {
        const importer = this.getImporterInstance(format);
        if (importer == null) {
            return null;
        }
        importer.organization = organization;
        return importer;
    }
    getImporterInstance(format) {
        if (format == null || format === '') {
            return null;
        }
        switch (format) {
            case 'bitwardencsv':
                return new bitwardenCsvImporter_BitwardenCsvImporter();
            case 'bitwardenjson':
                return new bitwardenJsonImporter_BitwardenJsonImporter();
            case 'lastpasscsv':
            case 'passboltcsv':
                return new lastpassCsvImporter_LastPassCsvImporter();
            case 'keepassxcsv':
                return new keepassxCsvImporter_KeePassXCsvImporter();
            case 'aviracsv':
                return new aviraCsvImporter_AviraCsvImporter();
            case 'blurcsv':
                return new blurCsvImporter_BlurCsvImporter();
            case 'safeincloudxml':
                return new safeInCloudXmlImporter_SafeInCloudXmlImporter();
            case 'padlockcsv':
                return new padlockCsvImporter_PadlockCsvImporter();
            case 'keepass2xml':
                return new keepass2XmlImporter_KeePass2XmlImporter();
            case 'chromecsv':
            case 'operacsv':
            case 'vivaldicsv':
                return new chromeCsvImporter_ChromeCsvImporter();
            case 'firefoxcsv':
                return new firefoxCsvImporter_FirefoxCsvImporter();
            case 'upmcsv':
                return new upmCsvImporter_UpmCsvImporter();
            case 'saferpasscsv':
                return new saferpassCsvImport_SaferPassCsvImporter();
            case 'meldiumcsv':
                return new meldiumCsvImporter_MeldiumCsvImporter();
            case '1password1pif':
                return new onepassword1PifImporter_OnePassword1PifImporter();
            case '1passwordwincsv':
                return new onepasswordWinCsvImporter_OnePasswordWinCsvImporter();
            case 'keepercsv':
                return new keeperCsvImporter_KeeperCsvImporter();
            case 'passworddragonxml':
                return new passwordDragonXmlImporter_PasswordDragonXmlImporter();
            case 'enpasscsv':
                return new enpassCsvImporter_EnpassCsvImporter();
            case 'enpassjson':
                return new enpassJsonImporter_EnpassJsonImporter();
            case 'pwsafexml':
                return new passwordSafeXmlImporter_PasswordSafeXmlImporter();
            case 'dashlanejson':
                return new dashlaneJsonImporter_DashlaneJsonImporter();
            case 'msecurecsv':
                return new msecureCsvImporter_MSecureCsvImporter();
            case 'stickypasswordxml':
                return new stickyPasswordXmlImporter_StickyPasswordXmlImporter();
            case 'truekeycsv':
                return new truekeyCsvImporter_TrueKeyCsvImporter();
            case 'clipperzhtml':
                return new clipperzHtmlImporter_ClipperzHtmlImporter();
            case 'roboformcsv':
                return new roboformCsvImporter_RoboFormCsvImporter();
            case 'ascendocsv':
                return new ascendoCsvImporter_AscendoCsvImporter();
            case 'passwordbossjson':
                return new passwordBossJsonImporter_PasswordBossJsonImporter();
            case 'zohovaultcsv':
                return new zohoVaultCsvImporter_ZohoVaultCsvImporter();
            case 'splashidcsv':
                return new splashIdCsvImporter_SplashIdCsvImporter();
            case 'passkeepcsv':
                return new passkeepCsvImporter_PassKeepCsvImporter();
            case 'gnomejson':
                return new gnomeJsonImporter_GnomeJsonImporter();
            case 'passwordagentcsv':
                return new passwordAgentCsvImporter_PasswordAgentCsvImporter();
            case 'passpackcsv':
                return new passpackCsvImporter_PasspackCsvImporter();
            case 'passmanjson':
                return new passmanJsonImporter_PassmanJsonImporter();
            case 'avastcsv':
                return new avastCsvImporter_AvastCsvImporter();
            case 'avastjson':
                return new avastJsonImporter_AvastJsonImporter();
            case 'fsecurefsk':
                return new fsecureFskImporter_FSecureFskImporter();
            case 'kasperskytxt':
                return new kasperskyTxtImporter_KasperskyTxtImporter();
            case 'remembearcsv':
                return new rememBearCsvImporter_RememBearCsvImporter();
            case 'passwordwallettxt':
                return new passwordWalletTxtImporter_PasswordWalletTxtImporter();
            case 'mykicsv':
                return new mykiCsvImporter_MykiCsvImporter();
            case 'securesafecsv':
                return new secureSafeCsvImporter_SecureSafeCsvImporter();
            case 'logmeoncecsv':
                return new logMeOnceCsvImporter_LogMeOnceCsvImporter();
            case 'blackberrycsv':
                return new blackBerryCsvImporter_BlackBerryCsvImporter();
            case 'buttercupcsv':
                return new buttercupCsvImporter_ButtercupCsvImporter();
            case 'codebookcsv':
                return new codebookCsvImporter_CodebookCsvImporter();
            case 'encryptrcsv':
                return new encryptrCsvImporter_EncryptrCsvImporter();
            default:
                return null;
        }
    }
    postImport(importResult, organizationId = null) {
        return import_service_awaiter(this, void 0, void 0, function* () {
            if (organizationId == null) {
                const request = new ImportCiphersRequest();
                for (let i = 0; i < importResult.ciphers.length; i++) {
                    const c = yield this.cipherService.encrypt(importResult.ciphers[i]);
                    request.ciphers.push(new cipherRequest_CipherRequest(c));
                }
                if (importResult.folders != null) {
                    for (let i = 0; i < importResult.folders.length; i++) {
                        const f = yield this.folderService.encrypt(importResult.folders[i]);
                        request.folders.push(new FolderRequest(f));
                    }
                }
                if (importResult.folderRelationships != null) {
                    importResult.folderRelationships.forEach((r) => request.folderRelationships.push(new KvpRequest(r[0], r[1])));
                }
                return yield this.apiService.postImportCiphers(request);
            }
            else {
                const request = new ImportOrganizationCiphersRequest();
                for (let i = 0; i < importResult.ciphers.length; i++) {
                    importResult.ciphers[i].organizationId = organizationId;
                    const c = yield this.cipherService.encrypt(importResult.ciphers[i]);
                    request.ciphers.push(new cipherRequest_CipherRequest(c));
                }
                if (importResult.collections != null) {
                    for (let i = 0; i < importResult.collections.length; i++) {
                        importResult.collections[i].organizationId = organizationId;
                        const c = yield this.collectionService.encrypt(importResult.collections[i]);
                        request.collections.push(new CollectionRequest(c));
                    }
                }
                if (importResult.collectionRelationships != null) {
                    importResult.collectionRelationships.forEach((r) => request.collectionRelationships.push(new KvpRequest(r[0], r[1])));
                }
                return yield this.apiService.postImportOrganizationCiphers(organizationId, request);
            }
        });
    }
    badData(c) {
        return (c.name == null || c.name === '--') &&
            (c.type === CipherType.Login && c.login != null && utils_Utils.isNullOrWhitespace(c.login.password));
    }
}

// EXTERNAL MODULE: external "lowdb"
var external_lowdb_ = __webpack_require__(11);

// EXTERNAL MODULE: external "lowdb/adapters/FileSync"
var FileSync_ = __webpack_require__(14);

// EXTERNAL MODULE: external "readline"
var external_readline_ = __webpack_require__(15);

// CONCATENATED MODULE: ./jslib/src/misc/nodeUtils.ts



class nodeUtils_NodeUtils {
    static mkdirpSync(targetDir, mode = '700', relative = false, relativeDir = null) {
        const initialDir = external_path_["isAbsolute"](targetDir) ? external_path_["sep"] : '';
        const baseDir = relative ? (relativeDir != null ? relativeDir : __dirname) : '.';
        targetDir.split(external_path_["sep"]).reduce((parentDir, childDir) => {
            const dir = external_path_["resolve"](baseDir, parentDir, childDir);
            if (!external_fs_["existsSync"](dir)) {
                external_fs_["mkdirSync"](dir, mode);
            }
            return dir;
        }, initialDir);
    }
    static readFirstLine(fileName) {
        return new Promise((resolve, reject) => {
            const readStream = external_fs_["createReadStream"](fileName, { encoding: 'utf8' });
            const readInterface = external_readline_["createInterface"](readStream);
            readInterface
                .on('line', (line) => {
                readStream.close();
                resolve(line);
            })
                .on('error', (err) => reject(err));
        });
    }
}

// CONCATENATED MODULE: ./jslib/src/services/lowdbStorage.service.ts






class lowdbStorage_service_LowdbStorageService {
    constructor(defaults, dir, allowCache = false) {
        this.allowCache = allowCache;
        this.defaults = defaults;
        let adapter;
        if (utils_Utils.isNode && dir != null) {
            if (!external_fs_["existsSync"](dir)) {
                nodeUtils_NodeUtils.mkdirpSync(dir, '700');
            }
            this.dataFilePath = external_path_["join"](dir, 'data.json');
            adapter = new FileSync_(this.dataFilePath);
        }
        try {
            this.db = external_lowdb_(adapter);
        }
        catch (e) {
            if (e instanceof SyntaxError) {
                adapter.write({});
                this.db = external_lowdb_(adapter);
            }
            else {
                throw e;
            }
        }
    }
    init() {
        if (this.defaults != null) {
            this.readForNoCache();
            this.db.defaults(this.defaults).write();
        }
    }
    get(key) {
        this.readForNoCache();
        const val = this.db.get(key).value();
        if (val == null) {
            return Promise.resolve(null);
        }
        return Promise.resolve(val);
    }
    save(key, obj) {
        this.readForNoCache();
        this.db.set(key, obj).write();
        return Promise.resolve();
    }
    remove(key) {
        this.readForNoCache();
        this.db.unset(key).write();
        return Promise.resolve();
    }
    readForNoCache() {
        if (!this.allowCache) {
            this.db.read();
        }
    }
}

// EXTERNAL MODULE: external "form-data"
var external_form_data_ = __webpack_require__(16);

// EXTERNAL MODULE: external "https-proxy-agent"
var external_https_proxy_agent_ = __webpack_require__(17);

// EXTERNAL MODULE: external "node-fetch"
var external_node_fetch_ = __webpack_require__(4);
var external_node_fetch_default = /*#__PURE__*/__webpack_require__.n(external_node_fetch_);

// CONCATENATED MODULE: ./jslib/src/models/response/apiKeyResponse.ts

class apiKeyResponse_ApiKeyResponse extends BaseResponse {
    constructor(response) {
        super(response);
        this.apiKey = this.getResponseProperty('ApiKey');
    }
}

// CONCATENATED MODULE: ./jslib/src/models/response/billingResponse.ts

class billingResponse_BillingResponse extends BaseResponse {
    constructor(response) {
        super(response);
        this.invoices = [];
        this.transactions = [];
        this.balance = this.getResponseProperty('Balance');
        const paymentSource = this.getResponseProperty('PaymentSource');
        const transactions = this.getResponseProperty('Transactions');
        const invoices = this.getResponseProperty('Invoices');
        this.paymentSource = paymentSource == null ? null : new billingResponse_BillingSourceResponse(paymentSource);
        if (transactions != null) {
            this.transactions = transactions.map((t) => new billingResponse_BillingTransactionResponse(t));
        }
        if (invoices != null) {
            this.invoices = invoices.map((i) => new billingResponse_BillingInvoiceResponse(i));
        }
    }
}
class billingResponse_BillingSourceResponse extends BaseResponse {
    constructor(response) {
        super(response);
        this.type = this.getResponseProperty('Type');
        this.cardBrand = this.getResponseProperty('CardBrand');
        this.description = this.getResponseProperty('Description');
        this.needsVerification = this.getResponseProperty('NeedsVerification');
    }
}
class billingResponse_BillingInvoiceResponse extends BaseResponse {
    constructor(response) {
        super(response);
        this.url = this.getResponseProperty('Url');
        this.pdfUrl = this.getResponseProperty('PdfUrl');
        this.number = this.getResponseProperty('Number');
        this.paid = this.getResponseProperty('Paid');
        this.date = this.getResponseProperty('Date');
        this.amount = this.getResponseProperty('Amount');
    }
}
class billingResponse_BillingTransactionResponse extends BaseResponse {
    constructor(response) {
        super(response);
        this.createdDate = this.getResponseProperty('CreatedDate');
        this.amount = this.getResponseProperty('Amount');
        this.refunded = this.getResponseProperty('Refunded');
        this.partiallyRefunded = this.getResponseProperty('PartiallyRefunded');
        this.refundedAmount = this.getResponseProperty('RefundedAmount');
        this.type = this.getResponseProperty('Type');
        this.paymentMethodType = this.getResponseProperty('PaymentMethodType');
        this.details = this.getResponseProperty('Details');
    }
}

// CONCATENATED MODULE: ./jslib/src/models/response/breachAccountResponse.ts

class breachAccountResponse_BreachAccountResponse extends BaseResponse {
    constructor(response) {
        super(response);
        this.addedDate = this.getResponseProperty('AddedDate');
        this.breachDate = this.getResponseProperty('BreachDate');
        this.dataClasses = this.getResponseProperty('DataClasses');
        this.description = this.getResponseProperty('Description');
        this.domain = this.getResponseProperty('Domain');
        this.isActive = this.getResponseProperty('IsActive');
        this.isVerified = this.getResponseProperty('IsVerified');
        this.logoPath = this.getResponseProperty('LogoPath');
        this.modifiedDate = this.getResponseProperty('ModifiedDate');
        this.name = this.getResponseProperty('Name');
        this.pwnCount = this.getResponseProperty('PwnCount');
        this.title = this.getResponseProperty('Title');
    }
}

// CONCATENATED MODULE: ./jslib/src/models/response/attachmentResponse.ts

class attachmentResponse_AttachmentResponse extends BaseResponse {
    constructor(response) {
        super(response);
        this.id = this.getResponseProperty('Id');
        this.url = this.getResponseProperty('Url');
        this.fileName = this.getResponseProperty('FileName');
        this.key = this.getResponseProperty('Key');
        this.size = this.getResponseProperty('Size');
        this.sizeName = this.getResponseProperty('SizeName');
    }
}

// CONCATENATED MODULE: ./jslib/src/models/response/passwordHistoryResponse.ts

class passwordHistoryResponse_PasswordHistoryResponse extends BaseResponse {
    constructor(response) {
        super(response);
        this.password = this.getResponseProperty('Password');
        this.lastUsedDate = this.getResponseProperty('LastUsedDate');
    }
}

// CONCATENATED MODULE: ./jslib/src/models/response/cipherResponse.ts








class cipherResponse_CipherResponse extends BaseResponse {
    constructor(response) {
        super(response);
        this.id = this.getResponseProperty('Id');
        this.organizationId = this.getResponseProperty('OrganizationId');
        this.folderId = this.getResponseProperty('FolderId') || null;
        this.type = this.getResponseProperty('Type');
        this.name = this.getResponseProperty('Name');
        this.notes = this.getResponseProperty('Notes');
        this.favorite = this.getResponseProperty('Favorite') || false;
        this.edit = this.getResponseProperty('Edit') || true;
        this.organizationUseTotp = this.getResponseProperty('OrganizationUseTotp');
        this.revisionDate = this.getResponseProperty('RevisionDate');
        this.collectionIds = this.getResponseProperty('CollectionIds');
        this.deletedDate = this.getResponseProperty('DeletedDate');
        const login = this.getResponseProperty('Login');
        if (login != null) {
            this.login = new loginApi_LoginApi(login);
        }
        const card = this.getResponseProperty('Card');
        if (card != null) {
            this.card = new cardApi_CardApi(card);
        }
        const identity = this.getResponseProperty('Identity');
        if (identity != null) {
            this.identity = new identityApi_IdentityApi(identity);
        }
        const secureNote = this.getResponseProperty('SecureNote');
        if (secureNote != null) {
            this.secureNote = new secureNoteApi_SecureNoteApi(secureNote);
        }
        const fields = this.getResponseProperty('Fields');
        if (fields != null) {
            this.fields = fields.map((f) => new fieldApi_FieldApi(f));
        }
        const attachments = this.getResponseProperty('Attachments');
        if (attachments != null) {
            this.attachments = attachments.map((a) => new attachmentResponse_AttachmentResponse(a));
        }
        const passwordHistory = this.getResponseProperty('PasswordHistory');
        if (passwordHistory != null) {
            this.passwordHistory = passwordHistory.map((h) => new passwordHistoryResponse_PasswordHistoryResponse(h));
        }
    }
}

// CONCATENATED MODULE: ./jslib/src/models/response/selectionReadOnlyResponse.ts

class selectionReadOnlyResponse_SelectionReadOnlyResponse extends BaseResponse {
    constructor(response) {
        super(response);
        this.id = this.getResponseProperty('Id');
        this.readOnly = this.getResponseProperty('ReadOnly');
    }
}

// CONCATENATED MODULE: ./jslib/src/models/response/collectionResponse.ts


class collectionResponse_CollectionResponse extends BaseResponse {
    constructor(response) {
        super(response);
        this.id = this.getResponseProperty('Id');
        this.organizationId = this.getResponseProperty('OrganizationId');
        this.name = this.getResponseProperty('Name');
        this.externalId = this.getResponseProperty('ExternalId');
    }
}
class CollectionDetailsResponse extends collectionResponse_CollectionResponse {
    constructor(response) {
        super(response);
        this.readOnly = this.getResponseProperty('ReadOnly') || false;
    }
}
class collectionResponse_CollectionGroupDetailsResponse extends collectionResponse_CollectionResponse {
    constructor(response) {
        super(response);
        this.groups = [];
        const groups = this.getResponseProperty('Groups');
        if (groups != null) {
            this.groups = groups.map((g) => new selectionReadOnlyResponse_SelectionReadOnlyResponse(g));
        }
    }
}

// CONCATENATED MODULE: ./jslib/src/models/response/globalDomainResponse.ts

class globalDomainResponse_GlobalDomainResponse extends BaseResponse {
    constructor(response) {
        super(response);
        this.type = this.getResponseProperty('Type');
        this.domains = this.getResponseProperty('Domains');
        this.excluded = this.getResponseProperty('Excluded');
    }
}

// CONCATENATED MODULE: ./jslib/src/models/response/domainsResponse.ts


class domainsResponse_DomainsResponse extends BaseResponse {
    constructor(response) {
        super(response);
        this.globalEquivalentDomains = [];
        this.equivalentDomains = this.getResponseProperty('EquivalentDomains');
        const globalEquivalentDomains = this.getResponseProperty('GlobalEquivalentDomains');
        if (globalEquivalentDomains != null) {
            this.globalEquivalentDomains = globalEquivalentDomains.map((d) => new globalDomainResponse_GlobalDomainResponse(d));
        }
        else {
            this.globalEquivalentDomains = [];
        }
    }
}

// CONCATENATED MODULE: ./jslib/src/models/response/errorResponse.ts

class errorResponse_ErrorResponse extends BaseResponse {
    constructor(response, status, identityResponse) {
        super(response);
        let errorModel = null;
        if (response != null) {
            const responseErrorModel = this.getResponseProperty('ErrorModel');
            if (responseErrorModel && identityResponse) {
                errorModel = responseErrorModel;
            }
            else {
                errorModel = response;
            }
        }
        if (errorModel) {
            this.message = this.getResponseProperty('Message', errorModel);
            this.validationErrors = this.getResponseProperty('ValidationErrors', errorModel);
        }
        else {
            if (status === 429) {
                this.message = 'Rate limit exceeded. Try again later.';
            }
        }
        this.statusCode = status;
    }
    getSingleMessage() {
        if (this.validationErrors == null) {
            return this.message;
        }
        for (const key in this.validationErrors) {
            if (!this.validationErrors.hasOwnProperty(key)) {
                continue;
            }
            if (this.validationErrors[key].length) {
                return this.validationErrors[key][0];
            }
        }
        return this.message;
    }
    getAllMessages() {
        const messages = [];
        if (this.validationErrors == null) {
            return messages;
        }
        for (const key in this.validationErrors) {
            if (!this.validationErrors.hasOwnProperty(key)) {
                continue;
            }
            this.validationErrors[key].forEach((item) => {
                let prefix = '';
                if (key.indexOf('[') > -1 && key.indexOf(']') > -1) {
                    const lastSep = key.lastIndexOf('.');
                    prefix = key.substr(0, lastSep > -1 ? lastSep : key.length) + ': ';
                }
                messages.push(prefix + item);
            });
        }
        return messages;
    }
}

// CONCATENATED MODULE: ./jslib/src/models/response/eventResponse.ts

class eventResponse_EventResponse extends BaseResponse {
    constructor(response) {
        super(response);
        this.type = this.getResponseProperty('Type');
        this.userId = this.getResponseProperty('UserId');
        this.organizationId = this.getResponseProperty('OrganizationId');
        this.cipherId = this.getResponseProperty('CipherId');
        this.collectionId = this.getResponseProperty('CollectionId');
        this.groupId = this.getResponseProperty('GroupId');
        this.organizationUserId = this.getResponseProperty('OrganizationUserId');
        this.actingUserId = this.getResponseProperty('ActingUserId');
        this.date = this.getResponseProperty('Date');
        this.deviceType = this.getResponseProperty('DeviceType');
        this.ipAddress = this.getResponseProperty('IpAddress');
    }
}

// CONCATENATED MODULE: ./jslib/src/models/response/folderResponse.ts

class folderResponse_FolderResponse extends BaseResponse {
    constructor(response) {
        super(response);
        this.id = this.getResponseProperty('Id');
        this.name = this.getResponseProperty('Name');
        this.revisionDate = this.getResponseProperty('RevisionDate');
    }
}

// CONCATENATED MODULE: ./jslib/src/models/response/groupResponse.ts


class groupResponse_GroupResponse extends BaseResponse {
    constructor(response) {
        super(response);
        this.id = this.getResponseProperty('Id');
        this.organizationId = this.getResponseProperty('OrganizationId');
        this.name = this.getResponseProperty('Name');
        this.accessAll = this.getResponseProperty('AccessAll');
        this.externalId = this.getResponseProperty('ExternalId');
    }
}
class groupResponse_GroupDetailsResponse extends groupResponse_GroupResponse {
    constructor(response) {
        super(response);
        this.collections = [];
        const collections = this.getResponseProperty('Collections');
        if (collections != null) {
            this.collections = collections.map((c) => new selectionReadOnlyResponse_SelectionReadOnlyResponse(c));
        }
    }
}

// CONCATENATED MODULE: ./jslib/src/models/response/identityTokenResponse.ts

class identityTokenResponse_IdentityTokenResponse extends BaseResponse {
    constructor(response) {
        super(response);
        this.accessToken = response.access_token;
        this.expiresIn = response.expires_in;
        this.refreshToken = response.refresh_token;
        this.tokenType = response.token_type;
        this.privateKey = this.getResponseProperty('PrivateKey');
        this.key = this.getResponseProperty('Key');
        this.twoFactorToken = this.getResponseProperty('TwoFactorToken');
    }
}

// CONCATENATED MODULE: ./jslib/src/models/response/identityTwoFactorResponse.ts

class identityTwoFactorResponse_IdentityTwoFactorResponse extends BaseResponse {
    constructor(response) {
        super(response);
        this.twoFactorProviders2 = new Map();
        this.twoFactorProviders = this.getResponseProperty('TwoFactorProviders');
        const twoFactorProviders2 = this.getResponseProperty('TwoFactorProviders2');
        if (twoFactorProviders2 != null) {
            for (const prop in twoFactorProviders2) {
                if (twoFactorProviders2.hasOwnProperty(prop)) {
                    this.twoFactorProviders2.set(parseInt(prop, null), twoFactorProviders2[prop]);
                }
            }
        }
    }
}

// CONCATENATED MODULE: ./jslib/src/models/response/listResponse.ts

class listResponse_ListResponse extends BaseResponse {
    constructor(response, t) {
        super(response);
        const data = this.getResponseProperty('Data');
        this.data = data == null ? [] : data.map((dr) => new t(dr));
        this.continuationToken = this.getResponseProperty('ContinuationToken');
    }
}

// CONCATENATED MODULE: ./jslib/src/models/response/organizationResponse.ts

class organizationResponse_OrganizationResponse extends BaseResponse {
    constructor(response) {
        super(response);
        this.id = this.getResponseProperty('Id');
        this.name = this.getResponseProperty('Name');
        this.businessName = this.getResponseProperty('BusinessName');
        this.businessAddress1 = this.getResponseProperty('BusinessAddress1');
        this.businessAddress2 = this.getResponseProperty('BusinessAddress2');
        this.businessAddress3 = this.getResponseProperty('BusinessAddress3');
        this.businessCountry = this.getResponseProperty('BusinessCountry');
        this.businessTaxNumber = this.getResponseProperty('BusinessTaxNumber');
        this.billingEmail = this.getResponseProperty('BillingEmail');
        this.plan = this.getResponseProperty('Plan');
        this.planType = this.getResponseProperty('PlanType');
        this.seats = this.getResponseProperty('Seats');
        this.maxCollections = this.getResponseProperty('MaxCollections');
        this.maxStorageGb = this.getResponseProperty('MaxStorageGb');
        this.useGroups = this.getResponseProperty('UseGroups');
        this.useDirectory = this.getResponseProperty('UseDirectory');
        this.useEvents = this.getResponseProperty('UseEvents');
        this.useTotp = this.getResponseProperty('UseTotp');
        this.use2fa = this.getResponseProperty('Use2fa');
        this.useApi = this.getResponseProperty('UseApi');
    }
}

// CONCATENATED MODULE: ./jslib/src/models/response/subscriptionResponse.ts

class subscriptionResponse_SubscriptionResponse extends BaseResponse {
    constructor(response) {
        super(response);
        this.storageName = this.getResponseProperty('StorageName');
        this.storageGb = this.getResponseProperty('StorageGb');
        this.maxStorageGb = this.getResponseProperty('MaxStorageGb');
        this.license = this.getResponseProperty('License');
        this.expiration = this.getResponseProperty('Expiration');
        this.usingInAppPurchase = this.getResponseProperty('UsingInAppPurchase');
        const subscription = this.getResponseProperty('Subscription');
        const upcomingInvoice = this.getResponseProperty('UpcomingInvoice');
        this.subscription = subscription == null ? null : new subscriptionResponse_BillingSubscriptionResponse(subscription);
        this.upcomingInvoice = upcomingInvoice == null ? null :
            new subscriptionResponse_BillingSubscriptionUpcomingInvoiceResponse(upcomingInvoice);
    }
}
class subscriptionResponse_BillingSubscriptionResponse extends BaseResponse {
    constructor(response) {
        super(response);
        this.items = [];
        this.trialEndDate = this.getResponseProperty('TrialStartDate');
        this.trialEndDate = this.getResponseProperty('TrialEndDate');
        this.periodStartDate = this.getResponseProperty('PeriodStartDate');
        this.periodEndDate = this.getResponseProperty('PeriodEndDate');
        this.cancelledDate = this.getResponseProperty('CancelledDate');
        this.cancelAtEndDate = this.getResponseProperty('CancelAtEndDate');
        this.status = this.getResponseProperty('Status');
        this.cancelled = this.getResponseProperty('Cancelled');
        const items = this.getResponseProperty('Items');
        if (items != null) {
            this.items = items.map((i) => new subscriptionResponse_BillingSubscriptionItemResponse(i));
        }
    }
}
class subscriptionResponse_BillingSubscriptionItemResponse extends BaseResponse {
    constructor(response) {
        super(response);
        this.name = this.getResponseProperty('Name');
        this.amount = this.getResponseProperty('Amount');
        this.quantity = this.getResponseProperty('Quantity');
        this.interval = this.getResponseProperty('Interval');
    }
}
class subscriptionResponse_BillingSubscriptionUpcomingInvoiceResponse extends BaseResponse {
    constructor(response) {
        super(response);
        this.date = this.getResponseProperty('Date');
        this.amount = this.getResponseProperty('Amount');
    }
}

// CONCATENATED MODULE: ./jslib/src/models/response/organizationSubscriptionResponse.ts


class organizationSubscriptionResponse_OrganizationSubscriptionResponse extends organizationResponse_OrganizationResponse {
    constructor(response) {
        super(response);
        this.storageName = this.getResponseProperty('StorageName');
        this.storageGb = this.getResponseProperty('StorageGb');
        const subscription = this.getResponseProperty('Subscription');
        this.subscription = subscription == null ? null : new subscriptionResponse_BillingSubscriptionResponse(subscription);
        const upcomingInvoice = this.getResponseProperty('UpcomingInvoice');
        this.upcomingInvoice = upcomingInvoice == null ? null :
            new subscriptionResponse_BillingSubscriptionUpcomingInvoiceResponse(upcomingInvoice);
        this.expiration = this.getResponseProperty('Expiration');
    }
}

// CONCATENATED MODULE: ./jslib/src/models/response/organizationUserResponse.ts


class organizationUserResponse_OrganizationUserResponse extends BaseResponse {
    constructor(response) {
        super(response);
        this.id = this.getResponseProperty('Id');
        this.userId = this.getResponseProperty('UserId');
        this.type = this.getResponseProperty('Type');
        this.status = this.getResponseProperty('Status');
        this.accessAll = this.getResponseProperty('AccessAll');
    }
}
class OrganizationUserUserDetailsResponse extends organizationUserResponse_OrganizationUserResponse {
    constructor(response) {
        super(response);
        this.name = this.getResponseProperty('Name');
        this.email = this.getResponseProperty('Email');
        this.twoFactorEnabled = this.getResponseProperty('TwoFactorEnabled');
    }
}
class organizationUserResponse_OrganizationUserDetailsResponse extends organizationUserResponse_OrganizationUserResponse {
    constructor(response) {
        super(response);
        this.collections = [];
        const collections = this.getResponseProperty('Collections');
        if (collections != null) {
            this.collections = collections.map((c) => new selectionReadOnlyResponse_SelectionReadOnlyResponse(c));
        }
    }
}

// CONCATENATED MODULE: ./jslib/src/models/response/profileOrganizationResponse.ts

class profileOrganizationResponse_ProfileOrganizationResponse extends BaseResponse {
    constructor(response) {
        super(response);
        this.id = this.getResponseProperty('Id');
        this.name = this.getResponseProperty('Name');
        this.usePolicies = this.getResponseProperty('UsePolicies');
        this.useGroups = this.getResponseProperty('UseGroups');
        this.useDirectory = this.getResponseProperty('UseDirectory');
        this.useEvents = this.getResponseProperty('UseEvents');
        this.useTotp = this.getResponseProperty('UseTotp');
        this.use2fa = this.getResponseProperty('Use2fa');
        this.useApi = this.getResponseProperty('UseApi');
        this.selfHost = this.getResponseProperty('SelfHost');
        this.usersGetPremium = this.getResponseProperty('UsersGetPremium');
        this.seats = this.getResponseProperty('Seats');
        this.maxCollections = this.getResponseProperty('MaxCollections');
        this.maxStorageGb = this.getResponseProperty('MaxStorageGb');
        this.key = this.getResponseProperty('Key');
        this.status = this.getResponseProperty('Status');
        this.type = this.getResponseProperty('Type');
        this.enabled = this.getResponseProperty('Enabled');
    }
}

// CONCATENATED MODULE: ./jslib/src/models/response/profileResponse.ts


class profileResponse_ProfileResponse extends BaseResponse {
    constructor(response) {
        super(response);
        this.organizations = [];
        this.id = this.getResponseProperty('Id');
        this.name = this.getResponseProperty('Name');
        this.email = this.getResponseProperty('Email');
        this.emailVerified = this.getResponseProperty('EmailVerified');
        this.masterPasswordHint = this.getResponseProperty('MasterPasswordHint');
        this.premium = this.getResponseProperty('Premium');
        this.culture = this.getResponseProperty('Culture');
        this.twoFactorEnabled = this.getResponseProperty('TwoFactorEnabled');
        this.key = this.getResponseProperty('Key');
        this.privateKey = this.getResponseProperty('PrivateKey');
        this.securityStamp = this.getResponseProperty('SecurityStamp');
        const organizations = this.getResponseProperty('Organizations');
        if (organizations != null) {
            this.organizations = organizations.map((o) => new profileOrganizationResponse_ProfileOrganizationResponse(o));
        }
    }
}

// CONCATENATED MODULE: ./jslib/src/models/response/paymentResponse.ts


class paymentResponse_PaymentResponse extends BaseResponse {
    constructor(response) {
        super(response);
        const userProfile = this.getResponseProperty('UserProfile');
        if (userProfile != null) {
            this.userProfile = new profileResponse_ProfileResponse(userProfile);
        }
        this.paymentIntentClientSecret = this.getResponseProperty('PaymentIntentClientSecret');
        this.success = this.getResponseProperty('Success');
    }
}

// CONCATENATED MODULE: ./jslib/src/models/response/policyResponse.ts

class policyResponse_PolicyResponse extends BaseResponse {
    constructor(response) {
        super(response);
        this.id = this.getResponseProperty('Id');
        this.organizationId = this.getResponseProperty('OrganizationId');
        this.type = this.getResponseProperty('Type');
        this.data = this.getResponseProperty('Data');
        this.enabled = this.getResponseProperty('Enabled');
    }
}

// CONCATENATED MODULE: ./jslib/src/models/response/preloginResponse.ts

class preloginResponse_PreloginResponse extends BaseResponse {
    constructor(response) {
        super(response);
        this.kdf = this.getResponseProperty('Kdf');
        this.kdfIterations = this.getResponseProperty('KdfIterations');
    }
}

// CONCATENATED MODULE: ./jslib/src/models/response/syncResponse.ts







class syncResponse_SyncResponse extends BaseResponse {
    constructor(response) {
        super(response);
        this.folders = [];
        this.collections = [];
        this.ciphers = [];
        this.policies = [];
        const profile = this.getResponseProperty('Profile');
        if (profile != null) {
            this.profile = new profileResponse_ProfileResponse(profile);
        }
        const folders = this.getResponseProperty('Folders');
        if (folders != null) {
            this.folders = folders.map((f) => new folderResponse_FolderResponse(f));
        }
        const collections = this.getResponseProperty('Collections');
        if (collections != null) {
            this.collections = collections.map((c) => new CollectionDetailsResponse(c));
        }
        const ciphers = this.getResponseProperty('Ciphers');
        if (ciphers != null) {
            this.ciphers = ciphers.map((c) => new cipherResponse_CipherResponse(c));
        }
        const domains = this.getResponseProperty('Domains');
        if (domains != null) {
            this.domains = new domainsResponse_DomainsResponse(domains);
        }
        const policies = this.getResponseProperty('Policies');
        if (policies != null) {
            this.policies = policies.map((p) => new policyResponse_PolicyResponse(p));
        }
    }
}

// CONCATENATED MODULE: ./jslib/src/models/response/twoFactorAuthenticatorResponse.ts

class twoFactorAuthenticatorResponse_TwoFactorAuthenticatorResponse extends BaseResponse {
    constructor(response) {
        super(response);
        this.enabled = this.getResponseProperty('Enabled');
        this.key = this.getResponseProperty('Key');
    }
}

// CONCATENATED MODULE: ./jslib/src/models/response/twoFactorDuoResponse.ts

class twoFactorDuoResponse_TwoFactorDuoResponse extends BaseResponse {
    constructor(response) {
        super(response);
        this.enabled = this.getResponseProperty('Enabled');
        this.host = this.getResponseProperty('Host');
        this.secretKey = this.getResponseProperty('SecretKey');
        this.integrationKey = this.getResponseProperty('IntegrationKey');
    }
}

// CONCATENATED MODULE: ./jslib/src/models/response/twoFactorEmailResponse.ts

class twoFactorEmailResponse_TwoFactorEmailResponse extends BaseResponse {
    constructor(response) {
        super(response);
        this.enabled = this.getResponseProperty('Enabled');
        this.email = this.getResponseProperty('Email');
    }
}

// CONCATENATED MODULE: ./jslib/src/models/response/twoFactorProviderResponse.ts

class twoFactorProviderResponse_TwoFactorProviderResponse extends BaseResponse {
    constructor(response) {
        super(response);
        this.enabled = this.getResponseProperty('Enabled');
        this.type = this.getResponseProperty('Type');
    }
}

// CONCATENATED MODULE: ./jslib/src/models/response/twoFactorRescoverResponse.ts

class twoFactorRescoverResponse_TwoFactorRecoverResponse extends BaseResponse {
    constructor(response) {
        super(response);
        this.code = this.getResponseProperty('Code');
    }
}

// CONCATENATED MODULE: ./jslib/src/models/response/twoFactorU2fResponse.ts

class twoFactorU2fResponse_TwoFactorU2fResponse extends BaseResponse {
    constructor(response) {
        super(response);
        this.enabled = this.getResponseProperty('Enabled');
        const keys = this.getResponseProperty('Keys');
        this.keys = keys == null ? null : keys.map((k) => new twoFactorU2fResponse_KeyResponse(k));
    }
}
class twoFactorU2fResponse_KeyResponse extends BaseResponse {
    constructor(response) {
        super(response);
        this.name = this.getResponseProperty('Name');
        this.id = this.getResponseProperty('Id');
        this.compromised = this.getResponseProperty('Compromised');
    }
}
class twoFactorU2fResponse_ChallengeResponse extends BaseResponse {
    constructor(response) {
        super(response);
        this.userId = this.getResponseProperty('UserId');
        this.appId = this.getResponseProperty('AppId');
        this.challenge = this.getResponseProperty('Challenge');
        this.version = this.getResponseProperty('Version');
    }
}

// CONCATENATED MODULE: ./jslib/src/models/response/twoFactorYubiKeyResponse.ts

class twoFactorYubiKeyResponse_TwoFactorYubiKeyResponse extends BaseResponse {
    constructor(response) {
        super(response);
        this.enabled = this.getResponseProperty('Enabled');
        this.key1 = this.getResponseProperty('Key1');
        this.key2 = this.getResponseProperty('Key2');
        this.key3 = this.getResponseProperty('Key3');
        this.key4 = this.getResponseProperty('Key4');
        this.key5 = this.getResponseProperty('Key5');
        this.nfc = this.getResponseProperty('Nfc');
    }
}

// CONCATENATED MODULE: ./jslib/src/models/response/userKeyResponse.ts

class userKeyResponse_UserKeyResponse extends BaseResponse {
    constructor(response) {
        super(response);
        this.userId = this.getResponseProperty('UserId');
        this.publicKey = this.getResponseProperty('PublicKey');
    }
}

// CONCATENATED MODULE: ./jslib/src/services/api.service.ts
var api_service_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
































class api_service_ApiService {
    constructor(tokenService, platformUtilsService, logoutCallback, customUserAgent = null) {
        this.tokenService = tokenService;
        this.platformUtilsService = platformUtilsService;
        this.logoutCallback = logoutCallback;
        this.customUserAgent = customUserAgent;
        this.urlsSet = false;
        this.isWebClient = false;
        this.isDesktopClient = false;
        this.usingBaseUrl = false;
        this.device = platformUtilsService.getDevice();
        this.deviceType = this.device.toString();
        this.isWebClient = this.device === DeviceType.IEBrowser || this.device === DeviceType.ChromeBrowser ||
            this.device === DeviceType.EdgeBrowser || this.device === DeviceType.FirefoxBrowser ||
            this.device === DeviceType.OperaBrowser || this.device === DeviceType.SafariBrowser ||
            this.device === DeviceType.UnknownBrowser || this.device === DeviceType.VivaldiBrowser;
        this.isDesktopClient = this.device === DeviceType.WindowsDesktop || this.device === DeviceType.MacOsDesktop ||
            this.device === DeviceType.LinuxDesktop;
    }
    setUrls(urls) {
        this.urlsSet = true;
        if (urls.base != null) {
            this.usingBaseUrl = true;
            this.apiBaseUrl = urls.base + '/api';
            this.identityBaseUrl = urls.base + '/identity';
            this.eventsBaseUrl = urls.base + '/events';
            return;
        }
        this.apiBaseUrl = urls.api;
        this.identityBaseUrl = urls.identity;
        this.eventsBaseUrl = urls.events;
        // Production
        if (this.apiBaseUrl == null) {
            this.apiBaseUrl = 'https://api.bitwarden.com';
        }
        if (this.identityBaseUrl == null) {
            this.identityBaseUrl = 'https://identity.bitwarden.com';
        }
        if (this.eventsBaseUrl == null) {
            this.eventsBaseUrl = 'https://events.bitwarden.com';
        }
    }
    // Auth APIs
    postIdentityToken(request) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const headers = new Headers({
                'Content-Type': 'application/x-www-form-urlencoded; charset=utf-8',
                'Accept': 'application/json',
                'Device-Type': this.deviceType,
            });
            if (this.customUserAgent != null) {
                headers.set('User-Agent', this.customUserAgent);
            }
            const response = yield this.fetch(new Request(this.identityBaseUrl + '/connect/token', {
                body: this.qsStringify(request.toIdentityToken(this.platformUtilsService.identityClientId)),
                credentials: this.getCredentials(),
                cache: 'no-store',
                headers: headers,
                method: 'POST',
            }));
            let responseJson = null;
            if (this.isJsonResponse(response)) {
                responseJson = yield response.json();
            }
            if (responseJson != null) {
                if (response.status === 200) {
                    return new identityTokenResponse_IdentityTokenResponse(responseJson);
                }
                else if (response.status === 400 && responseJson.TwoFactorProviders2 &&
                    Object.keys(responseJson.TwoFactorProviders2).length) {
                    yield this.tokenService.clearTwoFactorToken(request.email);
                    return new identityTwoFactorResponse_IdentityTwoFactorResponse(responseJson);
                }
            }
            return Promise.reject(new errorResponse_ErrorResponse(responseJson, response.status, true));
        });
    }
    refreshIdentityToken() {
        return api_service_awaiter(this, void 0, void 0, function* () {
            try {
                yield this.doRefreshToken();
            }
            catch (e) {
                return Promise.reject(null);
            }
        });
    }
    // Account APIs
    getProfile() {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('GET', '/accounts/profile', null, true, true);
            return new profileResponse_ProfileResponse(r);
        });
    }
    getUserBilling() {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('GET', '/accounts/billing', null, true, true);
            return new billingResponse_BillingResponse(r);
        });
    }
    getUserSubscription() {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('GET', '/accounts/subscription', null, true, true);
            return new subscriptionResponse_SubscriptionResponse(r);
        });
    }
    putProfile(request) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('PUT', '/accounts/profile', request, true, true);
            return new profileResponse_ProfileResponse(r);
        });
    }
    postPrelogin(request) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('POST', '/accounts/prelogin', request, false, true);
            return new preloginResponse_PreloginResponse(r);
        });
    }
    postEmailToken(request) {
        return this.send('POST', '/accounts/email-token', request, true, false);
    }
    postEmail(request) {
        return this.send('POST', '/accounts/email', request, true, false);
    }
    postPassword(request) {
        return this.send('POST', '/accounts/password', request, true, false);
    }
    postSecurityStamp(request) {
        return this.send('POST', '/accounts/security-stamp', request, true, false);
    }
    deleteAccount(request) {
        return this.send('DELETE', '/accounts', request, true, false);
    }
    getAccountRevisionDate() {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('GET', '/accounts/revision-date', null, true, true);
            return r;
        });
    }
    postPasswordHint(request) {
        return this.send('POST', '/accounts/password-hint', request, false, false);
    }
    postRegister(request) {
        return this.send('POST', '/accounts/register', request, false, false);
    }
    postPremium(data) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('POST', '/accounts/premium', data, true, true);
            return new paymentResponse_PaymentResponse(r);
        });
    }
    postIapCheck(request) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            return this.send('POST', '/accounts/iap-check', request, true, false);
        });
    }
    postReinstatePremium() {
        return this.send('POST', '/accounts/reinstate-premium', null, true, false);
    }
    postCancelPremium() {
        return this.send('POST', '/accounts/cancel-premium', null, true, false);
    }
    postAccountStorage(request) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('POST', '/accounts/storage', request, true, true);
            return new paymentResponse_PaymentResponse(r);
        });
    }
    postAccountPayment(request) {
        return this.send('POST', '/accounts/payment', request, true, false);
    }
    postAccountLicense(data) {
        return this.send('POST', '/accounts/license', data, true, false);
    }
    postAccountKeys(request) {
        return this.send('POST', '/accounts/keys', request, true, false);
    }
    postAccountKey(request) {
        return this.send('POST', '/accounts/key', request, true, false);
    }
    postAccountVerifyEmail() {
        return this.send('POST', '/accounts/verify-email', null, true, false);
    }
    postAccountVerifyEmailToken(request) {
        return this.send('POST', '/accounts/verify-email-token', request, false, false);
    }
    postAccountRecoverDelete(request) {
        return this.send('POST', '/accounts/delete-recover', request, false, false);
    }
    postAccountRecoverDeleteToken(request) {
        return this.send('POST', '/accounts/delete-recover-token', request, false, false);
    }
    postAccountKdf(request) {
        return this.send('POST', '/accounts/kdf', request, true, false);
    }
    getEnterprisePortalSignInToken() {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('GET', '/accounts/enterprise-portal-signin-token', null, true, true);
            return r;
        });
    }
    // Folder APIs
    getFolder(id) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('GET', '/folders/' + id, null, true, true);
            return new folderResponse_FolderResponse(r);
        });
    }
    postFolder(request) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('POST', '/folders', request, true, true);
            return new folderResponse_FolderResponse(r);
        });
    }
    putFolder(id, request) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('PUT', '/folders/' + id, request, true, true);
            return new folderResponse_FolderResponse(r);
        });
    }
    deleteFolder(id) {
        return this.send('DELETE', '/folders/' + id, null, true, false);
    }
    // Cipher APIs
    getCipher(id) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('GET', '/ciphers/' + id, null, true, true);
            return new cipherResponse_CipherResponse(r);
        });
    }
    getCipherAdmin(id) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('GET', '/ciphers/' + id + '/admin', null, true, true);
            return new cipherResponse_CipherResponse(r);
        });
    }
    getCiphersOrganization(organizationId) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('GET', '/ciphers/organization-details?organizationId=' + organizationId, null, true, true);
            return new listResponse_ListResponse(r, cipherResponse_CipherResponse);
        });
    }
    postCipher(request) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('POST', '/ciphers', request, true, true);
            return new cipherResponse_CipherResponse(r);
        });
    }
    postCipherCreate(request) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('POST', '/ciphers/create', request, true, true);
            return new cipherResponse_CipherResponse(r);
        });
    }
    postCipherAdmin(request) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('POST', '/ciphers/admin', request, true, true);
            return new cipherResponse_CipherResponse(r);
        });
    }
    putCipher(id, request) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('PUT', '/ciphers/' + id, request, true, true);
            return new cipherResponse_CipherResponse(r);
        });
    }
    putCipherAdmin(id, request) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('PUT', '/ciphers/' + id + '/admin', request, true, true);
            return new cipherResponse_CipherResponse(r);
        });
    }
    deleteCipher(id) {
        return this.send('DELETE', '/ciphers/' + id, null, true, false);
    }
    deleteCipherAdmin(id) {
        return this.send('DELETE', '/ciphers/' + id + '/admin', null, true, false);
    }
    deleteManyCiphers(request) {
        return this.send('DELETE', '/ciphers', request, true, false);
    }
    putMoveCiphers(request) {
        return this.send('PUT', '/ciphers/move', request, true, false);
    }
    putShareCipher(id, request) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('PUT', '/ciphers/' + id + '/share', request, true, true);
            return new cipherResponse_CipherResponse(r);
        });
    }
    putShareCiphers(request) {
        return this.send('PUT', '/ciphers/share', request, true, false);
    }
    putCipherCollections(id, request) {
        return this.send('PUT', '/ciphers/' + id + '/collections', request, true, false);
    }
    putCipherCollectionsAdmin(id, request) {
        return this.send('PUT', '/ciphers/' + id + '/collections-admin', request, true, false);
    }
    postPurgeCiphers(request, organizationId = null) {
        let path = '/ciphers/purge';
        if (organizationId != null) {
            path += '?organizationId=' + organizationId;
        }
        return this.send('POST', path, request, true, false);
    }
    postImportCiphers(request) {
        return this.send('POST', '/ciphers/import', request, true, false);
    }
    postImportOrganizationCiphers(organizationId, request) {
        return this.send('POST', '/ciphers/import-organization?organizationId=' + organizationId, request, true, false);
    }
    putDeleteCipher(id) {
        return this.send('PUT', '/ciphers/' + id + '/delete', null, true, false);
    }
    putDeleteCipherAdmin(id) {
        return this.send('PUT', '/ciphers/' + id + '/delete-admin', null, true, false);
    }
    putDeleteManyCiphers(request) {
        return this.send('PUT', '/ciphers/delete', request, true, false);
    }
    putRestoreCipher(id) {
        return this.send('PUT', '/ciphers/' + id + '/restore', null, true, false);
    }
    putRestoreCipherAdmin(id) {
        return this.send('PUT', '/ciphers/' + id + '/restore-admin', null, true, false);
    }
    putRestoreManyCiphers(request) {
        return this.send('PUT', '/ciphers/restore', request, true, false);
    }
    // Attachments APIs
    postCipherAttachment(id, data) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('POST', '/ciphers/' + id + '/attachment', data, true, true);
            return new cipherResponse_CipherResponse(r);
        });
    }
    postCipherAttachmentAdmin(id, data) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('POST', '/ciphers/' + id + '/attachment-admin', data, true, true);
            return new cipherResponse_CipherResponse(r);
        });
    }
    deleteCipherAttachment(id, attachmentId) {
        return this.send('DELETE', '/ciphers/' + id + '/attachment/' + attachmentId, null, true, false);
    }
    deleteCipherAttachmentAdmin(id, attachmentId) {
        return this.send('DELETE', '/ciphers/' + id + '/attachment/' + attachmentId + '/admin', null, true, false);
    }
    postShareCipherAttachment(id, attachmentId, data, organizationId) {
        return this.send('POST', '/ciphers/' + id + '/attachment/' +
            attachmentId + '/share?organizationId=' + organizationId, data, true, false);
    }
    // Collections APIs
    getCollectionDetails(organizationId, id) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('GET', '/organizations/' + organizationId + '/collections/' + id + '/details', null, true, true);
            return new collectionResponse_CollectionGroupDetailsResponse(r);
        });
    }
    getUserCollections() {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('GET', '/collections', null, true, true);
            return new listResponse_ListResponse(r, collectionResponse_CollectionResponse);
        });
    }
    getCollections(organizationId) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('GET', '/organizations/' + organizationId + '/collections', null, true, true);
            return new listResponse_ListResponse(r, collectionResponse_CollectionResponse);
        });
    }
    getCollectionUsers(organizationId, id) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('GET', '/organizations/' + organizationId + '/collections/' + id + '/users', null, true, true);
            return r.map((dr) => new selectionReadOnlyResponse_SelectionReadOnlyResponse(dr));
        });
    }
    postCollection(organizationId, request) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('POST', '/organizations/' + organizationId + '/collections', request, true, true);
            return new collectionResponse_CollectionResponse(r);
        });
    }
    putCollection(organizationId, id, request) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('PUT', '/organizations/' + organizationId + '/collections/' + id, request, true, true);
            return new collectionResponse_CollectionResponse(r);
        });
    }
    putCollectionUsers(organizationId, id, request) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            yield this.send('PUT', '/organizations/' + organizationId + '/collections/' + id + '/users', request, true, false);
        });
    }
    deleteCollection(organizationId, id) {
        return this.send('DELETE', '/organizations/' + organizationId + '/collections/' + id, null, true, false);
    }
    deleteCollectionUser(organizationId, id, organizationUserId) {
        return this.send('DELETE', '/organizations/' + organizationId + '/collections/' + id + '/user/' + organizationUserId, null, true, false);
    }
    // Groups APIs
    getGroupDetails(organizationId, id) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('GET', '/organizations/' + organizationId + '/groups/' + id + '/details', null, true, true);
            return new groupResponse_GroupDetailsResponse(r);
        });
    }
    getGroups(organizationId) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('GET', '/organizations/' + organizationId + '/groups', null, true, true);
            return new listResponse_ListResponse(r, groupResponse_GroupResponse);
        });
    }
    getGroupUsers(organizationId, id) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('GET', '/organizations/' + organizationId + '/groups/' + id + '/users', null, true, true);
            return r;
        });
    }
    postGroup(organizationId, request) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('POST', '/organizations/' + organizationId + '/groups', request, true, true);
            return new groupResponse_GroupResponse(r);
        });
    }
    putGroup(organizationId, id, request) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('PUT', '/organizations/' + organizationId + '/groups/' + id, request, true, true);
            return new groupResponse_GroupResponse(r);
        });
    }
    putGroupUsers(organizationId, id, request) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            yield this.send('PUT', '/organizations/' + organizationId + '/groups/' + id + '/users', request, true, false);
        });
    }
    deleteGroup(organizationId, id) {
        return this.send('DELETE', '/organizations/' + organizationId + '/groups/' + id, null, true, false);
    }
    deleteGroupUser(organizationId, id, organizationUserId) {
        return this.send('DELETE', '/organizations/' + organizationId + '/groups/' + id + '/user/' + organizationUserId, null, true, false);
    }
    // Policy APIs
    getPolicy(organizationId, type) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('GET', '/organizations/' + organizationId + '/policies/' + type, null, true, true);
            return new policyResponse_PolicyResponse(r);
        });
    }
    getPolicies(organizationId) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('GET', '/organizations/' + organizationId + '/policies', null, true, true);
            return new listResponse_ListResponse(r, policyResponse_PolicyResponse);
        });
    }
    getPoliciesByToken(organizationId, token, email, organizationUserId) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('GET', '/organizations/' + organizationId + '/policies/token?' +
                'token=' + encodeURIComponent(token) + '&email=' + encodeURIComponent(email) +
                '&organizationUserId=' + organizationUserId, null, false, true);
            return new listResponse_ListResponse(r, policyResponse_PolicyResponse);
        });
    }
    putPolicy(organizationId, type, request) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('PUT', '/organizations/' + organizationId + '/policies/' + type, request, true, true);
            return new policyResponse_PolicyResponse(r);
        });
    }
    // Organization User APIs
    getOrganizationUser(organizationId, id) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('GET', '/organizations/' + organizationId + '/users/' + id, null, true, true);
            return new organizationUserResponse_OrganizationUserDetailsResponse(r);
        });
    }
    getOrganizationUserGroups(organizationId, id) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('GET', '/organizations/' + organizationId + '/users/' + id + '/groups', null, true, true);
            return r;
        });
    }
    getOrganizationUsers(organizationId) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('GET', '/organizations/' + organizationId + '/users', null, true, true);
            return new listResponse_ListResponse(r, OrganizationUserUserDetailsResponse);
        });
    }
    postOrganizationUserInvite(organizationId, request) {
        return this.send('POST', '/organizations/' + organizationId + '/users/invite', request, true, false);
    }
    postOrganizationUserReinvite(organizationId, id) {
        return this.send('POST', '/organizations/' + organizationId + '/users/' + id + '/reinvite', null, true, false);
    }
    postOrganizationUserAccept(organizationId, id, request) {
        return this.send('POST', '/organizations/' + organizationId + '/users/' + id + '/accept', request, true, false);
    }
    postOrganizationUserConfirm(organizationId, id, request) {
        return this.send('POST', '/organizations/' + organizationId + '/users/' + id + '/confirm', request, true, false);
    }
    putOrganizationUser(organizationId, id, request) {
        return this.send('PUT', '/organizations/' + organizationId + '/users/' + id, request, true, false);
    }
    putOrganizationUserGroups(organizationId, id, request) {
        return this.send('PUT', '/organizations/' + organizationId + '/users/' + id + '/groups', request, true, false);
    }
    deleteOrganizationUser(organizationId, id) {
        return this.send('DELETE', '/organizations/' + organizationId + '/users/' + id, null, true, false);
    }
    // Sync APIs
    getSync() {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const path = this.isDesktopClient || this.isWebClient ? '/sync?excludeDomains=true' : '/sync';
            const r = yield this.send('GET', path, null, true, true);
            return new syncResponse_SyncResponse(r);
        });
    }
    postImportDirectory(organizationId, request) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            return this.send('POST', '/organizations/' + organizationId + '/import', request, true, false);
        });
    }
    // Settings APIs
    getSettingsDomains() {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('GET', '/settings/domains', null, true, true);
            return new domainsResponse_DomainsResponse(r);
        });
    }
    putSettingsDomains(request) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('PUT', '/settings/domains', request, true, true);
            return new domainsResponse_DomainsResponse(r);
        });
    }
    // Two-factor APIs
    getTwoFactorProviders() {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('GET', '/two-factor', null, true, true);
            return new listResponse_ListResponse(r, twoFactorProviderResponse_TwoFactorProviderResponse);
        });
    }
    getTwoFactorOrganizationProviders(organizationId) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('GET', '/organizations/' + organizationId + '/two-factor', null, true, true);
            return new listResponse_ListResponse(r, twoFactorProviderResponse_TwoFactorProviderResponse);
        });
    }
    getTwoFactorAuthenticator(request) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('POST', '/two-factor/get-authenticator', request, true, true);
            return new twoFactorAuthenticatorResponse_TwoFactorAuthenticatorResponse(r);
        });
    }
    getTwoFactorEmail(request) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('POST', '/two-factor/get-email', request, true, true);
            return new twoFactorEmailResponse_TwoFactorEmailResponse(r);
        });
    }
    getTwoFactorDuo(request) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('POST', '/two-factor/get-duo', request, true, true);
            return new twoFactorDuoResponse_TwoFactorDuoResponse(r);
        });
    }
    getTwoFactorOrganizationDuo(organizationId, request) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('POST', '/organizations/' + organizationId + '/two-factor/get-duo', request, true, true);
            return new twoFactorDuoResponse_TwoFactorDuoResponse(r);
        });
    }
    getTwoFactorYubiKey(request) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('POST', '/two-factor/get-yubikey', request, true, true);
            return new twoFactorYubiKeyResponse_TwoFactorYubiKeyResponse(r);
        });
    }
    getTwoFactorU2f(request) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('POST', '/two-factor/get-u2f', request, true, true);
            return new twoFactorU2fResponse_TwoFactorU2fResponse(r);
        });
    }
    getTwoFactorU2fChallenge(request) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('POST', '/two-factor/get-u2f-challenge', request, true, true);
            return new twoFactorU2fResponse_ChallengeResponse(r);
        });
    }
    getTwoFactorRecover(request) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('POST', '/two-factor/get-recover', request, true, true);
            return new twoFactorRescoverResponse_TwoFactorRecoverResponse(r);
        });
    }
    putTwoFactorAuthenticator(request) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('PUT', '/two-factor/authenticator', request, true, true);
            return new twoFactorAuthenticatorResponse_TwoFactorAuthenticatorResponse(r);
        });
    }
    putTwoFactorEmail(request) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('PUT', '/two-factor/email', request, true, true);
            return new twoFactorEmailResponse_TwoFactorEmailResponse(r);
        });
    }
    putTwoFactorDuo(request) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('PUT', '/two-factor/duo', request, true, true);
            return new twoFactorDuoResponse_TwoFactorDuoResponse(r);
        });
    }
    putTwoFactorOrganizationDuo(organizationId, request) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('PUT', '/organizations/' + organizationId + '/two-factor/duo', request, true, true);
            return new twoFactorDuoResponse_TwoFactorDuoResponse(r);
        });
    }
    putTwoFactorYubiKey(request) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('PUT', '/two-factor/yubikey', request, true, true);
            return new twoFactorYubiKeyResponse_TwoFactorYubiKeyResponse(r);
        });
    }
    putTwoFactorU2f(request) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('PUT', '/two-factor/u2f', request, true, true);
            return new twoFactorU2fResponse_TwoFactorU2fResponse(r);
        });
    }
    deleteTwoFactorU2f(request) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('DELETE', '/two-factor/u2f', request, true, true);
            return new twoFactorU2fResponse_TwoFactorU2fResponse(r);
        });
    }
    putTwoFactorDisable(request) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('PUT', '/two-factor/disable', request, true, true);
            return new twoFactorProviderResponse_TwoFactorProviderResponse(r);
        });
    }
    putTwoFactorOrganizationDisable(organizationId, request) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('PUT', '/organizations/' + organizationId + '/two-factor/disable', request, true, true);
            return new twoFactorProviderResponse_TwoFactorProviderResponse(r);
        });
    }
    postTwoFactorRecover(request) {
        return this.send('POST', '/two-factor/recover', request, false, false);
    }
    postTwoFactorEmailSetup(request) {
        return this.send('POST', '/two-factor/send-email', request, true, false);
    }
    postTwoFactorEmail(request) {
        return this.send('POST', '/two-factor/send-email-login', request, false, false);
    }
    // Organization APIs
    getOrganization(id) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('GET', '/organizations/' + id, null, true, true);
            return new organizationResponse_OrganizationResponse(r);
        });
    }
    getOrganizationBilling(id) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('GET', '/organizations/' + id + '/billing', null, true, true);
            return new billingResponse_BillingResponse(r);
        });
    }
    getOrganizationSubscription(id) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('GET', '/organizations/' + id + '/subscription', null, true, true);
            return new organizationSubscriptionResponse_OrganizationSubscriptionResponse(r);
        });
    }
    getOrganizationLicense(id, installationId) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            return this.send('GET', '/organizations/' + id + '/license?installationId=' + installationId, null, true, true);
        });
    }
    postOrganization(request) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('POST', '/organizations', request, true, true);
            return new organizationResponse_OrganizationResponse(r);
        });
    }
    putOrganization(id, request) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('PUT', '/organizations/' + id, request, true, true);
            return new organizationResponse_OrganizationResponse(r);
        });
    }
    postLeaveOrganization(id) {
        return this.send('POST', '/organizations/' + id + '/leave', null, true, false);
    }
    postOrganizationLicense(data) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('POST', '/organizations/license', data, true, true);
            return new organizationResponse_OrganizationResponse(r);
        });
    }
    postOrganizationLicenseUpdate(id, data) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            return this.send('POST', '/organizations/' + id + '/license', data, true, false);
        });
    }
    postOrganizationApiKey(id, request) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('POST', '/organizations/' + id + '/api-key', request, true, true);
            return new apiKeyResponse_ApiKeyResponse(r);
        });
    }
    postOrganizationRotateApiKey(id, request) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('POST', '/organizations/' + id + '/rotate-api-key', request, true, true);
            return new apiKeyResponse_ApiKeyResponse(r);
        });
    }
    postOrganizationUpgrade(id, request) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('POST', '/organizations/' + id + '/upgrade', request, true, true);
            return new paymentResponse_PaymentResponse(r);
        });
    }
    postOrganizationSeat(id, request) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('POST', '/organizations/' + id + '/seat', request, true, true);
            return new paymentResponse_PaymentResponse(r);
        });
    }
    postOrganizationStorage(id, request) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('POST', '/organizations/' + id + '/storage', request, true, true);
            return new paymentResponse_PaymentResponse(r);
        });
    }
    postOrganizationPayment(id, request) {
        return this.send('POST', '/organizations/' + id + '/payment', request, true, false);
    }
    postOrganizationVerifyBank(id, request) {
        return this.send('POST', '/organizations/' + id + '/verify-bank', request, true, false);
    }
    postOrganizationCancel(id) {
        return this.send('POST', '/organizations/' + id + '/cancel', null, true, false);
    }
    postOrganizationReinstate(id) {
        return this.send('POST', '/organizations/' + id + '/reinstate', null, true, false);
    }
    deleteOrganization(id, request) {
        return this.send('DELETE', '/organizations/' + id, request, true, false);
    }
    // Event APIs
    getEvents(start, end, token) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('GET', this.addEventParameters('/events', start, end, token), null, true, true);
            return new listResponse_ListResponse(r, eventResponse_EventResponse);
        });
    }
    getEventsCipher(id, start, end, token) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('GET', this.addEventParameters('/ciphers/' + id + '/events', start, end, token), null, true, true);
            return new listResponse_ListResponse(r, eventResponse_EventResponse);
        });
    }
    getEventsOrganization(id, start, end, token) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('GET', this.addEventParameters('/organizations/' + id + '/events', start, end, token), null, true, true);
            return new listResponse_ListResponse(r, eventResponse_EventResponse);
        });
    }
    getEventsOrganizationUser(organizationId, id, start, end, token) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('GET', this.addEventParameters('/organizations/' + organizationId + '/users/' + id + '/events', start, end, token), null, true, true);
            return new listResponse_ListResponse(r, eventResponse_EventResponse);
        });
    }
    postEventsCollect(request) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const authHeader = yield this.getActiveBearerToken();
            const headers = new Headers({
                'Device-Type': this.deviceType,
                'Authorization': 'Bearer ' + authHeader,
                'Content-Type': 'application/json; charset=utf-8',
            });
            if (this.customUserAgent != null) {
                headers.set('User-Agent', this.customUserAgent);
            }
            const response = yield this.fetch(new Request(this.eventsBaseUrl + '/collect', {
                cache: 'no-store',
                credentials: this.getCredentials(),
                method: 'POST',
                body: JSON.stringify(request),
                headers: headers,
            }));
            if (response.status !== 200) {
                return Promise.reject('Event post failed.');
            }
        });
    }
    // User APIs
    getUserPublicKey(id) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('GET', '/users/' + id + '/public-key', null, true, true);
            return new userKeyResponse_UserKeyResponse(r);
        });
    }
    // HIBP APIs
    getHibpBreach(username) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('GET', '/hibp/breach?username=' + username, null, true, true);
            return r.map((a) => new breachAccountResponse_BreachAccountResponse(a));
        });
    }
    // Misc
    postBitPayInvoice(request) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('POST', '/bitpay-invoice', request, true, true);
            return r;
        });
    }
    postSetupPayment() {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const r = yield this.send('POST', '/setup-payment', null, true, true);
            return r;
        });
    }
    // Helpers
    getActiveBearerToken() {
        return api_service_awaiter(this, void 0, void 0, function* () {
            let accessToken = yield this.tokenService.getToken();
            if (this.tokenService.tokenNeedsRefresh()) {
                const tokenResponse = yield this.doRefreshToken();
                accessToken = tokenResponse.accessToken;
            }
            return accessToken;
        });
    }
    fetch(request) {
        if (request.method === 'GET') {
            request.headers.set('Cache-Control', 'no-store');
            request.headers.set('Pragma', 'no-cache');
        }
        return this.nativeFetch(request);
    }
    nativeFetch(request) {
        return fetch(request);
    }
    send(method, path, body, authed, hasResponse) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const headers = new Headers({
                'Device-Type': this.deviceType,
            });
            if (this.customUserAgent != null) {
                headers.set('User-Agent', this.customUserAgent);
            }
            const requestInit = {
                cache: 'no-store',
                credentials: this.getCredentials(),
                method: method,
            };
            if (authed) {
                const authHeader = yield this.getActiveBearerToken();
                headers.set('Authorization', 'Bearer ' + authHeader);
            }
            if (body != null) {
                if (typeof body === 'string') {
                    requestInit.body = body;
                    headers.set('Content-Type', 'application/x-www-form-urlencoded; charset=utf-8');
                }
                else if (typeof body === 'object') {
                    if (body instanceof FormData) {
                        requestInit.body = body;
                    }
                    else {
                        headers.set('Content-Type', 'application/json; charset=utf-8');
                        requestInit.body = JSON.stringify(body);
                    }
                }
            }
            if (hasResponse) {
                headers.set('Accept', 'application/json');
            }
            requestInit.headers = headers;
            const response = yield this.fetch(new Request(this.apiBaseUrl + path, requestInit));
            if (hasResponse && response.status === 200) {
                const responseJson = yield response.json();
                return responseJson;
            }
            else if (response.status !== 200) {
                const error = yield this.handleError(response, false);
                return Promise.reject(error);
            }
        });
    }
    handleError(response, tokenError) {
        return api_service_awaiter(this, void 0, void 0, function* () {
            if ((tokenError && response.status === 400) || response.status === 401 || response.status === 403) {
                yield this.logoutCallback(true);
                return null;
            }
            let responseJson = null;
            if (this.isJsonResponse(response)) {
                responseJson = yield response.json();
            }
            return new errorResponse_ErrorResponse(responseJson, response.status, tokenError);
        });
    }
    doRefreshToken() {
        return api_service_awaiter(this, void 0, void 0, function* () {
            const refreshToken = yield this.tokenService.getRefreshToken();
            if (refreshToken == null || refreshToken === '') {
                throw new Error();
            }
            const headers = new Headers({
                'Content-Type': 'application/x-www-form-urlencoded; charset=utf-8',
                'Accept': 'application/json',
                'Device-Type': this.deviceType,
            });
            if (this.customUserAgent != null) {
                headers.set('User-Agent', this.customUserAgent);
            }
            const decodedToken = this.tokenService.decodeToken();
            const response = yield this.fetch(new Request(this.identityBaseUrl + '/connect/token', {
                body: this.qsStringify({
                    grant_type: 'refresh_token',
                    client_id: decodedToken.client_id,
                    refresh_token: refreshToken,
                }),
                cache: 'no-store',
                credentials: this.getCredentials(),
                headers: headers,
                method: 'POST',
            }));
            if (response.status === 200) {
                const responseJson = yield response.json();
                const tokenResponse = new identityTokenResponse_IdentityTokenResponse(responseJson);
                yield this.tokenService.setTokens(tokenResponse.accessToken, tokenResponse.refreshToken);
                return tokenResponse;
            }
            else {
                const error = yield this.handleError(response, true);
                return Promise.reject(error);
            }
        });
    }
    qsStringify(params) {
        return Object.keys(params).map((key) => {
            return encodeURIComponent(key) + '=' + encodeURIComponent(params[key]);
        }).join('&');
    }
    getCredentials() {
        if (this.device !== DeviceType.SafariExtension && (!this.isWebClient || this.usingBaseUrl)) {
            return 'include';
        }
        return undefined;
    }
    addEventParameters(base, start, end, token) {
        if (start != null) {
            base += ('?start=' + start);
        }
        if (end != null) {
            base += (base.indexOf('?') > -1 ? '&' : '?');
            base += ('end=' + end);
        }
        if (token != null) {
            base += (base.indexOf('?') > -1 ? '&' : '?');
            base += ('continuationToken=' + token);
        }
        return base;
    }
    isJsonResponse(response) {
        const typeHeader = response.headers.get('content-type');
        return typeHeader != null && typeHeader.indexOf('application/json') > -1;
    }
}

// CONCATENATED MODULE: ./jslib/src/services/nodeApi.service.ts




global.fetch = external_node_fetch_default.a;
global.Request = external_node_fetch_["Request"];
global.Response = external_node_fetch_["Response"];
global.Headers = external_node_fetch_["Headers"];
global.FormData = external_form_data_;
class nodeApi_service_NodeApiService extends api_service_ApiService {
    constructor(tokenService, platformUtilsService, logoutCallback, customUserAgent = null) {
        super(tokenService, platformUtilsService, logoutCallback, customUserAgent);
    }
    nativeFetch(request) {
        const proxy = process.env.http_proxy || process.env.https_proxy;
        if (proxy) {
            request.agent = new external_https_proxy_agent_(proxy);
        }
        return fetch(request);
    }
}

// EXTERNAL MODULE: external "crypto"
var external_crypto_ = __webpack_require__(6);

// EXTERNAL MODULE: external "node-forge"
var external_node_forge_ = __webpack_require__(2);

// CONCATENATED MODULE: ./jslib/src/models/domain/decryptParameters.ts
class DecryptParameters {
}

// CONCATENATED MODULE: ./jslib/src/services/nodeCryptoFunction.service.ts
var nodeCryptoFunction_service_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};




class nodeCryptoFunction_service_NodeCryptoFunctionService {
    pbkdf2(password, salt, algorithm, iterations) {
        const len = algorithm === 'sha256' ? 32 : 64;
        const nodePassword = this.toNodeValue(password);
        const nodeSalt = this.toNodeValue(salt);
        return new Promise((resolve, reject) => {
            external_crypto_["pbkdf2"](nodePassword, nodeSalt, iterations, len, algorithm, (error, key) => {
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(this.toArrayBuffer(key));
                }
            });
        });
    }
    hash(value, algorithm) {
        const nodeValue = this.toNodeValue(value);
        const hash = external_crypto_["createHash"](algorithm);
        hash.update(nodeValue);
        return Promise.resolve(this.toArrayBuffer(hash.digest()));
    }
    hmac(value, key, algorithm) {
        const nodeValue = this.toNodeBuffer(value);
        const nodeKey = this.toNodeBuffer(key);
        const hmac = external_crypto_["createHmac"](algorithm, nodeKey);
        hmac.update(nodeValue);
        return Promise.resolve(this.toArrayBuffer(hmac.digest()));
    }
    compare(a, b) {
        return nodeCryptoFunction_service_awaiter(this, void 0, void 0, function* () {
            const key = yield this.randomBytes(32);
            const mac1 = yield this.hmac(a, key, 'sha256');
            const mac2 = yield this.hmac(b, key, 'sha256');
            if (mac1.byteLength !== mac2.byteLength) {
                return false;
            }
            const arr1 = new Uint8Array(mac1);
            const arr2 = new Uint8Array(mac2);
            for (let i = 0; i < arr2.length; i++) {
                if (arr1[i] !== arr2[i]) {
                    return false;
                }
            }
            return true;
        });
    }
    hmacFast(value, key, algorithm) {
        return this.hmac(value, key, algorithm);
    }
    compareFast(a, b) {
        return this.compare(a, b);
    }
    aesEncrypt(data, iv, key) {
        const nodeData = this.toNodeBuffer(data);
        const nodeIv = this.toNodeBuffer(iv);
        const nodeKey = this.toNodeBuffer(key);
        const cipher = external_crypto_["createCipheriv"]('aes-256-cbc', nodeKey, nodeIv);
        const encBuf = Buffer.concat([cipher.update(nodeData), cipher.final()]);
        return Promise.resolve(this.toArrayBuffer(encBuf));
    }
    aesDecryptFastParameters(data, iv, mac, key) {
        const p = new DecryptParameters();
        p.encKey = key.encKey;
        p.data = utils_Utils.fromB64ToArray(data).buffer;
        p.iv = utils_Utils.fromB64ToArray(iv).buffer;
        const macData = new Uint8Array(p.iv.byteLength + p.data.byteLength);
        macData.set(new Uint8Array(p.iv), 0);
        macData.set(new Uint8Array(p.data), p.iv.byteLength);
        p.macData = macData.buffer;
        if (key.macKey != null) {
            p.macKey = key.macKey;
        }
        if (mac != null) {
            p.mac = utils_Utils.fromB64ToArray(mac).buffer;
        }
        return p;
    }
    aesDecryptFast(parameters) {
        return nodeCryptoFunction_service_awaiter(this, void 0, void 0, function* () {
            const decBuf = yield this.aesDecrypt(parameters.data, parameters.iv, parameters.encKey);
            return utils_Utils.fromBufferToUtf8(decBuf);
        });
    }
    aesDecrypt(data, iv, key) {
        const nodeData = this.toNodeBuffer(data);
        const nodeIv = this.toNodeBuffer(iv);
        const nodeKey = this.toNodeBuffer(key);
        const decipher = external_crypto_["createDecipheriv"]('aes-256-cbc', nodeKey, nodeIv);
        const decBuf = Buffer.concat([decipher.update(nodeData), decipher.final()]);
        return Promise.resolve(this.toArrayBuffer(decBuf));
    }
    rsaEncrypt(data, publicKey, algorithm) {
        if (algorithm === 'sha256') {
            throw new Error('Node crypto does not support RSA-OAEP SHA-256');
        }
        const pem = this.toPemPublicKey(publicKey);
        const decipher = external_crypto_["publicEncrypt"](pem, this.toNodeBuffer(data));
        return Promise.resolve(this.toArrayBuffer(decipher));
    }
    rsaDecrypt(data, privateKey, algorithm) {
        if (algorithm === 'sha256') {
            throw new Error('Node crypto does not support RSA-OAEP SHA-256');
        }
        const pem = this.toPemPrivateKey(privateKey);
        const decipher = external_crypto_["privateDecrypt"](pem, this.toNodeBuffer(data));
        return Promise.resolve(this.toArrayBuffer(decipher));
    }
    rsaExtractPublicKey(privateKey) {
        const privateKeyByteString = utils_Utils.fromBufferToByteString(privateKey);
        const privateKeyAsn1 = external_node_forge_["asn1"].fromDer(privateKeyByteString);
        const forgePrivateKey = external_node_forge_["pki"].privateKeyFromAsn1(privateKeyAsn1);
        const forgePublicKey = external_node_forge_["pki"].setRsaPublicKey(forgePrivateKey.n, forgePrivateKey.e);
        const publicKeyAsn1 = external_node_forge_["pki"].publicKeyToAsn1(forgePublicKey);
        const publicKeyByteString = external_node_forge_["asn1"].toDer(publicKeyAsn1).data;
        const publicKeyArray = utils_Utils.fromByteStringToArray(publicKeyByteString);
        return Promise.resolve(publicKeyArray.buffer);
    }
    rsaGenerateKeyPair(length) {
        return nodeCryptoFunction_service_awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                external_node_forge_["pki"].rsa.generateKeyPair({
                    bits: length,
                    workers: -1,
                    e: 0x10001,
                }, (error, keyPair) => {
                    if (error != null) {
                        reject(error);
                        return;
                    }
                    const publicKeyAsn1 = external_node_forge_["pki"].publicKeyToAsn1(keyPair.publicKey);
                    const publicKeyByteString = external_node_forge_["asn1"].toDer(publicKeyAsn1).getBytes();
                    const publicKey = utils_Utils.fromByteStringToArray(publicKeyByteString);
                    const privateKeyAsn1 = external_node_forge_["pki"].privateKeyToAsn1(keyPair.privateKey);
                    const privateKeyPkcs8 = external_node_forge_["pki"].wrapRsaPrivateKey(privateKeyAsn1);
                    const privateKeyByteString = external_node_forge_["asn1"].toDer(privateKeyPkcs8).getBytes();
                    const privateKey = utils_Utils.fromByteStringToArray(privateKeyByteString);
                    resolve([publicKey.buffer, privateKey.buffer]);
                });
            });
        });
    }
    randomBytes(length) {
        return new Promise((resolve, reject) => {
            external_crypto_["randomBytes"](length, (error, bytes) => {
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(this.toArrayBuffer(bytes));
                }
            });
        });
    }
    toNodeValue(value) {
        let nodeValue;
        if (typeof (value) === 'string') {
            nodeValue = value;
        }
        else {
            nodeValue = this.toNodeBuffer(value);
        }
        return nodeValue;
    }
    toNodeBuffer(value) {
        return Buffer.from(new Uint8Array(value));
    }
    toArrayBuffer(buf) {
        return new Uint8Array(buf).buffer;
    }
    toPemPrivateKey(key) {
        const byteString = utils_Utils.fromBufferToByteString(key);
        const asn1 = external_node_forge_["asn1"].fromDer(byteString);
        const privateKey = external_node_forge_["pki"].privateKeyFromAsn1(asn1);
        const rsaPrivateKey = external_node_forge_["pki"].privateKeyToAsn1(privateKey);
        const privateKeyInfo = external_node_forge_["pki"].wrapRsaPrivateKey(rsaPrivateKey);
        return external_node_forge_["pki"].privateKeyInfoToPem(privateKeyInfo);
    }
    toPemPublicKey(key) {
        const byteString = utils_Utils.fromBufferToByteString(key);
        const asn1 = external_node_forge_["asn1"].fromDer(byteString);
        const publicKey = external_node_forge_["pki"].publicKeyFromAsn1(asn1);
        return external_node_forge_["pki"].publicKeyToPem(publicKey);
    }
}

// CONCATENATED MODULE: ./jslib/src/services/noopMessaging.service.ts
class NoopMessagingService {
    send(subscriber, arg = {}) {
        // Do nothing...
    }
}

// EXTERNAL MODULE: external "zxcvbn"
var external_zxcvbn_ = __webpack_require__(18);

// CONCATENATED MODULE: ./jslib/src/models/domain/passwordGeneratorPolicyOptions.ts

class passwordGeneratorPolicyOptions_PasswordGeneratorPolicyOptions extends domainBase_Domain {
    constructor() {
        super(...arguments);
        this.defaultType = '';
        this.minLength = 0;
        this.useUppercase = false;
        this.useLowercase = false;
        this.useNumbers = false;
        this.numberCount = 0;
        this.useSpecial = false;
        this.specialCount = 0;
        this.minNumberWords = 0;
        this.capitalize = false;
        this.includeNumber = false;
    }
    inEffect() {
        return this.defaultType !== '' ||
            this.minLength > 0 ||
            this.numberCount > 0 ||
            this.specialCount > 0 ||
            this.useUppercase ||
            this.useLowercase ||
            this.useNumbers ||
            this.useSpecial ||
            this.minNumberWords > 0 ||
            this.capitalize ||
            this.includeNumber;
    }
}

// CONCATENATED MODULE: ./jslib/src/enums/policyType.ts
var PolicyType;
(function (PolicyType) {
    PolicyType[PolicyType["TwoFactorAuthentication"] = 0] = "TwoFactorAuthentication";
    PolicyType[PolicyType["MasterPassword"] = 1] = "MasterPassword";
    PolicyType[PolicyType["PasswordGenerator"] = 2] = "PasswordGenerator";
})(PolicyType || (PolicyType = {}));

// CONCATENATED MODULE: ./jslib/src/services/passwordGeneration.service.ts
var passwordGeneration_service_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};






const DefaultOptions = {
    length: 14,
    ambiguous: false,
    number: true,
    minNumber: 1,
    uppercase: true,
    minUppercase: 0,
    lowercase: true,
    minLowercase: 0,
    special: false,
    minSpecial: 1,
    type: 'password',
    numWords: 3,
    wordSeparator: '-',
    capitalize: false,
    includeNumber: false,
};
const passwordGeneration_service_Keys = {
    options: 'passwordGenerationOptions',
    history: 'generatedPasswordHistory',
};
const MaxPasswordsInHistory = 100;
class passwordGeneration_service_PasswordGenerationService {
    constructor(cryptoService, storageService, policyService) {
        this.cryptoService = cryptoService;
        this.storageService = storageService;
        this.policyService = policyService;
    }
    generatePassword(options) {
        return passwordGeneration_service_awaiter(this, void 0, void 0, function* () {
            // overload defaults with given options
            const o = Object.assign({}, DefaultOptions, options);
            if (o.type === 'passphrase') {
                return this.generatePassphrase(options);
            }
            // sanitize
            this.sanitizePasswordLength(o, true);
            const minLength = o.minUppercase + o.minLowercase + o.minNumber + o.minSpecial;
            if (o.length < minLength) {
                o.length = minLength;
            }
            const positions = [];
            if (o.lowercase && o.minLowercase > 0) {
                for (let i = 0; i < o.minLowercase; i++) {
                    positions.push('l');
                }
            }
            if (o.uppercase && o.minUppercase > 0) {
                for (let i = 0; i < o.minUppercase; i++) {
                    positions.push('u');
                }
            }
            if (o.number && o.minNumber > 0) {
                for (let i = 0; i < o.minNumber; i++) {
                    positions.push('n');
                }
            }
            if (o.special && o.minSpecial > 0) {
                for (let i = 0; i < o.minSpecial; i++) {
                    positions.push('s');
                }
            }
            while (positions.length < o.length) {
                positions.push('a');
            }
            // shuffle
            yield this.shuffleArray(positions);
            // build out the char sets
            let allCharSet = '';
            let lowercaseCharSet = 'abcdefghijkmnopqrstuvwxyz';
            if (o.ambiguous) {
                lowercaseCharSet += 'l';
            }
            if (o.lowercase) {
                allCharSet += lowercaseCharSet;
            }
            let uppercaseCharSet = 'ABCDEFGHJKLMNPQRSTUVWXYZ';
            if (o.ambiguous) {
                uppercaseCharSet += 'IO';
            }
            if (o.uppercase) {
                allCharSet += uppercaseCharSet;
            }
            let numberCharSet = '23456789';
            if (o.ambiguous) {
                numberCharSet += '01';
            }
            if (o.number) {
                allCharSet += numberCharSet;
            }
            const specialCharSet = '!@#$%^&*';
            if (o.special) {
                allCharSet += specialCharSet;
            }
            let password = '';
            for (let i = 0; i < o.length; i++) {
                let positionChars;
                switch (positions[i]) {
                    case 'l':
                        positionChars = lowercaseCharSet;
                        break;
                    case 'u':
                        positionChars = uppercaseCharSet;
                        break;
                    case 'n':
                        positionChars = numberCharSet;
                        break;
                    case 's':
                        positionChars = specialCharSet;
                        break;
                    case 'a':
                        positionChars = allCharSet;
                        break;
                    default:
                        break;
                }
                const randomCharIndex = yield this.cryptoService.randomNumber(0, positionChars.length - 1);
                password += positionChars.charAt(randomCharIndex);
            }
            return password;
        });
    }
    generatePassphrase(options) {
        return passwordGeneration_service_awaiter(this, void 0, void 0, function* () {
            const o = Object.assign({}, DefaultOptions, options);
            if (o.numWords == null || o.numWords <= 2) {
                o.numWords = DefaultOptions.numWords;
            }
            if (o.wordSeparator == null || o.wordSeparator.length === 0 || o.wordSeparator.length > 1) {
                o.wordSeparator = ' ';
            }
            if (o.capitalize == null) {
                o.capitalize = false;
            }
            if (o.includeNumber == null) {
                o.includeNumber = false;
            }
            const listLength = EEFLongWordList.length - 1;
            const wordList = new Array(o.numWords);
            for (let i = 0; i < o.numWords; i++) {
                const wordIndex = yield this.cryptoService.randomNumber(0, listLength);
                if (o.capitalize) {
                    wordList[i] = this.capitalize(EEFLongWordList[wordIndex]);
                }
                else {
                    wordList[i] = EEFLongWordList[wordIndex];
                }
            }
            if (o.includeNumber) {
                yield this.appendRandomNumberToRandomWord(wordList);
            }
            return wordList.join(o.wordSeparator);
        });
    }
    getOptions() {
        return passwordGeneration_service_awaiter(this, void 0, void 0, function* () {
            if (this.optionsCache == null) {
                const options = yield this.storageService.get(passwordGeneration_service_Keys.options);
                if (options == null) {
                    this.optionsCache = DefaultOptions;
                }
                else {
                    this.optionsCache = Object.assign({}, DefaultOptions, options);
                }
            }
            const enforcedOptions = yield this.enforcePasswordGeneratorPoliciesOnOptions(this.optionsCache);
            this.optionsCache = enforcedOptions[0];
            return [this.optionsCache, enforcedOptions[1]];
        });
    }
    enforcePasswordGeneratorPoliciesOnOptions(options) {
        return passwordGeneration_service_awaiter(this, void 0, void 0, function* () {
            let enforcedPolicyOptions = yield this.getPasswordGeneratorPolicyOptions();
            if (enforcedPolicyOptions != null) {
                if (options.length < enforcedPolicyOptions.minLength) {
                    options.length = enforcedPolicyOptions.minLength;
                }
                if (enforcedPolicyOptions.useUppercase) {
                    options.uppercase = true;
                }
                if (enforcedPolicyOptions.useLowercase) {
                    options.lowercase = true;
                }
                if (enforcedPolicyOptions.useNumbers) {
                    options.number = true;
                }
                if (options.minNumber < enforcedPolicyOptions.numberCount) {
                    options.minNumber = enforcedPolicyOptions.numberCount;
                }
                if (enforcedPolicyOptions.useSpecial) {
                    options.special = true;
                }
                if (options.minSpecial < enforcedPolicyOptions.specialCount) {
                    options.minSpecial = enforcedPolicyOptions.specialCount;
                }
                // Must normalize these fields because the receiving call expects all options to pass the current rules
                if (options.minSpecial + options.minNumber > options.length) {
                    options.minSpecial = options.length - options.minNumber;
                }
                if (options.numWords < enforcedPolicyOptions.minNumberWords) {
                    options.numWords = enforcedPolicyOptions.minNumberWords;
                }
                if (enforcedPolicyOptions.capitalize) {
                    options.capitalize = true;
                }
                if (enforcedPolicyOptions.includeNumber) {
                    options.includeNumber = true;
                }
                // Force default type if password/passphrase selected via policy
                if (enforcedPolicyOptions.defaultType === 'password' ||
                    enforcedPolicyOptions.defaultType === 'passphrase') {
                    options.type = enforcedPolicyOptions.defaultType;
                }
            }
            else { // UI layer expects an instantiated object to prevent more explicit null checks
                enforcedPolicyOptions = new passwordGeneratorPolicyOptions_PasswordGeneratorPolicyOptions();
            }
            return [options, enforcedPolicyOptions];
        });
    }
    getPasswordGeneratorPolicyOptions() {
        return passwordGeneration_service_awaiter(this, void 0, void 0, function* () {
            const policies = yield this.policyService.getAll(PolicyType.PasswordGenerator);
            let enforcedOptions = null;
            if (policies == null || policies.length === 0) {
                return enforcedOptions;
            }
            policies.forEach((currentPolicy) => {
                if (!currentPolicy.enabled || currentPolicy.data == null) {
                    return;
                }
                if (enforcedOptions == null) {
                    enforcedOptions = new passwordGeneratorPolicyOptions_PasswordGeneratorPolicyOptions();
                }
                // Password wins in multi-org collisions
                if (currentPolicy.data.defaultType != null && enforcedOptions.defaultType !== 'password') {
                    enforcedOptions.defaultType = currentPolicy.data.defaultType;
                }
                if (currentPolicy.data.minLength != null
                    && currentPolicy.data.minLength > enforcedOptions.minLength) {
                    enforcedOptions.minLength = currentPolicy.data.minLength;
                }
                if (currentPolicy.data.useUpper) {
                    enforcedOptions.useUppercase = true;
                }
                if (currentPolicy.data.useLower) {
                    enforcedOptions.useLowercase = true;
                }
                if (currentPolicy.data.useNumbers) {
                    enforcedOptions.useNumbers = true;
                }
                if (currentPolicy.data.minNumbers != null
                    && currentPolicy.data.minNumbers > enforcedOptions.numberCount) {
                    enforcedOptions.numberCount = currentPolicy.data.minNumbers;
                }
                if (currentPolicy.data.useSpecial) {
                    enforcedOptions.useSpecial = true;
                }
                if (currentPolicy.data.minSpecial != null
                    && currentPolicy.data.minSpecial > enforcedOptions.specialCount) {
                    enforcedOptions.specialCount = currentPolicy.data.minSpecial;
                }
                if (currentPolicy.data.minNumberWords != null
                    && currentPolicy.data.minNumberWords > enforcedOptions.minNumberWords) {
                    enforcedOptions.minNumberWords = currentPolicy.data.minNumberWords;
                }
                if (currentPolicy.data.capitalize) {
                    enforcedOptions.capitalize = true;
                }
                if (currentPolicy.data.includeNumber) {
                    enforcedOptions.includeNumber = true;
                }
            });
            return enforcedOptions;
        });
    }
    saveOptions(options) {
        return passwordGeneration_service_awaiter(this, void 0, void 0, function* () {
            yield this.storageService.save(passwordGeneration_service_Keys.options, options);
            this.optionsCache = options;
        });
    }
    getHistory() {
        return passwordGeneration_service_awaiter(this, void 0, void 0, function* () {
            const hasKey = yield this.cryptoService.hasKey();
            if (!hasKey) {
                return new Array();
            }
            if (!this.history) {
                const encrypted = yield this.storageService.get(passwordGeneration_service_Keys.history);
                this.history = yield this.decryptHistory(encrypted);
            }
            return this.history || new Array();
        });
    }
    addHistory(password) {
        return passwordGeneration_service_awaiter(this, void 0, void 0, function* () {
            // Cannot add new history if no key is available
            const hasKey = yield this.cryptoService.hasKey();
            if (!hasKey) {
                return;
            }
            const currentHistory = yield this.getHistory();
            // Prevent duplicates
            if (this.matchesPrevious(password, currentHistory)) {
                return;
            }
            currentHistory.unshift(new GeneratedPasswordHistory(password, Date.now()));
            // Remove old items.
            if (currentHistory.length > MaxPasswordsInHistory) {
                currentHistory.pop();
            }
            const newHistory = yield this.encryptHistory(currentHistory);
            return yield this.storageService.save(passwordGeneration_service_Keys.history, newHistory);
        });
    }
    clear() {
        return passwordGeneration_service_awaiter(this, void 0, void 0, function* () {
            this.history = [];
            return yield this.storageService.remove(passwordGeneration_service_Keys.history);
        });
    }
    passwordStrength(password, userInputs = null) {
        if (password == null || password.length === 0) {
            return null;
        }
        let globalUserInputs = ['bitwarden', 'bit', 'warden'];
        if (userInputs != null && userInputs.length > 0) {
            globalUserInputs = globalUserInputs.concat(userInputs);
        }
        // Use a hash set to get rid of any duplicate user inputs
        const finalUserInputs = Array.from(new Set(globalUserInputs));
        const result = external_zxcvbn_(password, finalUserInputs);
        return result;
    }
    normalizeOptions(options, enforcedPolicyOptions) {
        options.minLowercase = 0;
        options.minUppercase = 0;
        if (!options.length || options.length < 5) {
            options.length = 5;
        }
        else if (options.length > 128) {
            options.length = 128;
        }
        if (options.length < enforcedPolicyOptions.minLength) {
            options.length = enforcedPolicyOptions.minLength;
        }
        if (!options.minNumber) {
            options.minNumber = 0;
        }
        else if (options.minNumber > options.length) {
            options.minNumber = options.length;
        }
        else if (options.minNumber > 9) {
            options.minNumber = 9;
        }
        if (options.minNumber < enforcedPolicyOptions.numberCount) {
            options.minNumber = enforcedPolicyOptions.numberCount;
        }
        if (!options.minSpecial) {
            options.minSpecial = 0;
        }
        else if (options.minSpecial > options.length) {
            options.minSpecial = options.length;
        }
        else if (options.minSpecial > 9) {
            options.minSpecial = 9;
        }
        if (options.minSpecial < enforcedPolicyOptions.specialCount) {
            options.minSpecial = enforcedPolicyOptions.specialCount;
        }
        if (options.minSpecial + options.minNumber > options.length) {
            options.minSpecial = options.length - options.minNumber;
        }
        if (options.numWords == null || options.length < 3) {
            options.numWords = 3;
        }
        else if (options.numWords > 20) {
            options.numWords = 20;
        }
        if (options.numWords < enforcedPolicyOptions.minNumberWords) {
            options.numWords = enforcedPolicyOptions.minNumberWords;
        }
        if (options.wordSeparator != null && options.wordSeparator.length > 1) {
            options.wordSeparator = options.wordSeparator[0];
        }
        this.sanitizePasswordLength(options, false);
    }
    capitalize(str) {
        return str.charAt(0).toUpperCase() + str.slice(1);
    }
    appendRandomNumberToRandomWord(wordList) {
        return passwordGeneration_service_awaiter(this, void 0, void 0, function* () {
            if (wordList == null || wordList.length <= 0) {
                return;
            }
            const index = yield this.cryptoService.randomNumber(0, wordList.length - 1);
            const num = yield this.cryptoService.randomNumber(0, 9);
            wordList[index] = wordList[index] + num;
        });
    }
    encryptHistory(history) {
        return passwordGeneration_service_awaiter(this, void 0, void 0, function* () {
            if (history == null || history.length === 0) {
                return Promise.resolve([]);
            }
            const promises = history.map((item) => passwordGeneration_service_awaiter(this, void 0, void 0, function* () {
                const encrypted = yield this.cryptoService.encrypt(item.password);
                return new GeneratedPasswordHistory(encrypted.encryptedString, item.date);
            }));
            return yield Promise.all(promises);
        });
    }
    decryptHistory(history) {
        return passwordGeneration_service_awaiter(this, void 0, void 0, function* () {
            if (history == null || history.length === 0) {
                return Promise.resolve([]);
            }
            const promises = history.map((item) => passwordGeneration_service_awaiter(this, void 0, void 0, function* () {
                const decrypted = yield this.cryptoService.decryptToUtf8(new cipherString_CipherString(item.password));
                return new GeneratedPasswordHistory(decrypted, item.date);
            }));
            return yield Promise.all(promises);
        });
    }
    matchesPrevious(password, history) {
        if (history == null || history.length === 0) {
            return false;
        }
        return history[history.length - 1].password === password;
    }
    // ref: https://stackoverflow.com/a/12646864/1090359
    shuffleArray(array) {
        return passwordGeneration_service_awaiter(this, void 0, void 0, function* () {
            for (let i = array.length - 1; i > 0; i--) {
                const j = yield this.cryptoService.randomNumber(0, i);
                [array[i], array[j]] = [array[j], array[i]];
            }
        });
    }
    sanitizePasswordLength(options, forGeneration) {
        let minUppercaseCalc = 0;
        let minLowercaseCalc = 0;
        let minNumberCalc = options.minNumber;
        let minSpecialCalc = options.minSpecial;
        if (options.uppercase && options.minUppercase <= 0) {
            minUppercaseCalc = 1;
        }
        else if (!options.uppercase) {
            minUppercaseCalc = 0;
        }
        if (options.lowercase && options.minLowercase <= 0) {
            minLowercaseCalc = 1;
        }
        else if (!options.lowercase) {
            minLowercaseCalc = 0;
        }
        if (options.number && options.minNumber <= 0) {
            minNumberCalc = 1;
        }
        else if (!options.number) {
            minNumberCalc = 0;
        }
        if (options.special && options.minSpecial <= 0) {
            minSpecialCalc = 1;
        }
        else if (!options.special) {
            minSpecialCalc = 0;
        }
        // This should never happen but is a final safety net
        if (!options.length || options.length < 1) {
            options.length = 10;
        }
        const minLength = minUppercaseCalc + minLowercaseCalc + minNumberCalc + minSpecialCalc;
        // Normalize and Generation both require this modification
        if (options.length < minLength) {
            options.length = minLength;
        }
        // Apply other changes if the options object passed in is for generation
        if (forGeneration) {
            options.minUppercase = minUppercaseCalc;
            options.minLowercase = minLowercaseCalc;
            options.minNumber = minNumberCalc;
            options.minSpecial = minSpecialCalc;
        }
    }
}

// CONCATENATED MODULE: ./jslib/src/models/domain/masterPasswordPolicyOptions.ts

class masterPasswordPolicyOptions_MasterPasswordPolicyOptions extends domainBase_Domain {
    constructor() {
        super(...arguments);
        this.minComplexity = 0;
        this.minLength = 0;
        this.requireUpper = false;
        this.requireLower = false;
        this.requireNumbers = false;
        this.requireSpecial = false;
    }
}

// CONCATENATED MODULE: ./jslib/src/models/domain/policy.ts

class policy_Policy extends domainBase_Domain {
    constructor(obj) {
        super();
        if (obj == null) {
            return;
        }
        this.id = obj.id;
        this.organizationId = obj.organizationId;
        this.type = obj.type;
        this.data = obj.data;
        this.enabled = obj.enabled;
    }
}

// CONCATENATED MODULE: ./jslib/src/services/policy.service.ts
var policy_service_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};



const policy_service_Keys = {
    policiesPrefix: 'policies_',
};
class policy_service_PolicyService {
    constructor(userService, storageService) {
        this.userService = userService;
        this.storageService = storageService;
    }
    clearCache() {
        this.policyCache = null;
    }
    getAll(type) {
        return policy_service_awaiter(this, void 0, void 0, function* () {
            if (this.policyCache == null) {
                const userId = yield this.userService.getUserId();
                const policies = yield this.storageService.get(policy_service_Keys.policiesPrefix + userId);
                const response = [];
                for (const id in policies) {
                    if (policies.hasOwnProperty(id)) {
                        response.push(new policy_Policy(policies[id]));
                    }
                }
                this.policyCache = response;
            }
            if (type != null) {
                return this.policyCache.filter((p) => p.type === type);
            }
            else {
                return this.policyCache;
            }
        });
    }
    replace(policies) {
        return policy_service_awaiter(this, void 0, void 0, function* () {
            const userId = yield this.userService.getUserId();
            yield this.storageService.save(policy_service_Keys.policiesPrefix + userId, policies);
            this.policyCache = null;
        });
    }
    clear(userId) {
        return policy_service_awaiter(this, void 0, void 0, function* () {
            yield this.storageService.remove(policy_service_Keys.policiesPrefix + userId);
            this.policyCache = null;
        });
    }
    getMasterPasswordPolicyOptions(policies) {
        return policy_service_awaiter(this, void 0, void 0, function* () {
            let enforcedOptions = null;
            if (policies == null) {
                policies = yield this.getAll(PolicyType.MasterPassword);
            }
            else {
                policies = policies.filter((p) => p.type === PolicyType.MasterPassword);
            }
            if (policies == null || policies.length === 0) {
                return enforcedOptions;
            }
            policies.forEach((currentPolicy) => {
                if (!currentPolicy.enabled || currentPolicy.data == null) {
                    return;
                }
                if (enforcedOptions == null) {
                    enforcedOptions = new masterPasswordPolicyOptions_MasterPasswordPolicyOptions();
                }
                if (currentPolicy.data.minComplexity != null
                    && currentPolicy.data.minComplexity > enforcedOptions.minComplexity) {
                    enforcedOptions.minComplexity = currentPolicy.data.minComplexity;
                }
                if (currentPolicy.data.minLength != null
                    && currentPolicy.data.minLength > enforcedOptions.minLength) {
                    enforcedOptions.minLength = currentPolicy.data.minLength;
                }
                if (currentPolicy.data.requireUpper) {
                    enforcedOptions.requireUpper = true;
                }
                if (currentPolicy.data.requireLower) {
                    enforcedOptions.requireLower = true;
                }
                if (currentPolicy.data.requireNumbers) {
                    enforcedOptions.requireNumbers = true;
                }
                if (currentPolicy.data.requireSpecial) {
                    enforcedOptions.requireSpecial = true;
                }
            });
            return enforcedOptions;
        });
    }
    evaluateMasterPassword(passwordStrength, newPassword, enforcedPolicyOptions) {
        if (enforcedPolicyOptions == null) {
            return true;
        }
        if (enforcedPolicyOptions.minComplexity > 0 && enforcedPolicyOptions.minComplexity > passwordStrength) {
            return false;
        }
        if (enforcedPolicyOptions.minLength > 0 && enforcedPolicyOptions.minLength > newPassword.length) {
            return false;
        }
        if (enforcedPolicyOptions.requireUpper && newPassword.toLocaleLowerCase() === newPassword) {
            return false;
        }
        if (enforcedPolicyOptions.requireLower && newPassword.toLocaleUpperCase() === newPassword) {
            return false;
        }
        if (enforcedPolicyOptions.requireNumbers && !(/[0-9]/.test(newPassword))) {
            return false;
        }
        if (enforcedPolicyOptions.requireSpecial && !(/[!@#$%\^&*]/g.test(newPassword))) {
            return false;
        }
        return true;
    }
}

// EXTERNAL MODULE: external "lunr"
var external_lunr_ = __webpack_require__(9);

// CONCATENATED MODULE: ./jslib/src/services/search.service.ts
var search_service_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};





class search_service_SearchService {
    constructor(cipherService, platformUtilsService) {
        this.cipherService = cipherService;
        this.indexing = false;
        this.index = null;
        this.onlySearchName = false;
        this.onlySearchName = platformUtilsService == null ||
            platformUtilsService.getDevice() === DeviceType.EdgeExtension;
    }
    clearIndex() {
        this.index = null;
    }
    isSearchable(query) {
        const notSearchable = query == null || (this.index == null && query.length < 2) ||
            (this.index != null && query.length < 2 && query.indexOf('>') !== 0);
        return !notSearchable;
    }
    indexCiphers() {
        return search_service_awaiter(this, void 0, void 0, function* () {
            if (this.indexing) {
                return;
            }
            // tslint:disable-next-line
            console.time('search indexing');
            this.indexing = true;
            this.index = null;
            const builder = new external_lunr_["Builder"]();
            builder.ref('id');
            builder.field('shortid', { boost: 100, extractor: (c) => c.id.substr(0, 8) });
            builder.field('name', { boost: 10 });
            builder.field('subtitle', {
                boost: 5,
                extractor: (c) => {
                    if (c.subTitle != null && c.type === CipherType.Card) {
                        return c.subTitle.replace(/\*/g, '');
                    }
                    return c.subTitle;
                },
            });
            builder.field('notes');
            builder.field('login.username', {
                extractor: (c) => c.type === CipherType.Login && c.login != null ? c.login.username : null,
            });
            builder.field('login.uris', { boost: 2, extractor: (c) => this.uriExtractor(c) });
            builder.field('fields', { extractor: (c) => this.fieldExtractor(c, false) });
            builder.field('fields_joined', { extractor: (c) => this.fieldExtractor(c, true) });
            builder.field('attachments', { extractor: (c) => this.attachmentExtractor(c, false) });
            builder.field('attachments_joined', { extractor: (c) => this.attachmentExtractor(c, true) });
            builder.field('organizationid', { extractor: (c) => c.organizationId });
            const ciphers = yield this.cipherService.getAllDecrypted();
            ciphers.forEach((c) => builder.add(c));
            this.index = builder.build();
            this.indexing = false;
            // tslint:disable-next-line
            console.timeEnd('search indexing');
        });
    }
    searchCiphers(query, filter = null, ciphers = null) {
        return search_service_awaiter(this, void 0, void 0, function* () {
            const results = [];
            if (query != null) {
                query = query.trim().toLowerCase();
            }
            if (query === '') {
                query = null;
            }
            if (ciphers == null) {
                ciphers = yield this.cipherService.getAllDecrypted();
            }
            if (filter != null && Array.isArray(filter) && filter.length > 0) {
                ciphers = ciphers.filter((c) => filter.every((f) => f == null || f(c)));
            }
            else if (filter != null) {
                ciphers = ciphers.filter(filter);
            }
            if (!this.isSearchable(query)) {
                return ciphers;
            }
            if (this.indexing) {
                yield new Promise((r) => setTimeout(r, 250));
                if (this.indexing) {
                    yield new Promise((r) => setTimeout(r, 500));
                }
            }
            const index = this.getIndexForSearch();
            if (index == null) {
                // Fall back to basic search if index is not available
                return this.searchCiphersBasic(ciphers, query);
            }
            const ciphersMap = new Map();
            ciphers.forEach((c) => ciphersMap.set(c.id, c));
            let searchResults = null;
            const isQueryString = query != null && query.length > 1 && query.indexOf('>') === 0;
            if (isQueryString) {
                try {
                    searchResults = index.search(query.substr(1).trim());
                }
                catch (_a) { }
            }
            else {
                // tslint:disable-next-line
                const soWild = external_lunr_["Query"].wildcard.LEADING | external_lunr_["Query"].wildcard.TRAILING;
                searchResults = index.query((q) => {
                    external_lunr_["tokenizer"](query).forEach((token) => {
                        const t = token.toString();
                        q.term(t, { fields: ['name'], wildcard: soWild });
                        q.term(t, { fields: ['subtitle'], wildcard: soWild });
                        q.term(t, { fields: ['login.uris'], wildcard: soWild });
                        q.term(t, {});
                    });
                });
            }
            if (searchResults != null) {
                searchResults.forEach((r) => {
                    if (ciphersMap.has(r.ref)) {
                        results.push(ciphersMap.get(r.ref));
                    }
                });
            }
            return results;
        });
    }
    searchCiphersBasic(ciphers, query, deleted = false) {
        query = query.trim().toLowerCase();
        return ciphers.filter((c) => {
            if (deleted !== c.isDeleted) {
                return false;
            }
            if (c.name != null && c.name.toLowerCase().indexOf(query) > -1) {
                return true;
            }
            if (this.onlySearchName) {
                return false;
            }
            if (query.length >= 8 && c.id.startsWith(query)) {
                return true;
            }
            if (c.subTitle != null && c.subTitle.toLowerCase().indexOf(query) > -1) {
                return true;
            }
            if (c.login && c.login.uri != null && c.login.uri.toLowerCase().indexOf(query) > -1) {
                return true;
            }
            return false;
        });
    }
    getIndexForSearch() {
        return this.index;
    }
    fieldExtractor(c, joined) {
        if (!c.hasFields) {
            return null;
        }
        let fields = [];
        c.fields.forEach((f) => {
            if (f.name != null) {
                fields.push(f.name);
            }
            if (f.type === FieldType.Text && f.value != null) {
                fields.push(f.value);
            }
        });
        fields = fields.filter((f) => f.trim() !== '');
        if (fields.length === 0) {
            return null;
        }
        return joined ? fields.join(' ') : fields;
    }
    attachmentExtractor(c, joined) {
        if (!c.hasAttachments) {
            return null;
        }
        let attachments = [];
        c.attachments.forEach((a) => {
            if (a != null && a.fileName != null) {
                if (joined && a.fileName.indexOf('.') > -1) {
                    attachments.push(a.fileName.substr(0, a.fileName.lastIndexOf('.')));
                }
                else {
                    attachments.push(a.fileName);
                }
            }
        });
        attachments = attachments.filter((f) => f.trim() !== '');
        if (attachments.length === 0) {
            return null;
        }
        return joined ? attachments.join(' ') : attachments;
    }
    uriExtractor(c) {
        if (c.type !== CipherType.Login || c.login == null || !c.login.hasUris) {
            return null;
        }
        const uris = [];
        c.login.uris.forEach((u) => {
            if (u.uri == null || u.uri === '') {
                return;
            }
            if (u.hostname != null) {
                uris.push(u.hostname);
                return;
            }
            let uri = u.uri;
            if (u.match !== UriMatchType.RegularExpression) {
                const protocolIndex = uri.indexOf('://');
                if (protocolIndex > -1) {
                    uri = uri.substr(protocolIndex + 3);
                }
                const queryIndex = uri.search(/\?|&|#/);
                if (queryIndex > -1) {
                    uri = uri.substring(0, queryIndex);
                }
            }
            uris.push(uri);
        });
        return uris.length > 0 ? uris : null;
    }
}

// CONCATENATED MODULE: ./jslib/src/services/settings.service.ts
var settings_service_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const settings_service_Keys = {
    settingsPrefix: 'settings_',
    equivalentDomains: 'equivalentDomains',
};
class SettingsService {
    constructor(userService, storageService) {
        this.userService = userService;
        this.storageService = storageService;
    }
    clearCache() {
        this.settingsCache = null;
    }
    getEquivalentDomains() {
        return this.getSettingsKey(settings_service_Keys.equivalentDomains);
    }
    setEquivalentDomains(equivalentDomains) {
        return settings_service_awaiter(this, void 0, void 0, function* () {
            yield this.setSettingsKey(settings_service_Keys.equivalentDomains, equivalentDomains);
        });
    }
    clear(userId) {
        return settings_service_awaiter(this, void 0, void 0, function* () {
            yield this.storageService.remove(settings_service_Keys.settingsPrefix + userId);
            this.clearCache();
        });
    }
    // Helpers
    getSettings() {
        return settings_service_awaiter(this, void 0, void 0, function* () {
            if (this.settingsCache == null) {
                const userId = yield this.userService.getUserId();
                this.settingsCache = this.storageService.get(settings_service_Keys.settingsPrefix + userId);
            }
            return this.settingsCache;
        });
    }
    getSettingsKey(key) {
        return settings_service_awaiter(this, void 0, void 0, function* () {
            const settings = yield this.getSettings();
            if (settings != null && settings[key]) {
                return settings[key];
            }
            return null;
        });
    }
    setSettingsKey(key, value) {
        return settings_service_awaiter(this, void 0, void 0, function* () {
            const userId = yield this.userService.getUserId();
            let settings = yield this.getSettings();
            if (!settings) {
                settings = {};
            }
            settings[key] = value;
            yield this.storageService.save(settings_service_Keys.settingsPrefix + userId, settings);
            this.settingsCache = settings;
        });
    }
}

// CONCATENATED MODULE: ./jslib/src/models/data/organizationData.ts
class OrganizationData {
    constructor(response) {
        this.id = response.id;
        this.name = response.name;
        this.status = response.status;
        this.type = response.type;
        this.enabled = response.enabled;
        this.usePolicies = response.usePolicies;
        this.useGroups = response.useGroups;
        this.useDirectory = response.useDirectory;
        this.useEvents = response.useEvents;
        this.useTotp = response.useTotp;
        this.use2fa = response.use2fa;
        this.useApi = response.useApi;
        this.selfHost = response.selfHost;
        this.usersGetPremium = response.usersGetPremium;
        this.seats = response.seats;
        this.maxCollections = response.maxCollections;
        this.maxStorageGb = response.maxStorageGb;
    }
}

// CONCATENATED MODULE: ./jslib/src/models/data/policyData.ts
class PolicyData {
    constructor(response) {
        this.id = response.id;
        this.organizationId = response.organizationId;
        this.type = response.type;
        this.data = response.data;
        this.enabled = response.enabled;
    }
}

// CONCATENATED MODULE: ./jslib/src/services/sync.service.ts
var sync_service_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};





const sync_service_Keys = {
    lastSyncPrefix: 'lastSync_',
};
class sync_service_SyncService {
    constructor(userService, apiService, settingsService, folderService, cipherService, cryptoService, collectionService, storageService, messagingService, policyService, logoutCallback) {
        this.userService = userService;
        this.apiService = apiService;
        this.settingsService = settingsService;
        this.folderService = folderService;
        this.cipherService = cipherService;
        this.cryptoService = cryptoService;
        this.collectionService = collectionService;
        this.storageService = storageService;
        this.messagingService = messagingService;
        this.policyService = policyService;
        this.logoutCallback = logoutCallback;
        this.syncInProgress = false;
    }
    getLastSync() {
        return sync_service_awaiter(this, void 0, void 0, function* () {
            const userId = yield this.userService.getUserId();
            if (userId == null) {
                return null;
            }
            const lastSync = yield this.storageService.get(sync_service_Keys.lastSyncPrefix + userId);
            if (lastSync) {
                return new Date(lastSync);
            }
            return null;
        });
    }
    setLastSync(date) {
        return sync_service_awaiter(this, void 0, void 0, function* () {
            const userId = yield this.userService.getUserId();
            if (userId == null) {
                return;
            }
            yield this.storageService.save(sync_service_Keys.lastSyncPrefix + userId, date.toJSON());
        });
    }
    fullSync(forceSync, allowThrowOnError = false) {
        return sync_service_awaiter(this, void 0, void 0, function* () {
            this.syncStarted();
            const isAuthenticated = yield this.userService.isAuthenticated();
            if (!isAuthenticated) {
                return this.syncCompleted(false);
            }
            const now = new Date();
            const needsSyncResult = yield this.needsSyncing(forceSync);
            const needsSync = needsSyncResult[0];
            const skipped = needsSyncResult[1];
            if (skipped) {
                return this.syncCompleted(false);
            }
            if (!needsSync) {
                yield this.setLastSync(now);
                return this.syncCompleted(false);
            }
            const userId = yield this.userService.getUserId();
            try {
                const response = yield this.apiService.getSync();
                yield this.syncProfile(response.profile);
                yield this.syncFolders(userId, response.folders);
                yield this.syncCollections(response.collections);
                yield this.syncCiphers(userId, response.ciphers);
                yield this.syncSettings(userId, response.domains);
                yield this.syncPolicies(response.policies);
                yield this.setLastSync(now);
                return this.syncCompleted(true);
            }
            catch (e) {
                if (allowThrowOnError) {
                    throw e;
                }
                else {
                    return this.syncCompleted(false);
                }
            }
        });
    }
    syncUpsertFolder(notification, isEdit) {
        return sync_service_awaiter(this, void 0, void 0, function* () {
            this.syncStarted();
            if (yield this.userService.isAuthenticated()) {
                try {
                    const localFolder = yield this.folderService.get(notification.id);
                    if ((!isEdit && localFolder == null) ||
                        (isEdit && localFolder != null && localFolder.revisionDate < notification.revisionDate)) {
                        const remoteFolder = yield this.apiService.getFolder(notification.id);
                        if (remoteFolder != null) {
                            const userId = yield this.userService.getUserId();
                            yield this.folderService.upsert(new FolderData(remoteFolder, userId));
                            this.messagingService.send('syncedUpsertedFolder', { folderId: notification.id });
                            return this.syncCompleted(true);
                        }
                    }
                }
                catch (_a) { }
            }
            return this.syncCompleted(false);
        });
    }
    syncDeleteFolder(notification) {
        return sync_service_awaiter(this, void 0, void 0, function* () {
            this.syncStarted();
            if (yield this.userService.isAuthenticated()) {
                yield this.folderService.delete(notification.id);
                this.messagingService.send('syncedDeletedFolder', { folderId: notification.id });
                this.syncCompleted(true);
                return true;
            }
            return this.syncCompleted(false);
        });
    }
    syncUpsertCipher(notification, isEdit) {
        return sync_service_awaiter(this, void 0, void 0, function* () {
            this.syncStarted();
            if (yield this.userService.isAuthenticated()) {
                try {
                    let shouldUpdate = true;
                    const localCipher = yield this.cipherService.get(notification.id);
                    if (localCipher != null && localCipher.revisionDate >= notification.revisionDate) {
                        shouldUpdate = false;
                    }
                    let checkCollections = false;
                    if (shouldUpdate) {
                        if (isEdit) {
                            shouldUpdate = localCipher != null;
                            checkCollections = true;
                        }
                        else {
                            if (notification.collectionIds == null || notification.organizationId == null) {
                                shouldUpdate = localCipher == null;
                            }
                            else {
                                shouldUpdate = false;
                                checkCollections = true;
                            }
                        }
                    }
                    if (!shouldUpdate && checkCollections && notification.organizationId != null &&
                        notification.collectionIds != null && notification.collectionIds.length > 0) {
                        const collections = yield this.collectionService.getAll();
                        if (collections != null) {
                            for (let i = 0; i < collections.length; i++) {
                                if (notification.collectionIds.indexOf(collections[i].id) > -1) {
                                    shouldUpdate = true;
                                    break;
                                }
                            }
                        }
                    }
                    if (shouldUpdate) {
                        const remoteCipher = yield this.apiService.getCipher(notification.id);
                        if (remoteCipher != null) {
                            const userId = yield this.userService.getUserId();
                            yield this.cipherService.upsert(new cipherData_CipherData(remoteCipher, userId));
                            this.messagingService.send('syncedUpsertedCipher', { cipherId: notification.id });
                            return this.syncCompleted(true);
                        }
                    }
                }
                catch (e) {
                    if (e != null && e.statusCode === 404 && isEdit) {
                        yield this.cipherService.delete(notification.id);
                        this.messagingService.send('syncedDeletedCipher', { cipherId: notification.id });
                        return this.syncCompleted(true);
                    }
                }
            }
            return this.syncCompleted(false);
        });
    }
    syncDeleteCipher(notification) {
        return sync_service_awaiter(this, void 0, void 0, function* () {
            this.syncStarted();
            if (yield this.userService.isAuthenticated()) {
                yield this.cipherService.delete(notification.id);
                this.messagingService.send('syncedDeletedCipher', { cipherId: notification.id });
                return this.syncCompleted(true);
            }
            return this.syncCompleted(false);
        });
    }
    // Helpers
    syncStarted() {
        this.syncInProgress = true;
        this.messagingService.send('syncStarted');
    }
    syncCompleted(successfully) {
        this.syncInProgress = false;
        this.messagingService.send('syncCompleted', { successfully: successfully });
        return successfully;
    }
    needsSyncing(forceSync) {
        return sync_service_awaiter(this, void 0, void 0, function* () {
            if (forceSync) {
                return [true, false];
            }
            const lastSync = yield this.getLastSync();
            if (lastSync == null || lastSync.getTime() === 0) {
                return [true, false];
            }
            try {
                const response = yield this.apiService.getAccountRevisionDate();
                if (new Date(response) <= lastSync) {
                    return [false, false];
                }
                return [true, false];
            }
            catch (e) {
                return [false, true];
            }
        });
    }
    syncProfile(response) {
        return sync_service_awaiter(this, void 0, void 0, function* () {
            const stamp = yield this.userService.getSecurityStamp();
            if (stamp != null && stamp !== response.securityStamp) {
                if (this.logoutCallback != null) {
                    yield this.logoutCallback(true);
                }
                throw new Error('Stamp has changed');
            }
            yield this.cryptoService.setEncKey(response.key);
            yield this.cryptoService.setEncPrivateKey(response.privateKey);
            yield this.cryptoService.setOrgKeys(response.organizations);
            yield this.userService.setSecurityStamp(response.securityStamp);
            const organizations = {};
            response.organizations.forEach((o) => {
                organizations[o.id] = new OrganizationData(o);
            });
            return yield this.userService.replaceOrganizations(organizations);
        });
    }
    syncFolders(userId, response) {
        return sync_service_awaiter(this, void 0, void 0, function* () {
            const folders = {};
            response.forEach((f) => {
                folders[f.id] = new FolderData(f, userId);
            });
            return yield this.folderService.replace(folders);
        });
    }
    syncCollections(response) {
        return sync_service_awaiter(this, void 0, void 0, function* () {
            const collections = {};
            response.forEach((c) => {
                collections[c.id] = new CollectionData(c);
            });
            return yield this.collectionService.replace(collections);
        });
    }
    syncCiphers(userId, response) {
        return sync_service_awaiter(this, void 0, void 0, function* () {
            const ciphers = {};
            response.forEach((c) => {
                ciphers[c.id] = new cipherData_CipherData(c, userId);
            });
            return yield this.cipherService.replace(ciphers);
        });
    }
    syncSettings(userId, response) {
        return sync_service_awaiter(this, void 0, void 0, function* () {
            let eqDomains = [];
            if (response != null && response.equivalentDomains != null) {
                eqDomains = eqDomains.concat(response.equivalentDomains);
            }
            if (response != null && response.globalEquivalentDomains != null) {
                response.globalEquivalentDomains.forEach((global) => {
                    if (global.domains.length > 0) {
                        eqDomains.push(global.domains);
                    }
                });
            }
            return this.settingsService.setEquivalentDomains(eqDomains);
        });
    }
    syncPolicies(response) {
        return sync_service_awaiter(this, void 0, void 0, function* () {
            const policies = {};
            if (response != null) {
                response.forEach((p) => {
                    policies[p.id] = new PolicyData(p);
                });
            }
            return yield this.policyService.replace(policies);
        });
    }
}

// CONCATENATED MODULE: ./jslib/src/services/token.service.ts
var token_service_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};


const token_service_Keys = {
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    twoFactorTokenPrefix: 'twoFactorToken_',
};
class token_service_TokenService {
    constructor(storageService) {
        this.storageService = storageService;
    }
    setTokens(accessToken, refreshToken) {
        return Promise.all([
            this.setToken(accessToken),
            this.setRefreshToken(refreshToken),
        ]);
    }
    setToken(token) {
        return token_service_awaiter(this, void 0, void 0, function* () {
            this.token = token;
            this.decodedToken = null;
            if (yield this.skipTokenStorage()) {
                // if we have a vault timeout and the action is log out, don't store token
                return;
            }
            return this.storageService.save(token_service_Keys.accessToken, token);
        });
    }
    getToken() {
        return token_service_awaiter(this, void 0, void 0, function* () {
            if (this.token != null) {
                return this.token;
            }
            this.token = yield this.storageService.get(token_service_Keys.accessToken);
            return this.token;
        });
    }
    setRefreshToken(refreshToken) {
        return token_service_awaiter(this, void 0, void 0, function* () {
            this.refreshToken = refreshToken;
            if (yield this.skipTokenStorage()) {
                // if we have a vault timeout and the action is log out, don't store token
                return;
            }
            return this.storageService.save(token_service_Keys.refreshToken, refreshToken);
        });
    }
    getRefreshToken() {
        return token_service_awaiter(this, void 0, void 0, function* () {
            if (this.refreshToken != null) {
                return this.refreshToken;
            }
            this.refreshToken = yield this.storageService.get(token_service_Keys.refreshToken);
            return this.refreshToken;
        });
    }
    toggleTokens() {
        return token_service_awaiter(this, void 0, void 0, function* () {
            const token = yield this.getToken();
            const refreshToken = yield this.getRefreshToken();
            const timeout = yield this.storageService.get(ConstantsService.vaultTimeoutKey);
            const action = yield this.storageService.get(ConstantsService.vaultTimeoutActionKey);
            if ((timeout != null || timeout === 0) && action === 'logOut') {
                // if we have a vault timeout and the action is log out, reset tokens
                yield this.clearToken();
                this.token = token;
                this.refreshToken = refreshToken;
                return;
            }
            yield this.setToken(token);
            yield this.setRefreshToken(refreshToken);
        });
    }
    setTwoFactorToken(token, email) {
        return this.storageService.save(token_service_Keys.twoFactorTokenPrefix + email, token);
    }
    getTwoFactorToken(email) {
        return this.storageService.get(token_service_Keys.twoFactorTokenPrefix + email);
    }
    clearTwoFactorToken(email) {
        return this.storageService.remove(token_service_Keys.twoFactorTokenPrefix + email);
    }
    clearToken() {
        this.token = null;
        this.decodedToken = null;
        this.refreshToken = null;
        return Promise.all([
            this.storageService.remove(token_service_Keys.accessToken),
            this.storageService.remove(token_service_Keys.refreshToken),
        ]);
    }
    // jwthelper methods
    // ref https://github.com/auth0/angular-jwt/blob/master/src/angularJwt/services/jwt.js
    decodeToken() {
        if (this.decodedToken) {
            return this.decodedToken;
        }
        if (this.token == null) {
            throw new Error('Token not found.');
        }
        const parts = this.token.split('.');
        if (parts.length !== 3) {
            throw new Error('JWT must have 3 parts');
        }
        const decoded = utils_Utils.fromUrlB64ToUtf8(parts[1]);
        if (decoded == null) {
            throw new Error('Cannot decode the token');
        }
        this.decodedToken = JSON.parse(decoded);
        return this.decodedToken;
    }
    getTokenExpirationDate() {
        const decoded = this.decodeToken();
        if (typeof decoded.exp === 'undefined') {
            return null;
        }
        const d = new Date(0); // The 0 here is the key, which sets the date to the epoch
        d.setUTCSeconds(decoded.exp);
        return d;
    }
    tokenSecondsRemaining(offsetSeconds = 0) {
        const d = this.getTokenExpirationDate();
        if (d == null) {
            return 0;
        }
        const msRemaining = d.valueOf() - (new Date().valueOf() + (offsetSeconds * 1000));
        return Math.round(msRemaining / 1000);
    }
    tokenNeedsRefresh(minutes = 5) {
        const sRemaining = this.tokenSecondsRemaining();
        return sRemaining < (60 * minutes);
    }
    getUserId() {
        const decoded = this.decodeToken();
        if (typeof decoded.sub === 'undefined') {
            throw new Error('No user id found');
        }
        return decoded.sub;
    }
    getEmail() {
        const decoded = this.decodeToken();
        if (typeof decoded.email === 'undefined') {
            throw new Error('No email found');
        }
        return decoded.email;
    }
    getEmailVerified() {
        const decoded = this.decodeToken();
        if (typeof decoded.email_verified === 'undefined') {
            throw new Error('No email verification found');
        }
        return decoded.email_verified;
    }
    getName() {
        const decoded = this.decodeToken();
        if (typeof decoded.name === 'undefined') {
            return null;
        }
        return decoded.name;
    }
    getPremium() {
        const decoded = this.decodeToken();
        if (typeof decoded.premium === 'undefined') {
            return false;
        }
        return decoded.premium;
    }
    getIssuer() {
        const decoded = this.decodeToken();
        if (typeof decoded.iss === 'undefined') {
            throw new Error('No issuer found');
        }
        return decoded.iss;
    }
    skipTokenStorage() {
        return token_service_awaiter(this, void 0, void 0, function* () {
            const timeout = yield this.storageService.get(ConstantsService.vaultTimeoutKey);
            const action = yield this.storageService.get(ConstantsService.vaultTimeoutActionKey);
            return timeout != null && action === 'logOut';
        });
    }
}

// CONCATENATED MODULE: ./jslib/src/services/totp.service.ts
var totp_service_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};


const B32Chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';
const SteamChars = '23456789BCDFGHJKMNPQRTVWXY';
class totp_service_TotpService {
    constructor(storageService, cryptoFunctionService) {
        this.storageService = storageService;
        this.cryptoFunctionService = cryptoFunctionService;
    }
    getCode(key) {
        return totp_service_awaiter(this, void 0, void 0, function* () {
            if (key == null) {
                return null;
            }
            let period = 30;
            let alg = 'sha1';
            let digits = 6;
            let keyB32 = key;
            const isOtpAuth = key.toLowerCase().indexOf('otpauth://') === 0;
            const isSteamAuth = !isOtpAuth && key.toLowerCase().indexOf('steam://') === 0;
            if (isOtpAuth) {
                const params = utils_Utils.getQueryParams(key);
                if (params.has('digits') && params.get('digits') != null) {
                    try {
                        const digitParams = parseInt(params.get('digits').trim(), null);
                        if (digitParams > 10) {
                            digits = 10;
                        }
                        else if (digitParams > 0) {
                            digits = digitParams;
                        }
                    }
                    catch (_a) { }
                }
                if (params.has('period') && params.get('period') != null) {
                    try {
                        const periodParam = parseInt(params.get('period').trim(), null);
                        if (periodParam > 0) {
                            period = periodParam;
                        }
                    }
                    catch (_b) { }
                }
                if (params.has('secret') && params.get('secret') != null) {
                    keyB32 = params.get('secret');
                }
                if (params.has('algorithm') && params.get('algorithm') != null) {
                    const algParam = params.get('algorithm').toLowerCase();
                    if (algParam === 'sha1' || algParam === 'sha256' || algParam === 'sha512') {
                        alg = algParam;
                    }
                }
            }
            else if (isSteamAuth) {
                keyB32 = key.substr('steam://'.length);
                digits = 5;
            }
            const epoch = Math.round(new Date().getTime() / 1000.0);
            const timeHex = this.leftPad(this.decToHex(Math.floor(epoch / period)), 16, '0');
            const timeBytes = utils_Utils.fromHexToArray(timeHex);
            const keyBytes = this.b32ToBytes(keyB32);
            if (!keyBytes.length || !timeBytes.length) {
                return null;
            }
            const hash = yield this.sign(keyBytes, timeBytes, alg);
            if (hash.length === 0) {
                return null;
            }
            /* tslint:disable */
            const offset = (hash[hash.length - 1] & 0xf);
            const binary = ((hash[offset] & 0x7f) << 24) | ((hash[offset + 1] & 0xff) << 16) |
                ((hash[offset + 2] & 0xff) << 8) | (hash[offset + 3] & 0xff);
            /* tslint:enable */
            let otp = '';
            if (isSteamAuth) {
                // tslint:disable-next-line
                let fullCode = binary & 0x7fffffff;
                for (let i = 0; i < digits; i++) {
                    otp += SteamChars[fullCode % SteamChars.length];
                    fullCode = Math.trunc(fullCode / SteamChars.length);
                }
            }
            else {
                otp = (binary % Math.pow(10, digits)).toString();
                otp = this.leftPad(otp, digits, '0');
            }
            return otp;
        });
    }
    getTimeInterval(key) {
        let period = 30;
        if (key != null && key.toLowerCase().indexOf('otpauth://') === 0) {
            const params = utils_Utils.getQueryParams(key);
            if (params.has('period') && params.get('period') != null) {
                try {
                    period = parseInt(params.get('period').trim(), null);
                }
                catch (_a) { }
            }
        }
        return period;
    }
    isAutoCopyEnabled() {
        return totp_service_awaiter(this, void 0, void 0, function* () {
            return !(yield this.storageService.get(ConstantsService.disableAutoTotpCopyKey));
        });
    }
    // Helpers
    leftPad(s, l, p) {
        if (l + 1 >= s.length) {
            s = Array(l + 1 - s.length).join(p) + s;
        }
        return s;
    }
    decToHex(d) {
        return (d < 15.5 ? '0' : '') + Math.round(d).toString(16);
    }
    b32ToHex(s) {
        s = s.toUpperCase();
        let cleanedInput = '';
        for (let i = 0; i < s.length; i++) {
            if (B32Chars.indexOf(s[i]) < 0) {
                continue;
            }
            cleanedInput += s[i];
        }
        s = cleanedInput;
        let bits = '';
        let hex = '';
        for (let i = 0; i < s.length; i++) {
            const byteIndex = B32Chars.indexOf(s.charAt(i));
            if (byteIndex < 0) {
                continue;
            }
            bits += this.leftPad(byteIndex.toString(2), 5, '0');
        }
        for (let i = 0; i + 4 <= bits.length; i += 4) {
            const chunk = bits.substr(i, 4);
            hex = hex + parseInt(chunk, 2).toString(16);
        }
        return hex;
    }
    b32ToBytes(s) {
        return utils_Utils.fromHexToArray(this.b32ToHex(s));
    }
    sign(keyBytes, timeBytes, alg) {
        return totp_service_awaiter(this, void 0, void 0, function* () {
            const signature = yield this.cryptoFunctionService.hmac(timeBytes.buffer, keyBytes.buffer, alg);
            return new Uint8Array(signature);
        });
    }
}

// CONCATENATED MODULE: ./jslib/src/enums/organizationUserStatusType.ts
var OrganizationUserStatusType;
(function (OrganizationUserStatusType) {
    OrganizationUserStatusType[OrganizationUserStatusType["Invited"] = 0] = "Invited";
    OrganizationUserStatusType[OrganizationUserStatusType["Accepted"] = 1] = "Accepted";
    OrganizationUserStatusType[OrganizationUserStatusType["Confirmed"] = 2] = "Confirmed";
})(OrganizationUserStatusType || (OrganizationUserStatusType = {}));

// CONCATENATED MODULE: ./jslib/src/enums/organizationUserType.ts
var OrganizationUserType;
(function (OrganizationUserType) {
    OrganizationUserType[OrganizationUserType["Owner"] = 0] = "Owner";
    OrganizationUserType[OrganizationUserType["Admin"] = 1] = "Admin";
    OrganizationUserType[OrganizationUserType["User"] = 2] = "User";
    OrganizationUserType[OrganizationUserType["Manager"] = 3] = "Manager";
})(OrganizationUserType || (OrganizationUserType = {}));

// CONCATENATED MODULE: ./jslib/src/models/domain/organization.ts


class organization_Organization {
    constructor(obj) {
        if (obj == null) {
            return;
        }
        this.id = obj.id;
        this.name = obj.name;
        this.status = obj.status;
        this.type = obj.type;
        this.enabled = obj.enabled;
        this.usePolicies = obj.usePolicies;
        this.useGroups = obj.useGroups;
        this.useDirectory = obj.useDirectory;
        this.useEvents = obj.useEvents;
        this.useTotp = obj.useTotp;
        this.use2fa = obj.use2fa;
        this.useApi = obj.useApi;
        this.selfHost = obj.selfHost;
        this.usersGetPremium = obj.usersGetPremium;
        this.seats = obj.seats;
        this.maxCollections = obj.maxCollections;
        this.maxStorageGb = obj.maxStorageGb;
    }
    get canAccess() {
        if (this.type === OrganizationUserType.Owner) {
            return true;
        }
        return this.enabled && this.status === OrganizationUserStatusType.Confirmed;
    }
    get isManager() {
        return this.type === OrganizationUserType.Manager || this.type === OrganizationUserType.Owner ||
            this.type === OrganizationUserType.Admin;
    }
    get isAdmin() {
        return this.type === OrganizationUserType.Owner || this.type === OrganizationUserType.Admin;
    }
    get isOwner() {
        return this.type === OrganizationUserType.Owner;
    }
}

// CONCATENATED MODULE: ./jslib/src/services/user.service.ts
var user_service_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};

const user_service_Keys = {
    userId: 'userId',
    userEmail: 'userEmail',
    stamp: 'securityStamp',
    kdf: 'kdf',
    kdfIterations: 'kdfIterations',
    organizationsPrefix: 'organizations_',
};
class user_service_UserService {
    constructor(tokenService, storageService) {
        this.tokenService = tokenService;
        this.storageService = storageService;
    }
    setInformation(userId, email, kdf, kdfIterations) {
        this.email = email;
        this.userId = userId;
        this.kdf = kdf;
        this.kdfIterations = kdfIterations;
        return Promise.all([
            this.storageService.save(user_service_Keys.userEmail, email),
            this.storageService.save(user_service_Keys.userId, userId),
            this.storageService.save(user_service_Keys.kdf, kdf),
            this.storageService.save(user_service_Keys.kdfIterations, kdfIterations),
        ]);
    }
    setSecurityStamp(stamp) {
        this.stamp = stamp;
        return this.storageService.save(user_service_Keys.stamp, stamp);
    }
    getUserId() {
        return user_service_awaiter(this, void 0, void 0, function* () {
            if (this.userId == null) {
                this.userId = yield this.storageService.get(user_service_Keys.userId);
            }
            return this.userId;
        });
    }
    getEmail() {
        return user_service_awaiter(this, void 0, void 0, function* () {
            if (this.email == null) {
                this.email = yield this.storageService.get(user_service_Keys.userEmail);
            }
            return this.email;
        });
    }
    getSecurityStamp() {
        return user_service_awaiter(this, void 0, void 0, function* () {
            if (this.stamp == null) {
                this.stamp = yield this.storageService.get(user_service_Keys.stamp);
            }
            return this.stamp;
        });
    }
    getKdf() {
        return user_service_awaiter(this, void 0, void 0, function* () {
            if (this.kdf == null) {
                this.kdf = yield this.storageService.get(user_service_Keys.kdf);
            }
            return this.kdf;
        });
    }
    getKdfIterations() {
        return user_service_awaiter(this, void 0, void 0, function* () {
            if (this.kdfIterations == null) {
                this.kdfIterations = yield this.storageService.get(user_service_Keys.kdfIterations);
            }
            return this.kdfIterations;
        });
    }
    clear() {
        return user_service_awaiter(this, void 0, void 0, function* () {
            const userId = yield this.getUserId();
            yield Promise.all([
                this.storageService.remove(user_service_Keys.userId),
                this.storageService.remove(user_service_Keys.userEmail),
                this.storageService.remove(user_service_Keys.stamp),
                this.storageService.remove(user_service_Keys.kdf),
                this.storageService.remove(user_service_Keys.kdfIterations),
                this.clearOrganizations(userId),
            ]);
            this.userId = this.email = this.stamp = null;
            this.kdf = null;
            this.kdfIterations = null;
        });
    }
    isAuthenticated() {
        return user_service_awaiter(this, void 0, void 0, function* () {
            const token = yield this.tokenService.getToken();
            if (token == null) {
                return false;
            }
            const userId = yield this.getUserId();
            return userId != null;
        });
    }
    canAccessPremium() {
        return user_service_awaiter(this, void 0, void 0, function* () {
            const tokenPremium = this.tokenService.getPremium();
            if (tokenPremium) {
                return true;
            }
            const orgs = yield this.getAllOrganizations();
            for (let i = 0; i < orgs.length; i++) {
                if (orgs[i].usersGetPremium && orgs[i].enabled) {
                    return true;
                }
            }
            return false;
        });
    }
    getOrganization(id) {
        return user_service_awaiter(this, void 0, void 0, function* () {
            const userId = yield this.getUserId();
            const organizations = yield this.storageService.get(user_service_Keys.organizationsPrefix + userId);
            if (organizations == null || !organizations.hasOwnProperty(id)) {
                return null;
            }
            return new organization_Organization(organizations[id]);
        });
    }
    getAllOrganizations() {
        return user_service_awaiter(this, void 0, void 0, function* () {
            const userId = yield this.getUserId();
            const organizations = yield this.storageService.get(user_service_Keys.organizationsPrefix + userId);
            const response = [];
            for (const id in organizations) {
                if (organizations.hasOwnProperty(id)) {
                    response.push(new organization_Organization(organizations[id]));
                }
            }
            return response;
        });
    }
    replaceOrganizations(organizations) {
        return user_service_awaiter(this, void 0, void 0, function* () {
            const userId = yield this.getUserId();
            yield this.storageService.save(user_service_Keys.organizationsPrefix + userId, organizations);
        });
    }
    clearOrganizations(userId) {
        return user_service_awaiter(this, void 0, void 0, function* () {
            yield this.storageService.remove(user_service_Keys.organizationsPrefix + userId);
        });
    }
}

// CONCATENATED MODULE: ./jslib/src/services/vaultTimeout.service.ts
var vaultTimeout_service_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};

class vaultTimeout_service_VaultTimeoutService {
    constructor(cipherService, folderService, collectionService, cryptoService, platformUtilsService, storageService, messagingService, searchService, userService, tokenService, lockedCallback = null, loggedOutCallback = null) {
        this.cipherService = cipherService;
        this.folderService = folderService;
        this.collectionService = collectionService;
        this.cryptoService = cryptoService;
        this.platformUtilsService = platformUtilsService;
        this.storageService = storageService;
        this.messagingService = messagingService;
        this.searchService = searchService;
        this.userService = userService;
        this.tokenService = tokenService;
        this.lockedCallback = lockedCallback;
        this.loggedOutCallback = loggedOutCallback;
        this.pinProtectedKey = null;
        this.inited = false;
    }
    init(checkOnInterval) {
        if (this.inited) {
            return;
        }
        this.inited = true;
        if (checkOnInterval) {
            this.checkVaultTimeout();
            setInterval(() => this.checkVaultTimeout(), 10 * 1000); // check every 10 seconds
        }
    }
    // Keys aren't stored for a device that is locked or logged out.
    isLocked() {
        return vaultTimeout_service_awaiter(this, void 0, void 0, function* () {
            const hasKey = yield this.cryptoService.hasKey();
            return !hasKey;
        });
    }
    checkVaultTimeout() {
        return vaultTimeout_service_awaiter(this, void 0, void 0, function* () {
            if (yield this.platformUtilsService.isViewOpen()) {
                // Do not lock
                return;
            }
            // "is logged out check" - similar to isLocked, below
            const authed = yield this.userService.isAuthenticated();
            if (!authed) {
                return;
            }
            if (yield this.isLocked()) {
                return;
            }
            // This has the potential to be removed. Evaluate after all platforms complete with auto-logout
            let vaultTimeout = this.platformUtilsService.lockTimeout();
            if (vaultTimeout == null) {
                vaultTimeout = yield this.storageService.get(ConstantsService.vaultTimeoutKey);
            }
            if (vaultTimeout == null || vaultTimeout < 0) {
                return;
            }
            const lastActive = yield this.storageService.get(ConstantsService.lastActiveKey);
            if (lastActive == null) {
                return;
            }
            const vaultTimeoutSeconds = vaultTimeout * 60;
            const diffSeconds = ((new Date()).getTime() - lastActive) / 1000;
            if (diffSeconds >= vaultTimeoutSeconds) {
                // Pivot based on the saved vault timeout action
                const timeoutAction = yield this.storageService.get(ConstantsService.vaultTimeoutActionKey);
                timeoutAction === 'logOut' ? yield this.logOut() : yield this.lock(true);
            }
        });
    }
    lock(allowSoftLock = false) {
        return vaultTimeout_service_awaiter(this, void 0, void 0, function* () {
            const authed = yield this.userService.isAuthenticated();
            if (!authed) {
                return;
            }
            yield Promise.all([
                this.cryptoService.clearKey(),
                this.cryptoService.clearOrgKeys(true),
                this.cryptoService.clearKeyPair(true),
                this.cryptoService.clearEncKey(true),
            ]);
            this.folderService.clearCache();
            this.cipherService.clearCache();
            this.collectionService.clearCache();
            this.searchService.clearIndex();
            this.messagingService.send('locked');
            if (this.lockedCallback != null) {
                yield this.lockedCallback();
            }
        });
    }
    logOut() {
        return vaultTimeout_service_awaiter(this, void 0, void 0, function* () {
            if (this.loggedOutCallback != null) {
                yield this.loggedOutCallback();
            }
        });
    }
    setVaultTimeoutOptions(timeout, action) {
        return vaultTimeout_service_awaiter(this, void 0, void 0, function* () {
            yield this.storageService.save(ConstantsService.vaultTimeoutKey, timeout);
            yield this.storageService.save(ConstantsService.vaultTimeoutActionKey, action);
            yield this.cryptoService.toggleKey();
            yield this.tokenService.toggleTokens();
        });
    }
    isPinLockSet() {
        return vaultTimeout_service_awaiter(this, void 0, void 0, function* () {
            const protectedPin = yield this.storageService.get(ConstantsService.protectedPin);
            const pinProtectedKey = yield this.storageService.get(ConstantsService.pinProtectedKey);
            return [protectedPin != null, pinProtectedKey != null];
        });
    }
    clear() {
        this.pinProtectedKey = null;
        return this.storageService.remove(ConstantsService.protectedPin);
    }
}

// EXTERNAL MODULE: external "chalk"
var external_chalk_ = __webpack_require__(10);
var external_chalk_default = /*#__PURE__*/__webpack_require__.n(external_chalk_);

// EXTERNAL MODULE: external "commander"
var external_commander_ = __webpack_require__(0);

// CONCATENATED MODULE: ./jslib/src/cli/models/response.ts
class Response {
    static error(error, data) {
        const res = new Response();
        res.success = false;
        if (typeof (error) === 'string') {
            res.message = error;
        }
        else {
            res.message = error.message != null ? error.message : error.toString();
        }
        res.data = data;
        return res;
    }
    static notFound() {
        return Response.error('Not found.');
    }
    static badRequest(message) {
        return Response.error(message);
    }
    static multipleResults(ids) {
        let msg = 'More than one result was found. Try getting a specific object by `id` instead. ' +
            'The following objects were found:';
        ids.forEach((id) => {
            msg += '\n' + id;
        });
        return Response.error(msg, ids);
    }
    static success(data) {
        const res = new Response();
        res.success = true;
        res.data = data;
        return res;
    }
}

// CONCATENATED MODULE: ./jslib/src/cli/models/response/messageResponse.ts
class MessageResponse {
    constructor(title, message) {
        this.noColor = false;
        this.object = 'message';
        this.title = title;
        this.message = message;
    }
}

// CONCATENATED MODULE: ./jslib/src/cli/models/response/stringResponse.ts
class StringResponse {
    constructor(data) {
        this.object = 'string';
        this.data = data;
    }
}

// CONCATENATED MODULE: ./src/commands/config.command.ts
var config_command_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};



class config_command_ConfigCommand {
    constructor(environmentService) {
        this.environmentService = environmentService;
    }
    run(setting, value, cmd) {
        return config_command_awaiter(this, void 0, void 0, function* () {
            setting = setting.toLowerCase();
            switch (setting) {
                case 'server':
                    return yield this.getOrSetServer(value, cmd);
                default:
                    return Response.badRequest('Unknown setting.');
            }
        });
    }
    getOrSetServer(url, cmd) {
        return config_command_awaiter(this, void 0, void 0, function* () {
            if ((url == null || url.trim() === '') &&
                !cmd.webVault && !cmd.api && !cmd.identity && !cmd.icons && !cmd.notifications && !cmd.events) {
                const baseUrl = this.environmentService.baseUrl;
                const stringRes = new StringResponse(baseUrl == null ? 'https://bitwarden.com' : baseUrl);
                return Response.success(stringRes);
            }
            url = (url === 'null' || url === 'bitwarden.com' || url === 'https://bitwarden.com' ? null : url);
            yield this.environmentService.setUrls({
                base: url,
                webVault: cmd.webVault || null,
                api: cmd.api || null,
                identity: cmd.identity || null,
                icons: cmd.icons || null,
                notifications: cmd.notifications || null,
                events: cmd.events || null,
            });
            const res = new MessageResponse('Saved setting `config`.', null);
            return Response.success(res);
        });
    }
}

// CONCATENATED MODULE: ./jslib/src/models/request/organizationUserConfirmRequest.ts
class OrganizationUserConfirmRequest {
}

// CONCATENATED MODULE: ./src/commands/confirm.command.ts
var confirm_command_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};



class confirm_command_ConfirmCommand {
    constructor(apiService, cryptoService) {
        this.apiService = apiService;
        this.cryptoService = cryptoService;
    }
    run(object, id, cmd) {
        return confirm_command_awaiter(this, void 0, void 0, function* () {
            if (id != null) {
                id = id.toLowerCase();
            }
            switch (object.toLowerCase()) {
                case 'org-member':
                    return yield this.confirmOrganizationMember(id, cmd);
                default:
                    return Response.badRequest('Unknown object.');
            }
        });
    }
    confirmOrganizationMember(id, cmd) {
        return confirm_command_awaiter(this, void 0, void 0, function* () {
            if (cmd.organizationid == null || cmd.organizationid === '') {
                return Response.badRequest('--organizationid <organizationid> required.');
            }
            if (!utils_Utils.isGuid(id)) {
                return Response.error('`' + id + '` is not a GUID.');
            }
            if (!utils_Utils.isGuid(cmd.organizationid)) {
                return Response.error('`' + cmd.organizationid + '` is not a GUID.');
            }
            try {
                const orgKey = yield this.cryptoService.getOrgKey(cmd.organizationid);
                if (orgKey == null) {
                    throw new Error('No encryption key for this organization.');
                }
                const orgUser = yield this.apiService.getOrganizationUser(cmd.organizationid, id);
                if (orgUser == null) {
                    throw new Error('Member id does not exist for this organization.');
                }
                const publicKeyResponse = yield this.apiService.getUserPublicKey(orgUser.userId);
                const publicKey = utils_Utils.fromB64ToArray(publicKeyResponse.publicKey);
                const key = yield this.cryptoService.rsaEncrypt(orgKey.key, publicKey.buffer);
                const req = new OrganizationUserConfirmRequest();
                req.key = key.encryptedString;
                yield this.apiService.postOrganizationUserConfirm(cmd.organizationid, id, req);
                return Response.success();
            }
            catch (e) {
                return Response.error(e);
            }
        });
    }
}

// CONCATENATED MODULE: ./jslib/src/models/request/selectionReadOnlyRequest.ts
class SelectionReadOnlyRequest {
    constructor(id, readOnly) {
        this.id = id;
        this.readOnly = readOnly;
    }
}

// CONCATENATED MODULE: ./src/models/response/attachmentResponse.ts
class response_attachmentResponse_AttachmentResponse {
    constructor(o) {
        this.id = o.id;
        this.fileName = o.fileName;
        this.size = o.size;
        this.sizeName = o.sizeName;
        this.url = o.url;
    }
}

// CONCATENATED MODULE: ./src/models/response/loginResponse.ts

class loginResponse_LoginResponse extends export_login_Login {
    constructor(o) {
        super(o);
        this.passwordRevisionDate = o.passwordRevisionDate != null ? o.passwordRevisionDate : null;
    }
}

// CONCATENATED MODULE: ./src/models/response/passwordHistoryResponse.ts
class response_passwordHistoryResponse_PasswordHistoryResponse {
    constructor(o) {
        this.lastUsedDate = o.lastUsedDate;
        this.password = o.password;
    }
}

// CONCATENATED MODULE: ./jslib/src/enums/logLevelType.ts
var LogLevelType;
(function (LogLevelType) {
    LogLevelType[LogLevelType["Debug"] = 0] = "Debug";
    LogLevelType[LogLevelType["Info"] = 1] = "Info";
    LogLevelType[LogLevelType["Warning"] = 2] = "Warning";
    LogLevelType[LogLevelType["Error"] = 3] = "Error";
})(LogLevelType || (LogLevelType = {}));

// CONCATENATED MODULE: ./jslib/src/enums/index.ts









// CONCATENATED MODULE: ./src/models/response/cipherResponse.ts





class response_cipherResponse_CipherResponse extends cipherWithIds_CipherWithIds {
    constructor(o) {
        super();
        this.object = 'item';
        this.build(o);
        if (o.attachments != null) {
            this.attachments = o.attachments.map((a) => new response_attachmentResponse_AttachmentResponse(a));
        }
        this.revisionDate = o.revisionDate;
        if (o.passwordHistory != null) {
            this.passwordHistory = o.passwordHistory.map((h) => new response_passwordHistoryResponse_PasswordHistoryResponse(h));
        }
        if (o.type === CipherType.Login && o.login != null) {
            this.login = new loginResponse_LoginResponse(o.login);
        }
    }
}

// CONCATENATED MODULE: ./src/models/response/folderResponse.ts

class response_folderResponse_FolderResponse extends folderWithId_FolderWithId {
    constructor(o) {
        super();
        this.object = 'folder';
        this.build(o);
    }
}

// CONCATENATED MODULE: ./src/models/response/collectionResponse.ts

class response_collectionResponse_CollectionResponse extends collectionWithId_CollectionWithId {
    constructor(o) {
        super();
        this.object = 'collection';
        this.build(o);
    }
}

// CONCATENATED MODULE: ./src/models/response/organizationCollectionResponse.ts

class organizationCollectionResponse_OrganizationCollectionResponse extends response_collectionResponse_CollectionResponse {
    constructor(o, groups) {
        super(o);
        this.object = 'org-collection';
        this.groups = groups;
    }
}

// CONCATENATED MODULE: ./src/utils.ts



class utils_CliUtils {
    static writeLn(s, finalLine = false, error = false) {
        const stream = error ? process.stderr : process.stdout;
        if (finalLine && (process.platform === 'win32' || !stream.isTTY)) {
            stream.write(s);
        }
        else {
            stream.write(s + '\n');
        }
    }
    static readFile(input) {
        return new Promise((resolve, reject) => {
            let p = null;
            if (input != null && input !== '') {
                const osInput = external_path_["join"](input);
                if (osInput.indexOf(external_path_["sep"]) === -1) {
                    p = external_path_["join"](process.cwd(), osInput);
                }
                else {
                    p = osInput;
                }
            }
            else {
                reject('You must specify a file path.');
            }
            external_fs_["readFile"](p, 'utf8', (err, data) => {
                if (err != null) {
                    reject(err.message);
                }
                resolve(data);
            });
        });
    }
    static saveFile(data, output, defaultFileName) {
        let p = null;
        let mkdir = false;
        if (output != null && output !== '') {
            const osOutput = external_path_["join"](output);
            if (osOutput.indexOf(external_path_["sep"]) === -1) {
                p = external_path_["join"](process.cwd(), osOutput);
            }
            else {
                mkdir = true;
                if (osOutput.endsWith(external_path_["sep"])) {
                    p = external_path_["join"](osOutput, defaultFileName);
                }
                else {
                    p = osOutput;
                }
            }
        }
        else {
            p = external_path_["join"](process.cwd(), defaultFileName);
        }
        p = external_path_["resolve"](p);
        if (mkdir) {
            const dir = p.substring(0, p.lastIndexOf(external_path_["sep"]));
            if (!external_fs_["existsSync"](dir)) {
                nodeUtils_NodeUtils.mkdirpSync(dir, '700');
            }
        }
        return new Promise((resolve, reject) => {
            external_fs_["writeFile"](p, data, 'utf8', (err) => {
                if (err != null) {
                    reject('Cannot save file to ' + p);
                }
                resolve(p);
            });
        });
    }
    static readStdin() {
        return new Promise((resolve, reject) => {
            let input = '';
            if (process.stdin.isTTY) {
                resolve(input);
                return;
            }
            process.stdin.setEncoding('utf8');
            process.stdin.on('readable', () => {
                while (true) {
                    const chunk = process.stdin.read();
                    if (chunk == null) {
                        break;
                    }
                    input += chunk;
                }
            });
            process.stdin.on('end', () => {
                resolve(input);
            });
        });
    }
    static searchFolders(folders, search) {
        search = search.toLowerCase();
        return folders.filter((f) => {
            if (f.name != null && f.name.toLowerCase().indexOf(search) > -1) {
                return true;
            }
            return false;
        });
    }
    static searchCollections(collections, search) {
        search = search.toLowerCase();
        return collections.filter((c) => {
            if (c.name != null && c.name.toLowerCase().indexOf(search) > -1) {
                return true;
            }
            return false;
        });
    }
    static searchOrganizations(organizations, search) {
        search = search.toLowerCase();
        return organizations.filter((o) => {
            if (o.name != null && o.name.toLowerCase().indexOf(search) > -1) {
                return true;
            }
            return false;
        });
    }
}

// CONCATENATED MODULE: ./src/commands/create.command.ts
var create_command_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};













class create_command_CreateCommand {
    constructor(cipherService, folderService, userService, cryptoService, apiService) {
        this.cipherService = cipherService;
        this.folderService = folderService;
        this.userService = userService;
        this.cryptoService = cryptoService;
        this.apiService = apiService;
    }
    run(object, requestJson, cmd) {
        return create_command_awaiter(this, void 0, void 0, function* () {
            let req = null;
            if (object !== 'attachment') {
                if (requestJson == null || requestJson === '') {
                    requestJson = yield utils_CliUtils.readStdin();
                }
                if (requestJson == null || requestJson === '') {
                    return Response.badRequest('`requestJson` was not provided.');
                }
                try {
                    const reqJson = Buffer.from(requestJson, 'base64').toString();
                    req = JSON.parse(reqJson);
                }
                catch (e) {
                    return Response.badRequest('Error parsing the encoded request data.');
                }
            }
            switch (object.toLowerCase()) {
                case 'item':
                    return yield this.createCipher(req);
                case 'attachment':
                    return yield this.createAttachment(cmd);
                case 'folder':
                    return yield this.createFolder(req);
                case 'org-collection':
                    return yield this.createOrganizationCollection(req, cmd);
                default:
                    return Response.badRequest('Unknown object.');
            }
        });
    }
    createCipher(req) {
        return create_command_awaiter(this, void 0, void 0, function* () {
            const cipher = yield this.cipherService.encrypt(export_cipher_Cipher.toView(req));
            try {
                yield this.cipherService.saveWithServer(cipher);
                const newCipher = yield this.cipherService.get(cipher.id);
                const decCipher = yield newCipher.decrypt();
                const res = new response_cipherResponse_CipherResponse(decCipher);
                return Response.success(res);
            }
            catch (e) {
                return Response.error(e);
            }
        });
    }
    createAttachment(cmd) {
        return create_command_awaiter(this, void 0, void 0, function* () {
            if (cmd.itemid == null || cmd.itemid === '') {
                return Response.badRequest('--itemid <itemid> required.');
            }
            if (cmd.file == null || cmd.file === '') {
                return Response.badRequest('--file <file> required.');
            }
            const filePath = external_path_["resolve"](cmd.file);
            if (!external_fs_["existsSync"](cmd.file)) {
                return Response.badRequest('Cannot find file at ' + filePath);
            }
            const itemId = cmd.itemid.toLowerCase();
            const cipher = yield this.cipherService.get(itemId);
            if (cipher == null) {
                return Response.notFound();
            }
            if (cipher.organizationId == null && !(yield this.userService.canAccessPremium())) {
                return Response.error('Premium status is required to use this feature.');
            }
            const encKey = yield this.cryptoService.getEncKey();
            if (encKey == null) {
                return Response.error('You must update your encryption key before you can use this feature. ' +
                    'See https://help.bitwarden.com/article/update-encryption-key/');
            }
            try {
                const fileBuf = external_fs_["readFileSync"](filePath);
                yield this.cipherService.saveAttachmentRawWithServer(cipher, external_path_["basename"](filePath), new Uint8Array(fileBuf).buffer);
                const updatedCipher = yield this.cipherService.get(cipher.id);
                const decCipher = yield updatedCipher.decrypt();
                const res = new response_cipherResponse_CipherResponse(decCipher);
                return Response.success(res);
            }
            catch (e) {
                return Response.error(e);
            }
        });
    }
    createFolder(req) {
        return create_command_awaiter(this, void 0, void 0, function* () {
            const folder = yield this.folderService.encrypt(export_folder_Folder.toView(req));
            try {
                yield this.folderService.saveWithServer(folder);
                const newFolder = yield this.folderService.get(folder.id);
                const decFolder = yield newFolder.decrypt();
                const res = new response_folderResponse_FolderResponse(decFolder);
                return Response.success(res);
            }
            catch (e) {
                return Response.error(e);
            }
        });
    }
    createOrganizationCollection(req, cmd) {
        return create_command_awaiter(this, void 0, void 0, function* () {
            if (cmd.organizationid == null || cmd.organizationid === '') {
                return Response.badRequest('--organizationid <organizationid> required.');
            }
            if (!utils_Utils.isGuid(cmd.organizationid)) {
                return Response.error('`' + cmd.organizationid + '` is not a GUID.');
            }
            if (cmd.organizationid !== req.organizationId) {
                return Response.error('--organizationid <organizationid> does not match request object.');
            }
            try {
                const orgKey = yield this.cryptoService.getOrgKey(req.organizationId);
                if (orgKey == null) {
                    throw new Error('No encryption key for this organization.');
                }
                const groups = req.groups == null ? null :
                    req.groups.map((g) => new SelectionReadOnlyRequest(g.id, g.readOnly));
                const request = new CollectionRequest();
                request.name = (yield this.cryptoService.encrypt(req.name, orgKey)).encryptedString;
                request.externalId = req.externalId;
                request.groups = groups;
                yield this.apiService.postCollection(req.organizationId, request);
                const res = new organizationCollectionResponse_OrganizationCollectionResponse(export_collection_Collection.toView(req), groups);
                return Response.success(res);
            }
            catch (e) {
                return Response.error(e);
            }
        });
    }
}

// CONCATENATED MODULE: ./src/commands/delete.command.ts
var delete_command_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};


class delete_command_DeleteCommand {
    constructor(cipherService, folderService, userService, apiService) {
        this.cipherService = cipherService;
        this.folderService = folderService;
        this.userService = userService;
        this.apiService = apiService;
    }
    run(object, id, cmd) {
        return delete_command_awaiter(this, void 0, void 0, function* () {
            if (id != null) {
                id = id.toLowerCase();
            }
            switch (object.toLowerCase()) {
                case 'item':
                    return yield this.deleteCipher(id, cmd);
                case 'attachment':
                    return yield this.deleteAttachment(id, cmd);
                case 'folder':
                    return yield this.deleteFolder(id);
                case 'org-collection':
                    return yield this.deleteOrganizationCollection(id, cmd);
                default:
                    return Response.badRequest('Unknown object.');
            }
        });
    }
    deleteCipher(id, cmd) {
        return delete_command_awaiter(this, void 0, void 0, function* () {
            const cipher = yield this.cipherService.get(id);
            if (cipher == null) {
                return Response.notFound();
            }
            try {
                if (cmd.permanent) {
                    yield this.cipherService.deleteWithServer(id);
                }
                else {
                    yield this.cipherService.softDeleteWithServer(id);
                }
                return Response.success();
            }
            catch (e) {
                return Response.error(e);
            }
        });
    }
    deleteAttachment(id, cmd) {
        return delete_command_awaiter(this, void 0, void 0, function* () {
            if (cmd.itemid == null || cmd.itemid === '') {
                return Response.badRequest('--itemid <itemid> required.');
            }
            const itemId = cmd.itemid.toLowerCase();
            const cipher = yield this.cipherService.get(itemId);
            if (cipher == null) {
                return Response.notFound();
            }
            if (cipher.attachments == null || cipher.attachments.length === 0) {
                return Response.error('No attachments available for this item.');
            }
            const attachments = cipher.attachments.filter((a) => a.id.toLowerCase() === id);
            if (attachments.length === 0) {
                return Response.error('Attachment `' + id + '` was not found.');
            }
            if (cipher.organizationId == null && !(yield this.userService.canAccessPremium())) {
                return Response.error('Premium status is required to use this feature.');
            }
            try {
                yield this.cipherService.deleteAttachmentWithServer(cipher.id, attachments[0].id);
                return Response.success();
            }
            catch (e) {
                return Response.error(e);
            }
        });
    }
    deleteFolder(id) {
        return delete_command_awaiter(this, void 0, void 0, function* () {
            const folder = yield this.folderService.get(id);
            if (folder == null) {
                return Response.notFound();
            }
            try {
                yield this.folderService.deleteWithServer(id);
                return Response.success();
            }
            catch (e) {
                return Response.error(e);
            }
        });
    }
    deleteOrganizationCollection(id, cmd) {
        return delete_command_awaiter(this, void 0, void 0, function* () {
            if (cmd.organizationid == null || cmd.organizationid === '') {
                return Response.badRequest('--organizationid <organizationid> required.');
            }
            if (!utils_Utils.isGuid(id)) {
                return Response.error('`' + id + '` is not a GUID.');
            }
            if (!utils_Utils.isGuid(cmd.organizationid)) {
                return Response.error('`' + cmd.organizationid + '` is not a GUID.');
            }
            try {
                yield this.apiService.deleteCollection(cmd.organizationid, id);
                return Response.success();
            }
            catch (e) {
                return Response.error(e);
            }
        });
    }
}

// CONCATENATED MODULE: ./src/commands/edit.command.ts
var edit_command_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};











class edit_command_EditCommand {
    constructor(cipherService, folderService, cryptoService, apiService) {
        this.cipherService = cipherService;
        this.folderService = folderService;
        this.cryptoService = cryptoService;
        this.apiService = apiService;
    }
    run(object, id, requestJson, cmd) {
        return edit_command_awaiter(this, void 0, void 0, function* () {
            if (requestJson == null || requestJson === '') {
                requestJson = yield utils_CliUtils.readStdin();
            }
            if (requestJson == null || requestJson === '') {
                return Response.badRequest('`requestJson` was not provided.');
            }
            let req = null;
            try {
                const reqJson = Buffer.from(requestJson, 'base64').toString();
                req = JSON.parse(reqJson);
            }
            catch (e) {
                return Response.badRequest('Error parsing the encoded request data.');
            }
            if (id != null) {
                id = id.toLowerCase();
            }
            switch (object.toLowerCase()) {
                case 'item':
                    return yield this.editCipher(id, req);
                case 'item-collections':
                    return yield this.editCipherCollections(id, req);
                case 'folder':
                    return yield this.editFolder(id, req);
                case 'org-collection':
                    return yield this.editOrganizationCollection(id, req, cmd);
                default:
                    return Response.badRequest('Unknown object.');
            }
        });
    }
    editCipher(id, req) {
        return edit_command_awaiter(this, void 0, void 0, function* () {
            const cipher = yield this.cipherService.get(id);
            if (cipher == null) {
                return Response.notFound();
            }
            let cipherView = yield cipher.decrypt();
            if (cipherView.isDeleted) {
                return Response.badRequest('You may not edit a deleted cipher. Use restore item <id> command first.');
            }
            cipherView = export_cipher_Cipher.toView(req, cipherView);
            const encCipher = yield this.cipherService.encrypt(cipherView);
            try {
                yield this.cipherService.saveWithServer(encCipher);
                const updatedCipher = yield this.cipherService.get(cipher.id);
                const decCipher = yield updatedCipher.decrypt();
                const res = new response_cipherResponse_CipherResponse(decCipher);
                return Response.success(res);
            }
            catch (e) {
                return Response.error(e);
            }
        });
    }
    editCipherCollections(id, req) {
        return edit_command_awaiter(this, void 0, void 0, function* () {
            const cipher = yield this.cipherService.get(id);
            if (cipher == null) {
                return Response.notFound();
            }
            if (cipher.organizationId == null) {
                return Response.badRequest('Item does not belong to an organization. Consider sharing it first.');
            }
            cipher.collectionIds = req;
            try {
                yield this.cipherService.saveCollectionsWithServer(cipher);
                const updatedCipher = yield this.cipherService.get(cipher.id);
                const decCipher = yield updatedCipher.decrypt();
                const res = new response_cipherResponse_CipherResponse(decCipher);
                return Response.success(res);
            }
            catch (e) {
                return Response.error(e);
            }
        });
    }
    editFolder(id, req) {
        return edit_command_awaiter(this, void 0, void 0, function* () {
            const folder = yield this.folderService.get(id);
            if (folder == null) {
                return Response.notFound();
            }
            let folderView = yield folder.decrypt();
            folderView = export_folder_Folder.toView(req, folderView);
            const encFolder = yield this.folderService.encrypt(folderView);
            try {
                yield this.folderService.saveWithServer(encFolder);
                const updatedFolder = yield this.folderService.get(folder.id);
                const decFolder = yield updatedFolder.decrypt();
                const res = new response_folderResponse_FolderResponse(decFolder);
                return Response.success(res);
            }
            catch (e) {
                return Response.error(e);
            }
        });
    }
    editOrganizationCollection(id, req, cmd) {
        return edit_command_awaiter(this, void 0, void 0, function* () {
            if (cmd.organizationid == null || cmd.organizationid === '') {
                return Response.badRequest('--organizationid <organizationid> required.');
            }
            if (!utils_Utils.isGuid(id)) {
                return Response.error('`' + id + '` is not a GUID.');
            }
            if (!utils_Utils.isGuid(cmd.organizationid)) {
                return Response.error('`' + cmd.organizationid + '` is not a GUID.');
            }
            if (cmd.organizationid !== req.organizationId) {
                return Response.error('--organizationid <organizationid> does not match request object.');
            }
            try {
                const orgKey = yield this.cryptoService.getOrgKey(req.organizationId);
                if (orgKey == null) {
                    throw new Error('No encryption key for this organization.');
                }
                const groups = req.groups == null ? null :
                    req.groups.map((g) => new SelectionReadOnlyRequest(g.id, g.readOnly));
                const request = new CollectionRequest();
                request.name = (yield this.cryptoService.encrypt(req.name, orgKey)).encryptedString;
                request.externalId = req.externalId;
                request.groups = groups;
                yield this.apiService.putCollection(req.organizationId, id, request);
                const res = new organizationCollectionResponse_OrganizationCollectionResponse(export_collection_Collection.toView(req), groups);
                return Response.success(res);
            }
            catch (e) {
                return Response.error(e);
            }
        });
    }
}

// CONCATENATED MODULE: ./src/commands/encode.command.ts
var encode_command_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};



class encode_command_EncodeCommand {
    run(cmd) {
        return encode_command_awaiter(this, void 0, void 0, function* () {
            if (process.stdin.isTTY) {
                return Response.badRequest('No stdin was piped in.');
            }
            const input = yield utils_CliUtils.readStdin();
            const b64 = Buffer.from(input, 'utf8').toString('base64');
            const res = new StringResponse(b64);
            return Response.success(res);
        });
    }
}

// EXTERNAL MODULE: external "inquirer"
var external_inquirer_ = __webpack_require__(5);

// CONCATENATED MODULE: ./src/commands/export.command.ts
var export_command_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};





class export_command_ExportCommand {
    constructor(cryptoService, exportService) {
        this.cryptoService = cryptoService;
        this.exportService = exportService;
    }
    run(password, cmd) {
        return export_command_awaiter(this, void 0, void 0, function* () {
            const canInteract = process.env.BW_NOINTERACTION !== 'true';
            if ((password == null || password === '') && canInteract) {
                const answer = yield external_inquirer_["createPromptModule"]({ output: process.stderr })({
                    type: 'password',
                    name: 'password',
                    message: 'Master password:',
                });
                password = answer.password;
            }
            if (password == null || password === '') {
                return Response.badRequest('Master password is required.');
            }
            const keyHash = yield this.cryptoService.hashPassword(password, null);
            const storedKeyHash = yield this.cryptoService.getKeyHash();
            if (storedKeyHash != null && keyHash != null && storedKeyHash === keyHash) {
                const format = cmd.format !== 'json' ? 'csv' : 'json';
                if (cmd.organizationid != null && !utils_Utils.isGuid(cmd.organizationid)) {
                    return Response.error('`' + cmd.organizationid + '` is not a GUID.');
                }
                let csv = null;
                try {
                    csv = cmd.organizationid != null ?
                        yield this.exportService.getOrganizationExport(cmd.organizationid, format) :
                        yield this.exportService.getExport(format);
                }
                catch (e) {
                    return Response.error(e);
                }
                return yield this.saveFile(csv, cmd, format);
            }
            else {
                return Response.error('Invalid master password.');
            }
        });
    }
    saveFile(csv, cmd, format) {
        return export_command_awaiter(this, void 0, void 0, function* () {
            try {
                const filePath = yield utils_CliUtils.saveFile(csv, cmd.output, this.exportService.getFileName(cmd.organizationid != null ? 'org' : null, format));
                const res = new MessageResponse('Saved ' + filePath, null);
                res.raw = filePath;
                return Response.success(res);
            }
            catch (e) {
                return Response.error(e.toString());
            }
        });
    }
}

// CONCATENATED MODULE: ./src/commands/generate.command.ts
var generate_command_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};


class generate_command_GenerateCommand {
    constructor(passwordGenerationService) {
        this.passwordGenerationService = passwordGenerationService;
    }
    run(cmd) {
        return generate_command_awaiter(this, void 0, void 0, function* () {
            const options = {
                uppercase: cmd.uppercase || false,
                lowercase: cmd.lowercase || false,
                number: cmd.number || false,
                special: cmd.special || false,
                length: cmd.length || 14,
                type: cmd.passphrase ? 'passphrase' : 'password',
                wordSeparator: cmd.separator == null ? '-' : cmd.separator,
                numWords: cmd.words || 3,
            };
            if (!options.uppercase && !options.lowercase && !options.special && !options.number) {
                options.lowercase = true;
                options.uppercase = true;
                options.number = true;
            }
            if (options.length < 5) {
                options.length = 5;
            }
            if (options.numWords < 3) {
                options.numWords = 3;
            }
            if (options.wordSeparator === 'space') {
                options.wordSeparator = ' ';
            }
            else if (options.wordSeparator != null && options.wordSeparator.length > 1) {
                options.wordSeparator = options.wordSeparator[0];
            }
            const enforcedOptions = yield this.passwordGenerationService.enforcePasswordGeneratorPoliciesOnOptions(options);
            const password = yield this.passwordGenerationService.generatePassword(enforcedOptions[0]);
            const res = new StringResponse(password);
            return Response.success(res);
        });
    }
}

// CONCATENATED MODULE: ./src/models/response/organizationResponse.ts
class response_organizationResponse_OrganizationResponse {
    constructor(o) {
        this.object = 'organization';
        this.id = o.id;
        this.name = o.name;
        this.status = o.status;
        this.type = o.type;
        this.enabled = o.enabled;
    }
}

// CONCATENATED MODULE: ./src/models/response/templateResponse.ts
class TemplateResponse {
    constructor(template) {
        this.object = 'template';
        this.template = template;
    }
}

// CONCATENATED MODULE: ./src/models/selectionReadOnly.ts
class SelectionReadOnly {
    static template() {
        return new SelectionReadOnly('00000000-0000-0000-0000-000000000000', false);
    }
    constructor(id, readOnly) {
        this.id = id;
        this.readOnly = readOnly;
    }
}

// CONCATENATED MODULE: ./src/models/request/organizationCollectionRequest.ts


class organizationCollectionRequest_OrganizationCollectionRequest extends export_collection_Collection {
    static template() {
        const req = new organizationCollectionRequest_OrganizationCollectionRequest();
        req.organizationId = '00000000-0000-0000-0000-000000000000';
        req.name = 'Collection name';
        req.externalId = null;
        req.groups = [SelectionReadOnly.template(), SelectionReadOnly.template()];
        return req;
    }
}

// CONCATENATED MODULE: ./src/commands/get.command.ts
var get_command_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};


























class get_command_GetCommand {
    constructor(cipherService, folderService, collectionService, totpService, auditService, cryptoService, userService, searchService, apiService) {
        this.cipherService = cipherService;
        this.folderService = folderService;
        this.collectionService = collectionService;
        this.totpService = totpService;
        this.auditService = auditService;
        this.cryptoService = cryptoService;
        this.userService = userService;
        this.searchService = searchService;
        this.apiService = apiService;
    }
    run(object, id, cmd) {
        return get_command_awaiter(this, void 0, void 0, function* () {
            if (id != null) {
                id = id.toLowerCase();
            }
            switch (object.toLowerCase()) {
                case 'item':
                    return yield this.getCipher(id);
                case 'username':
                    return yield this.getUsername(id);
                case 'password':
                    return yield this.getPassword(id);
                case 'uri':
                    return yield this.getUri(id);
                case 'totp':
                    return yield this.getTotp(id);
                case 'exposed':
                    return yield this.getExposed(id);
                case 'attachment':
                    return yield this.getAttachment(id, cmd);
                case 'folder':
                    return yield this.getFolder(id);
                case 'collection':
                    return yield this.getCollection(id);
                case 'org-collection':
                    return yield this.getOrganizationCollection(id, cmd);
                case 'organization':
                    return yield this.getOrganization(id);
                case 'template':
                    return yield this.getTemplate(id);
                case 'fingerprint':
                    return yield this.getFingerprint(id);
                default:
                    return Response.badRequest('Unknown object.');
            }
        });
    }
    getCipherView(id) {
        return get_command_awaiter(this, void 0, void 0, function* () {
            let decCipher = null;
            if (utils_Utils.isGuid(id)) {
                const cipher = yield this.cipherService.get(id);
                if (cipher != null) {
                    decCipher = yield cipher.decrypt();
                }
            }
            else if (id.trim() !== '') {
                let ciphers = yield this.cipherService.getAllDecrypted();
                ciphers = this.searchService.searchCiphersBasic(ciphers, id);
                if (ciphers.length > 1) {
                    return ciphers;
                }
                if (ciphers.length > 0) {
                    decCipher = ciphers[0];
                }
            }
            return decCipher;
        });
    }
    getCipher(id, filter) {
        return get_command_awaiter(this, void 0, void 0, function* () {
            let decCipher = yield this.getCipherView(id);
            if (decCipher == null) {
                return Response.notFound();
            }
            if (Array.isArray(decCipher)) {
                if (filter != null) {
                    const filteredCiphers = decCipher.filter(filter);
                    if (filteredCiphers.length === 1) {
                        decCipher = filteredCiphers[0];
                    }
                }
                if (Array.isArray(decCipher)) {
                    return Response.multipleResults(decCipher.map((c) => c.id));
                }
            }
            const res = new response_cipherResponse_CipherResponse(decCipher);
            return Response.success(res);
        });
    }
    getUsername(id) {
        return get_command_awaiter(this, void 0, void 0, function* () {
            const cipherResponse = yield this.getCipher(id, (c) => c.type === CipherType.Login && !utils_Utils.isNullOrWhitespace(c.login.username));
            if (!cipherResponse.success) {
                return cipherResponse;
            }
            const cipher = cipherResponse.data;
            if (cipher.type !== CipherType.Login) {
                return Response.badRequest('Not a login.');
            }
            if (utils_Utils.isNullOrWhitespace(cipher.login.username)) {
                return Response.error('No username available for this login.');
            }
            const res = new StringResponse(cipher.login.username);
            return Response.success(res);
        });
    }
    getPassword(id) {
        return get_command_awaiter(this, void 0, void 0, function* () {
            const cipherResponse = yield this.getCipher(id, (c) => c.type === CipherType.Login && !utils_Utils.isNullOrWhitespace(c.login.password));
            if (!cipherResponse.success) {
                return cipherResponse;
            }
            const cipher = cipherResponse.data;
            if (cipher.type !== CipherType.Login) {
                return Response.badRequest('Not a login.');
            }
            if (utils_Utils.isNullOrWhitespace(cipher.login.password)) {
                return Response.error('No password available for this login.');
            }
            const res = new StringResponse(cipher.login.password);
            return Response.success(res);
        });
    }
    getUri(id) {
        return get_command_awaiter(this, void 0, void 0, function* () {
            const cipherResponse = yield this.getCipher(id, (c) => c.type === CipherType.Login && c.login.uris != null && c.login.uris.length > 0 &&
                c.login.uris[0].uri !== '');
            if (!cipherResponse.success) {
                return cipherResponse;
            }
            const cipher = cipherResponse.data;
            if (cipher.type !== CipherType.Login) {
                return Response.badRequest('Not a login.');
            }
            if (cipher.login.uris == null || cipher.login.uris.length === 0 || cipher.login.uris[0].uri === '') {
                return Response.error('No uri available for this login.');
            }
            const res = new StringResponse(cipher.login.uris[0].uri);
            return Response.success(res);
        });
    }
    getTotp(id) {
        return get_command_awaiter(this, void 0, void 0, function* () {
            const cipherResponse = yield this.getCipher(id, (c) => c.type === CipherType.Login && !utils_Utils.isNullOrWhitespace(c.login.totp));
            if (!cipherResponse.success) {
                return cipherResponse;
            }
            const cipher = cipherResponse.data;
            if (cipher.type !== CipherType.Login) {
                return Response.badRequest('Not a login.');
            }
            if (utils_Utils.isNullOrWhitespace(cipher.login.totp)) {
                return Response.error('No TOTP available for this login.');
            }
            const totp = yield this.totpService.getCode(cipher.login.totp);
            if (totp == null) {
                return Response.error('Couldn\'t generate TOTP code.');
            }
            const canAccessPremium = yield this.userService.canAccessPremium();
            if (!canAccessPremium) {
                const originalCipher = yield this.cipherService.get(cipher.id);
                if (originalCipher == null || originalCipher.organizationId == null ||
                    !originalCipher.organizationUseTotp) {
                    return Response.error('Premium status is required to use this feature.');
                }
            }
            const res = new StringResponse(totp);
            return Response.success(res);
        });
    }
    getExposed(id) {
        return get_command_awaiter(this, void 0, void 0, function* () {
            const passwordResponse = yield this.getPassword(id);
            if (!passwordResponse.success) {
                return passwordResponse;
            }
            const exposedNumber = yield this.auditService.passwordLeaked(passwordResponse.data.data);
            const res = new StringResponse(exposedNumber.toString());
            return Response.success(res);
        });
    }
    getAttachment(id, cmd) {
        return get_command_awaiter(this, void 0, void 0, function* () {
            if (cmd.itemid == null || cmd.itemid === '') {
                return Response.badRequest('--itemid <itemid> required.');
            }
            const itemId = cmd.itemid.toLowerCase();
            const cipherResponse = yield this.getCipher(itemId);
            if (!cipherResponse.success) {
                return cipherResponse;
            }
            const cipher = yield this.getCipherView(itemId);
            if (cipher == null || Array.isArray(cipher) || cipher.attachments.length === 0) {
                return Response.error('No attachments available for this item.');
            }
            const attachments = cipher.attachments.filter((a) => a.id.toLowerCase() === id ||
                (a.fileName != null && a.fileName.toLowerCase().indexOf(id) > -1));
            if (attachments.length === 0) {
                return Response.error('Attachment `' + id + '` was not found.');
            }
            if (attachments.length > 1) {
                return Response.multipleResults(attachments.map((a) => a.id));
            }
            if (!(yield this.userService.canAccessPremium())) {
                const originalCipher = yield this.cipherService.get(cipher.id);
                if (originalCipher == null || originalCipher.organizationId == null) {
                    return Response.error('Premium status is required to use this feature.');
                }
            }
            const response = yield external_node_fetch_default.a(new external_node_fetch_["Request"](attachments[0].url, { headers: { cache: 'no-cache' } }));
            if (response.status !== 200) {
                return Response.error('A ' + response.status + ' error occurred while downloading the attachment.');
            }
            try {
                const buf = yield response.arrayBuffer();
                const key = attachments[0].key != null ? attachments[0].key :
                    yield this.cryptoService.getOrgKey(cipher.organizationId);
                const decBuf = yield this.cryptoService.decryptFromBytes(buf, key);
                const filePath = yield utils_CliUtils.saveFile(Buffer.from(decBuf), cmd.output, attachments[0].fileName);
                const res = new MessageResponse('Saved ' + filePath, null);
                res.raw = filePath;
                return Response.success(res);
            }
            catch (e) {
                if (typeof (e) === 'string') {
                    return Response.error(e);
                }
                else {
                    return Response.error('An error occurred while saving the attachment.');
                }
            }
        });
    }
    getFolder(id) {
        return get_command_awaiter(this, void 0, void 0, function* () {
            let decFolder = null;
            if (utils_Utils.isGuid(id)) {
                const folder = yield this.folderService.get(id);
                if (folder != null) {
                    decFolder = yield folder.decrypt();
                }
            }
            else if (id.trim() !== '') {
                let folders = yield this.folderService.getAllDecrypted();
                folders = utils_CliUtils.searchFolders(folders, id);
                if (folders.length > 1) {
                    return Response.multipleResults(folders.map((f) => f.id));
                }
                if (folders.length > 0) {
                    decFolder = folders[0];
                }
            }
            if (decFolder == null) {
                return Response.notFound();
            }
            const res = new response_folderResponse_FolderResponse(decFolder);
            return Response.success(res);
        });
    }
    getCollection(id) {
        return get_command_awaiter(this, void 0, void 0, function* () {
            let decCollection = null;
            if (utils_Utils.isGuid(id)) {
                const collection = yield this.collectionService.get(id);
                if (collection != null) {
                    decCollection = yield collection.decrypt();
                }
            }
            else if (id.trim() !== '') {
                let collections = yield this.collectionService.getAllDecrypted();
                collections = utils_CliUtils.searchCollections(collections, id);
                if (collections.length > 1) {
                    return Response.multipleResults(collections.map((c) => c.id));
                }
                if (collections.length > 0) {
                    decCollection = collections[0];
                }
            }
            if (decCollection == null) {
                return Response.notFound();
            }
            const res = new response_collectionResponse_CollectionResponse(decCollection);
            return Response.success(res);
        });
    }
    getOrganizationCollection(id, cmd) {
        return get_command_awaiter(this, void 0, void 0, function* () {
            if (cmd.organizationid == null || cmd.organizationid === '') {
                return Response.badRequest('--organizationid <organizationid> required.');
            }
            if (!utils_Utils.isGuid(id)) {
                return Response.error('`' + id + '` is not a GUID.');
            }
            if (!utils_Utils.isGuid(cmd.organizationid)) {
                return Response.error('`' + cmd.organizationid + '` is not a GUID.');
            }
            try {
                const orgKey = yield this.cryptoService.getOrgKey(cmd.organizationid);
                if (orgKey == null) {
                    throw new Error('No encryption key for this organization.');
                }
                const response = yield this.apiService.getCollectionDetails(cmd.organizationid, id);
                const decCollection = new collectionView_CollectionView(response);
                decCollection.name = yield this.cryptoService.decryptToUtf8(new cipherString_CipherString(response.name), orgKey);
                const groups = response.groups == null ? null :
                    response.groups.map((g) => new SelectionReadOnly(g.id, g.readOnly));
                const res = new organizationCollectionResponse_OrganizationCollectionResponse(decCollection, groups);
                return Response.success(res);
            }
            catch (e) {
                return Response.error(e);
            }
        });
    }
    getOrganization(id) {
        return get_command_awaiter(this, void 0, void 0, function* () {
            let org = null;
            if (utils_Utils.isGuid(id)) {
                org = yield this.userService.getOrganization(id);
            }
            else if (id.trim() !== '') {
                let orgs = yield this.userService.getAllOrganizations();
                orgs = utils_CliUtils.searchOrganizations(orgs, id);
                if (orgs.length > 1) {
                    return Response.multipleResults(orgs.map((c) => c.id));
                }
                if (orgs.length > 0) {
                    org = orgs[0];
                }
            }
            if (org == null) {
                return Response.notFound();
            }
            const res = new response_organizationResponse_OrganizationResponse(org);
            return Response.success(res);
        });
    }
    getTemplate(id) {
        return get_command_awaiter(this, void 0, void 0, function* () {
            let template = null;
            switch (id.toLowerCase()) {
                case 'item':
                    template = export_cipher_Cipher.template();
                    break;
                case 'item.field':
                    template = export_field_Field.template();
                    break;
                case 'item.login':
                    template = export_login_Login.template();
                    break;
                case 'item.login.uri':
                    template = export_loginUri_LoginUri.template();
                    break;
                case 'item.card':
                    template = export_card_Card.template();
                    break;
                case 'item.identity':
                    template = export_identity_Identity.template();
                    break;
                case 'item.securenote':
                    template = export_secureNote_SecureNote.template();
                    break;
                case 'folder':
                    template = export_folder_Folder.template();
                    break;
                case 'collection':
                    template = export_collection_Collection.template();
                    break;
                case 'item-collections':
                    template = ['collection-id1', 'collection-id2'];
                    break;
                case 'org-collection':
                    template = organizationCollectionRequest_OrganizationCollectionRequest.template();
                    break;
                default:
                    return Response.badRequest('Unknown template object.');
            }
            const res = new TemplateResponse(template);
            return Response.success(res);
        });
    }
    getFingerprint(id) {
        return get_command_awaiter(this, void 0, void 0, function* () {
            let fingerprint = null;
            if (id === 'me') {
                fingerprint = yield this.cryptoService.getFingerprint(yield this.userService.getUserId());
            }
            else if (utils_Utils.isGuid(id)) {
                try {
                    const response = yield this.apiService.getUserPublicKey(id);
                    const pubKey = utils_Utils.fromB64ToArray(response.publicKey);
                    fingerprint = yield this.cryptoService.getFingerprint(id, pubKey.buffer);
                }
                catch (_a) { }
            }
            if (fingerprint == null) {
                return Response.notFound();
            }
            const res = new StringResponse(fingerprint.join('-'));
            return Response.success(res);
        });
    }
}

// CONCATENATED MODULE: ./src/commands/import.command.ts
var import_command_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};



class import_command_ImportCommand {
    constructor(importService) {
        this.importService = importService;
    }
    run(format, filepath, cmd) {
        return import_command_awaiter(this, void 0, void 0, function* () {
            if (cmd.formats || false) {
                return this.list();
            }
            else {
                return this.import(format, filepath);
            }
        });
    }
    import(format, filepath) {
        return import_command_awaiter(this, void 0, void 0, function* () {
            if (format == null || format === '') {
                return Response.badRequest('`format` was not provided.');
            }
            if (filepath == null || filepath === '') {
                return Response.badRequest('`filepath` was not provided.');
            }
            const importer = yield this.importService.getImporter(format, false);
            if (importer === null) {
                return Response.badRequest('Proper importer type required.');
            }
            try {
                const contents = yield utils_CliUtils.readFile(filepath);
                if (contents === null || contents === '') {
                    return Response.badRequest('Import file was empty.');
                }
                const err = yield this.importService.import(importer, contents, null);
                if (err != null) {
                    return Response.badRequest(err.message);
                }
                const res = new MessageResponse('Imported ' + filepath, null);
                return Response.success(res);
            }
            catch (err) {
                return Response.badRequest(err);
            }
        });
    }
    list() {
        return import_command_awaiter(this, void 0, void 0, function* () {
            const options = this.importService.getImportOptions().sort((a, b) => {
                return a.id < b.id ? -1 : a.id > b.id ? 1 : 0;
            }).map((option) => option.id).join('\n');
            const res = new MessageResponse('Supported input formats:', options);
            res.raw = options;
            return Response.success(res);
        });
    }
}

// CONCATENATED MODULE: ./jslib/src/cli/models/response/listResponse.ts
class response_listResponse_ListResponse {
    constructor(data) {
        this.object = 'list';
        this.data = data;
    }
}

// CONCATENATED MODULE: ./src/models/response/organizationUserResponse.ts
class response_organizationUserResponse_OrganizationUserResponse {
    constructor() {
        this.object = 'org-member';
    }
}

// CONCATENATED MODULE: ./src/commands/list.command.ts
var list_command_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};











class list_command_ListCommand {
    constructor(cipherService, folderService, collectionService, userService, searchService, apiService) {
        this.cipherService = cipherService;
        this.folderService = folderService;
        this.collectionService = collectionService;
        this.userService = userService;
        this.searchService = searchService;
        this.apiService = apiService;
    }
    run(object, cmd) {
        return list_command_awaiter(this, void 0, void 0, function* () {
            switch (object.toLowerCase()) {
                case 'items':
                    return yield this.listCiphers(cmd);
                case 'folders':
                    return yield this.listFolders(cmd);
                case 'collections':
                    return yield this.listCollections(cmd);
                case 'org-collections':
                    return yield this.listOrganizationCollections(cmd);
                case 'org-members':
                    return yield this.listOrganizationMembers(cmd);
                case 'organizations':
                    return yield this.listOrganizations(cmd);
                default:
                    return Response.badRequest('Unknown object.');
            }
        });
    }
    listCiphers(cmd) {
        return list_command_awaiter(this, void 0, void 0, function* () {
            let ciphers;
            cmd.trash = cmd.trash || false;
            if (cmd.url != null && cmd.url.trim() !== '') {
                ciphers = yield this.cipherService.getAllDecryptedForUrl(cmd.url);
            }
            else {
                ciphers = yield this.cipherService.getAllDecrypted();
            }
            if (cmd.folderid != null || cmd.collectionid != null || cmd.organizationid != null) {
                ciphers = ciphers.filter((c) => {
                    if (cmd.trash !== c.isDeleted) {
                        return false;
                    }
                    if (cmd.folderid != null) {
                        if (cmd.folderid === 'notnull' && c.folderId != null) {
                            return true;
                        }
                        const folderId = cmd.folderid === 'null' ? null : cmd.folderid;
                        if (folderId === c.folderId) {
                            return true;
                        }
                    }
                    if (cmd.organizationid != null) {
                        if (cmd.organizationid === 'notnull' && c.organizationId != null) {
                            return true;
                        }
                        const organizationId = cmd.organizationid === 'null' ? null : cmd.organizationid;
                        if (organizationId === c.organizationId) {
                            return true;
                        }
                    }
                    if (cmd.collectionid != null) {
                        if (cmd.collectionid === 'notnull' && c.collectionIds != null && c.collectionIds.length > 0) {
                            return true;
                        }
                        const collectionId = cmd.collectionid === 'null' ? null : cmd.collectionid;
                        if (collectionId == null && (c.collectionIds == null || c.collectionIds.length === 0)) {
                            return true;
                        }
                        if (collectionId != null && c.collectionIds != null && c.collectionIds.indexOf(collectionId) > -1) {
                            return true;
                        }
                    }
                    return false;
                });
            }
            else if (cmd.search == null || cmd.search.trim() === '') {
                ciphers = ciphers.filter((c) => cmd.trash === c.isDeleted);
            }
            if (cmd.search != null && cmd.search.trim() !== '') {
                ciphers = this.searchService.searchCiphersBasic(ciphers, cmd.search, cmd.trash);
            }
            const res = new response_listResponse_ListResponse(ciphers.map((o) => new response_cipherResponse_CipherResponse(o)));
            return Response.success(res);
        });
    }
    listFolders(cmd) {
        return list_command_awaiter(this, void 0, void 0, function* () {
            let folders = yield this.folderService.getAllDecrypted();
            if (cmd.search != null && cmd.search.trim() !== '') {
                folders = utils_CliUtils.searchFolders(folders, cmd.search);
            }
            const res = new response_listResponse_ListResponse(folders.map((o) => new response_folderResponse_FolderResponse(o)));
            return Response.success(res);
        });
    }
    listCollections(cmd) {
        return list_command_awaiter(this, void 0, void 0, function* () {
            let collections = yield this.collectionService.getAllDecrypted();
            if (cmd.organizationid != null) {
                collections = collections.filter((c) => {
                    if (cmd.organizationid === c.organizationId) {
                        return true;
                    }
                    return false;
                });
            }
            if (cmd.search != null && cmd.search.trim() !== '') {
                collections = utils_CliUtils.searchCollections(collections, cmd.search);
            }
            const res = new response_listResponse_ListResponse(collections.map((o) => new response_collectionResponse_CollectionResponse(o)));
            return Response.success(res);
        });
    }
    listOrganizationCollections(cmd) {
        return list_command_awaiter(this, void 0, void 0, function* () {
            if (cmd.organizationid == null || cmd.organizationid === '') {
                return Response.badRequest('--organizationid <organizationid> required.');
            }
            if (!utils_Utils.isGuid(cmd.organizationid)) {
                return Response.error('`' + cmd.organizationid + '` is not a GUID.');
            }
            const organization = yield this.userService.getOrganization(cmd.organizationid);
            if (organization == null) {
                return Response.error('Organization not found.');
            }
            try {
                let response;
                if (organization.isAdmin) {
                    response = yield this.apiService.getCollections(cmd.organizationid);
                }
                else {
                    response = yield this.apiService.getUserCollections();
                }
                const collections = response.data.filter((c) => c.organizationId === cmd.organizationid).map((r) => new collection_Collection(new CollectionData(r)));
                let decCollections = yield this.collectionService.decryptMany(collections);
                if (cmd.search != null && cmd.search.trim() !== '') {
                    decCollections = utils_CliUtils.searchCollections(decCollections, cmd.search);
                }
                const res = new response_listResponse_ListResponse(decCollections.map((o) => new response_collectionResponse_CollectionResponse(o)));
                return Response.success(res);
            }
            catch (e) {
                return Response.error(e);
            }
        });
    }
    listOrganizationMembers(cmd) {
        return list_command_awaiter(this, void 0, void 0, function* () {
            if (cmd.organizationid == null || cmd.organizationid === '') {
                return Response.badRequest('--organizationid <organizationid> required.');
            }
            if (!utils_Utils.isGuid(cmd.organizationid)) {
                return Response.error('`' + cmd.organizationid + '` is not a GUID.');
            }
            const organization = yield this.userService.getOrganization(cmd.organizationid);
            if (organization == null) {
                return Response.error('Organization not found.');
            }
            try {
                const response = yield this.apiService.getOrganizationUsers(cmd.organizationid);
                const res = new response_listResponse_ListResponse(response.data.map((r) => {
                    const u = new response_organizationUserResponse_OrganizationUserResponse();
                    u.email = r.email;
                    u.name = r.name;
                    u.id = r.id;
                    u.status = r.status;
                    u.type = r.type;
                    u.twoFactorEnabled = r.twoFactorEnabled;
                    return u;
                }));
                return Response.success(res);
            }
            catch (e) {
                return Response.error(e);
            }
        });
    }
    listOrganizations(cmd) {
        return list_command_awaiter(this, void 0, void 0, function* () {
            let organizations = yield this.userService.getAllOrganizations();
            if (cmd.search != null && cmd.search.trim() !== '') {
                organizations = utils_CliUtils.searchOrganizations(organizations, cmd.search);
            }
            const res = new response_listResponse_ListResponse(organizations.map((o) => new response_organizationResponse_OrganizationResponse(o)));
            return Response.success(res);
        });
    }
}

// CONCATENATED MODULE: ./src/commands/lock.command.ts
var lock_command_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};


class lock_command_LockCommand {
    constructor(vaultTimeoutService) {
        this.vaultTimeoutService = vaultTimeoutService;
    }
    run(cmd) {
        return lock_command_awaiter(this, void 0, void 0, function* () {
            yield this.vaultTimeoutService.lock();
            process.env.BW_SESSION = null;
            const res = new MessageResponse('Your vault is locked.', null);
            return Response.success(res);
        });
    }
}

// CONCATENATED MODULE: ./jslib/src/models/request/passwordVerificationRequest.ts
class PasswordVerificationRequest {
}

// CONCATENATED MODULE: ./jslib/src/models/request/twoFactorEmailRequest.ts

class twoFactorEmailRequest_TwoFactorEmailRequest extends PasswordVerificationRequest {
    constructor(email, masterPasswordHash) {
        super();
        this.masterPasswordHash = masterPasswordHash;
        this.email = email;
    }
}

// CONCATENATED MODULE: ./jslib/src/cli/commands/login.command.ts
var login_command_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};






class login_command_LoginCommand {
    constructor(authService, apiService, i18nService) {
        this.authService = authService;
        this.apiService = apiService;
        this.i18nService = i18nService;
    }
    run(email, password, cmd) {
        return login_command_awaiter(this, void 0, void 0, function* () {
            const canInteract = process.env.BW_NOINTERACTION !== 'true';
            if ((email == null || email === '') && canInteract) {
                const answer = yield external_inquirer_["createPromptModule"]({ output: process.stderr })({
                    type: 'input',
                    name: 'email',
                    message: 'Email address:',
                });
                email = answer.email;
            }
            if (email == null || email.trim() === '') {
                return Response.badRequest('Email address is required.');
            }
            if (email.indexOf('@') === -1) {
                return Response.badRequest('Email address is invalid.');
            }
            if (password == null || password === '') {
                if (cmd.passwordfile) {
                    password = yield nodeUtils_NodeUtils.readFirstLine(cmd.passwordfile);
                }
                else if (cmd.passwordenv && process.env[cmd.passwordenv]) {
                    password = process.env[cmd.passwordenv];
                }
                else if (canInteract) {
                    const answer = yield external_inquirer_["createPromptModule"]({ output: process.stderr })({
                        type: 'password',
                        name: 'password',
                        message: 'Master password:',
                    });
                    password = answer.password;
                }
            }
            if (password == null || password === '') {
                return Response.badRequest('Master password is required.');
            }
            let twoFactorToken = cmd.code;
            let twoFactorMethod = null;
            try {
                if (cmd.method != null) {
                    twoFactorMethod = parseInt(cmd.method, null);
                }
            }
            catch (e) {
                return Response.error('Invalid two-step login method.');
            }
            try {
                if (this.validatedParams != null) {
                    yield this.validatedParams();
                }
                let response = null;
                if (twoFactorToken != null && twoFactorMethod != null) {
                    response = yield this.authService.logInComplete(email, password, twoFactorMethod, twoFactorToken, false);
                }
                else {
                    response = yield this.authService.logIn(email, password);
                    if (response.twoFactor) {
                        let selectedProvider = null;
                        const twoFactorProviders = this.authService.getSupportedTwoFactorProviders(null);
                        if (twoFactorProviders.length === 0) {
                            return Response.badRequest('No providers available for this client.');
                        }
                        if (twoFactorMethod != null) {
                            try {
                                selectedProvider = twoFactorProviders.filter((p) => p.type === twoFactorMethod)[0];
                            }
                            catch (e) {
                                return Response.error('Invalid two-step login method.');
                            }
                        }
                        if (selectedProvider == null) {
                            if (twoFactorProviders.length === 1) {
                                selectedProvider = twoFactorProviders[0];
                            }
                            else if (canInteract) {
                                const options = twoFactorProviders.map((p) => p.name);
                                options.push(new external_inquirer_["Separator"]());
                                options.push('Cancel');
                                const answer = yield external_inquirer_["createPromptModule"]({ output: process.stderr })({
                                    type: 'list',
                                    name: 'method',
                                    message: 'Two-step login method:',
                                    choices: options,
                                });
                                const i = options.indexOf(answer.method);
                                if (i === (options.length - 1)) {
                                    return Response.error('Login failed.');
                                }
                                selectedProvider = twoFactorProviders[i];
                            }
                            if (selectedProvider == null) {
                                return Response.error('Login failed. No provider selected.');
                            }
                        }
                        if (twoFactorToken == null && response.twoFactorProviders.size > 1 &&
                            selectedProvider.type === TwoFactorProviderType.Email) {
                            const emailReq = new twoFactorEmailRequest_TwoFactorEmailRequest(this.authService.email, this.authService.masterPasswordHash);
                            yield this.apiService.postTwoFactorEmail(emailReq);
                        }
                        if (twoFactorToken == null) {
                            if (canInteract) {
                                const answer = yield external_inquirer_["createPromptModule"]({ output: process.stderr })({
                                    type: 'input',
                                    name: 'token',
                                    message: 'Two-step login code:',
                                });
                                twoFactorToken = answer.token;
                            }
                            if (twoFactorToken == null || twoFactorToken === '') {
                                return Response.badRequest('Code is required.');
                            }
                        }
                        response = yield this.authService.logInTwoFactor(selectedProvider.type, twoFactorToken, false);
                    }
                }
                if (response.twoFactor) {
                    return Response.error('Login failed.');
                }
                if (this.success != null) {
                    const res = yield this.success();
                    return Response.success(res);
                }
                else {
                    const res = new MessageResponse('You are logged in!', null);
                    return Response.success(res);
                }
            }
            catch (e) {
                return Response.error(e);
            }
        });
    }
}

// CONCATENATED MODULE: ./src/commands/login.command.ts
var commands_login_command_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};



class commands_login_command_LoginCommand extends login_command_LoginCommand {
    constructor(authService, apiService, cryptoFunctionService, syncService, i18nService) {
        super(authService, apiService, i18nService);
        this.validatedParams = () => commands_login_command_awaiter(this, void 0, void 0, function* () {
            const key = yield cryptoFunctionService.randomBytes(64);
            process.env.BW_SESSION = utils_Utils.fromBufferToB64(key);
        });
        this.success = () => commands_login_command_awaiter(this, void 0, void 0, function* () {
            yield syncService.fullSync(true);
            const res = new MessageResponse('You are logged in!', '\n' +
                'To unlock your vault, set your session key to the `BW_SESSION` environment variable. ex:\n' +
                '$ export BW_SESSION="' + process.env.BW_SESSION + '"\n' +
                '> $env:BW_SESSION="' + process.env.BW_SESSION + '"\n\n' +
                'You can also pass the session key to any command with the `--session` option. ex:\n' +
                '$ bw list items --session ' + process.env.BW_SESSION);
            res.raw = process.env.BW_SESSION;
            return res;
        });
    }
}

// CONCATENATED MODULE: ./src/commands/restore.command.ts
var restore_command_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};

class restore_command_RestoreCommand {
    constructor(cipherService) {
        this.cipherService = cipherService;
    }
    run(object, id, cmd) {
        return restore_command_awaiter(this, void 0, void 0, function* () {
            if (id != null) {
                id = id.toLowerCase();
            }
            switch (object.toLowerCase()) {
                case 'item':
                    return yield this.restoreCipher(id, cmd);
                default:
                    return Response.badRequest('Unknown object.');
            }
        });
    }
    restoreCipher(id, cmd) {
        return restore_command_awaiter(this, void 0, void 0, function* () {
            const cipher = yield this.cipherService.get(id);
            if (cipher == null) {
                return Response.notFound();
            }
            if (cipher.deletedDate == null) {
                return Response.badRequest('Cipher is not in trash.');
            }
            try {
                yield this.cipherService.restoreWithServer(id);
                return Response.success();
            }
            catch (e) {
                return Response.error(e);
            }
        });
    }
}

// CONCATENATED MODULE: ./src/commands/share.command.ts
var share_command_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};



class share_command_ShareCommand {
    constructor(cipherService) {
        this.cipherService = cipherService;
    }
    run(id, organizationId, requestJson, cmd) {
        return share_command_awaiter(this, void 0, void 0, function* () {
            if (requestJson == null || requestJson === '') {
                requestJson = yield utils_CliUtils.readStdin();
            }
            if (requestJson == null || requestJson === '') {
                return Response.badRequest('`requestJson` was not provided.');
            }
            let req = [];
            try {
                const reqJson = Buffer.from(requestJson, 'base64').toString();
                req = JSON.parse(reqJson);
                if (req == null || req.length === 0) {
                    return Response.badRequest('You must provide at least one collection id for this item.');
                }
            }
            catch (e) {
                return Response.badRequest('Error parsing the encoded request data.');
            }
            if (id != null) {
                id = id.toLowerCase();
            }
            if (organizationId != null) {
                organizationId = organizationId.toLowerCase();
            }
            const cipher = yield this.cipherService.get(id);
            if (cipher == null) {
                return Response.notFound();
            }
            if (cipher.organizationId != null) {
                return Response.badRequest('This item already belongs to an organization.');
            }
            const cipherView = yield cipher.decrypt();
            try {
                yield this.cipherService.shareWithServer(cipherView, organizationId, req);
                const updatedCipher = yield this.cipherService.get(cipher.id);
                const decCipher = yield updatedCipher.decrypt();
                const res = new response_cipherResponse_CipherResponse(decCipher);
                return Response.success(res);
            }
            catch (e) {
                return Response.error(e);
            }
        });
    }
}

// CONCATENATED MODULE: ./src/commands/sync.command.ts
var sync_command_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};



class sync_command_SyncCommand {
    constructor(syncService) {
        this.syncService = syncService;
    }
    run(cmd) {
        return sync_command_awaiter(this, void 0, void 0, function* () {
            if (cmd.last || false) {
                return yield this.getLastSync();
            }
            try {
                const result = yield this.syncService.fullSync(cmd.force || false);
                const res = new MessageResponse('Syncing complete.', null);
                return Response.success(res);
            }
            catch (e) {
                return Response.error(e);
            }
        });
    }
    getLastSync() {
        return sync_command_awaiter(this, void 0, void 0, function* () {
            const lastSyncDate = yield this.syncService.getLastSync();
            const res = new StringResponse(lastSyncDate == null ? null : lastSyncDate.toISOString());
            return Response.success(res);
        });
    }
}

// CONCATENATED MODULE: ./src/commands/unlock.command.ts
var unlock_command_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};




class unlock_command_UnlockCommand {
    constructor(cryptoService, userService, cryptoFunctionService) {
        this.cryptoService = cryptoService;
        this.userService = userService;
        this.cryptoFunctionService = cryptoFunctionService;
    }
    run(password, cmd) {
        return unlock_command_awaiter(this, void 0, void 0, function* () {
            const canInteract = process.env.BW_NOINTERACTION !== 'true';
            if ((password == null || password === '') && canInteract) {
                const answer = yield external_inquirer_["createPromptModule"]({ output: process.stderr })({
                    type: 'password',
                    name: 'password',
                    message: 'Master password:',
                });
                password = answer.password;
            }
            if (password == null || password === '') {
                return Response.badRequest('Master password is required.');
            }
            this.setNewSessionKey();
            const email = yield this.userService.getEmail();
            const kdf = yield this.userService.getKdf();
            const kdfIterations = yield this.userService.getKdfIterations();
            const key = yield this.cryptoService.makeKey(password, email, kdf, kdfIterations);
            const keyHash = yield this.cryptoService.hashPassword(password, key);
            const storedKeyHash = yield this.cryptoService.getKeyHash();
            if (storedKeyHash != null && keyHash != null && storedKeyHash === keyHash) {
                yield this.cryptoService.setKey(key);
                const res = new MessageResponse('Your vault is now unlocked!', '\n' +
                    'To unlock your vault, set your session key to the `BW_SESSION` environment variable. ex:\n' +
                    '$ export BW_SESSION="' + process.env.BW_SESSION + '"\n' +
                    '> $env:BW_SESSION="' + process.env.BW_SESSION + '"\n\n' +
                    'You can also pass the session key to any command with the `--session` option. ex:\n' +
                    '$ bw list items --session ' + process.env.BW_SESSION);
                res.raw = process.env.BW_SESSION;
                return Response.success(res);
            }
            else {
                return Response.error('Invalid master password.');
            }
        });
    }
    setNewSessionKey() {
        return unlock_command_awaiter(this, void 0, void 0, function* () {
            const key = yield this.cryptoFunctionService.randomBytes(64);
            process.env.BW_SESSION = utils_Utils.fromBufferToB64(key);
        });
    }
}

// CONCATENATED MODULE: ./src/commands/completion.command.ts
var completion_command_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};


const validShells = ['zsh'];
class completion_command_CompletionCommand {
    run(cmd) {
        return completion_command_awaiter(this, void 0, void 0, function* () {
            const shell = cmd.shell;
            if (!shell) {
                return Response.badRequest('`shell` was not provided.');
            }
            if (!validShells.includes(shell)) {
                return Response.badRequest('Unsupported shell.');
            }
            let content = '';
            if (shell === 'zsh') {
                content = this.zshCompletion('bw', cmd.parent).render();
            }
            const res = new MessageResponse(content, null);
            return Response.success(res);
        });
    }
    zshCompletion(rootName, rootCommand) {
        return {
            render: () => {
                return [
                    `#compdef _${rootName} ${rootName}`,
                    '',
                    this.renderCommandBlock(rootName, rootCommand),
                ].join('\n');
            },
        };
    }
    renderCommandBlock(name, command) {
        const { commands = [], options = [] } = command;
        const hasOptions = options.length > 0;
        const hasCommands = commands.length > 0;
        const args = options
            .map(({ long, short, description }) => {
            const aliases = [short, long].filter(Boolean);
            const opts = aliases.join(',');
            const desc = `[${description.replace(`'`, `'"'"'`)}]`;
            return aliases.length > 1 ? `'(${aliases.join(' ')})'{${opts}}'${desc}'` : `'${opts}${desc}'`;
        }).concat(`'(-h --help)'{-h,--help}'[output usage information]'`, hasCommands ? '"1: :->cmnds"' : null, '"*::arg:->args"').filter(Boolean);
        const commandBlockFunctionParts = [];
        if (hasCommands) {
            commandBlockFunctionParts.push('local -a commands');
        }
        if (hasOptions) {
            commandBlockFunctionParts.push(`_arguments -C \\\n    ${args.join(` \\\n    `)}`);
        }
        if (hasCommands) {
            commandBlockFunctionParts.push(`case $state in
    cmnds)
      commands=(
        ${commands.map(({ _name, _description }) => `"${_name}:${_description}"`).join('\n        ')}
      )
      _describe "command" commands
      ;;
  esac

  case "$words[1]" in
    ${commands.map(({ _name }) => [`${_name})`, `_${name}_${_name}`, ';;'].join('\n      ')).join('\n    ')}
  esac`);
        }
        const commandBlocParts = [
            `function _${name} {\n  ${commandBlockFunctionParts.join('\n\n  ')}\n}`,
        ];
        if (hasCommands) {
            commandBlocParts.push(commands.map((c) => this.renderCommandBlock(`${name}_${c._name}`, c)).join('\n\n'));
        }
        return commandBlocParts.join('\n\n');
    }
}

// CONCATENATED MODULE: ./jslib/src/cli/commands/logout.command.ts
var logout_command_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};


class logout_command_LogoutCommand {
    constructor(authService, i18nService, logoutCallback) {
        this.authService = authService;
        this.i18nService = i18nService;
        this.logoutCallback = logoutCallback;
    }
    run(cmd) {
        return logout_command_awaiter(this, void 0, void 0, function* () {
            yield this.logoutCallback();
            this.authService.logOut(() => { });
            const res = new MessageResponse('You have logged out.', null);
            return Response.success(res);
        });
    }
}

// CONCATENATED MODULE: ./jslib/src/cli/commands/update.command.ts
var update_command_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};



class update_command_UpdateCommand {
    constructor(platformUtilsService, i18nService, repoName, executableName, showExtendedMessage) {
        this.platformUtilsService = platformUtilsService;
        this.i18nService = i18nService;
        this.repoName = repoName;
        this.executableName = executableName;
        this.showExtendedMessage = showExtendedMessage;
        this.inPkg = false;
        this.inPkg = !!process.pkg;
    }
    run(cmd) {
        return update_command_awaiter(this, void 0, void 0, function* () {
            const currentVersion = this.platformUtilsService.getApplicationVersion();
            const response = yield external_node_fetch_default.a('https://api.github.com/repos/bitwarden/' +
                this.repoName + '/releases/latest');
            if (response.status === 200) {
                const responseJson = yield response.json();
                const res = new MessageResponse(null, null);
                const tagName = responseJson.tag_name;
                if (tagName === ('v' + currentVersion)) {
                    res.title = 'No update available.';
                    res.noColor = true;
                    return Response.success(res);
                }
                let downloadUrl = null;
                if (responseJson.assets != null) {
                    for (const a of responseJson.assets) {
                        const download = a.browser_download_url;
                        if (download == null) {
                            continue;
                        }
                        if (download.indexOf('.zip') === -1) {
                            continue;
                        }
                        if (process.platform === 'win32' && download.indexOf(this.executableName + '-windows') > -1) {
                            downloadUrl = download;
                            break;
                        }
                        else if (process.platform === 'darwin' && download.indexOf(this.executableName + '-macos') > -1) {
                            downloadUrl = download;
                            break;
                        }
                        else if (process.platform === 'linux' && download.indexOf(this.executableName + '-linux') > -1) {
                            downloadUrl = download;
                            break;
                        }
                    }
                }
                res.title = 'A new version is available: ' + tagName;
                if (downloadUrl == null) {
                    downloadUrl = 'https://github.com/bitwarden/' + this.repoName + '/releases';
                }
                else {
                    res.raw = downloadUrl;
                }
                res.message = '';
                if (responseJson.body != null && responseJson.body !== '') {
                    res.message = responseJson.body + '\n\n';
                }
                res.message += 'You can download this update at ' + downloadUrl;
                if (this.showExtendedMessage) {
                    if (this.inPkg) {
                        res.message += '\n\nIf you installed this CLI through a package manager ' +
                            'you should probably update using its update command instead.';
                    }
                    else {
                        res.message += '\n\nIf you installed this CLI through NPM ' +
                            'you should update using `npm install -g @bitwarden/' + this.repoName + '`';
                    }
                }
                return Response.success(res);
            }
            else {
                return Response.error('Error contacting update API: ' + response.status);
            }
        });
    }
}

// CONCATENATED MODULE: ./jslib/src/cli/baseProgram.ts
var baseProgram_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};


const chalk = external_chalk_default.a;
class baseProgram_BaseProgram {
    constructor(userService, writeLn) {
        this.userService = userService;
        this.writeLn = writeLn;
    }
    processResponse(response, exitImmediately = false, dataProcessor = null) {
        if (!response.success) {
            if (process.env.BW_QUIET !== 'true') {
                if (process.env.BW_RESPONSE === 'true') {
                    this.writeLn(this.getJson(response), true, true);
                }
                else {
                    this.writeLn(chalk.redBright(response.message), true, true);
                }
            }
            if (exitImmediately) {
                process.exit(1);
            }
            else {
                process.exitCode = 1;
            }
            return;
        }
        if (process.env.BW_RESPONSE === 'true') {
            this.writeLn(this.getJson(response), true, false);
        }
        else if (response.data != null) {
            let out = dataProcessor != null ? dataProcessor() : null;
            if (out == null) {
                if (response.data.object === 'string') {
                    const data = response.data.data;
                    if (data != null) {
                        out = data;
                    }
                }
                else if (response.data.object === 'list') {
                    out = this.getJson(response.data.data);
                }
                else if (response.data.object === 'message') {
                    out = this.getMessage(response);
                }
                else {
                    out = this.getJson(response.data);
                }
            }
            if (out != null && process.env.BW_QUIET !== 'true') {
                this.writeLn(out, true, false);
            }
        }
        if (exitImmediately) {
            process.exit(0);
        }
        else {
            process.exitCode = 0;
        }
    }
    getJson(obj) {
        if (process.env.BW_PRETTY === 'true') {
            return JSON.stringify(obj, null, '  ');
        }
        else {
            return JSON.stringify(obj);
        }
    }
    getMessage(response) {
        const message = response.data;
        if (process.env.BW_RAW === 'true') {
            return message.raw;
        }
        let out = '';
        if (message.title != null) {
            if (message.noColor) {
                out = message.title;
            }
            else {
                out = chalk.greenBright(message.title);
            }
        }
        if (message.message != null) {
            if (message.title != null) {
                out += '\n';
            }
            out += message.message;
        }
        return out.trim() === '' ? null : out;
    }
    exitIfAuthed() {
        return baseProgram_awaiter(this, void 0, void 0, function* () {
            const authed = yield this.userService.isAuthenticated();
            if (authed) {
                const email = yield this.userService.getEmail();
                this.processResponse(Response.error('You are already logged in as ' + email + '.'), true);
            }
        });
    }
    exitIfNotAuthed() {
        return baseProgram_awaiter(this, void 0, void 0, function* () {
            const authed = yield this.userService.isAuthenticated();
            if (!authed) {
                this.processResponse(Response.error('You are not logged in.'), true);
            }
        });
    }
}

// CONCATENATED MODULE: ./src/program.ts
var program_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};


























const program_chalk = external_chalk_default.a;
const writeLn = utils_CliUtils.writeLn;
class program_Program extends baseProgram_BaseProgram {
    constructor(main) {
        super(main.userService, writeLn);
        this.main = main;
    }
    run() {
        external_commander_["option"]('--pretty', 'Format output. JSON is tabbed with two spaces.')
            .option('--raw', 'Return raw output instead of a descriptive message.')
            .option('--response', 'Return a JSON formatted version of response output.')
            .option('--quiet', 'Don\'t return anything to stdout.')
            .option('--nointeraction', 'Do not prompt for interactive user input.')
            .option('--session <session>', 'Pass session key instead of reading from env.')
            .version(this.main.platformUtilsService.getApplicationVersion(), '-v, --version');
        external_commander_["on"]('option:pretty', () => {
            process.env.BW_PRETTY = 'true';
        });
        external_commander_["on"]('option:raw', () => {
            process.env.BW_RAW = 'true';
        });
        external_commander_["on"]('option:quiet', () => {
            process.env.BW_QUIET = 'true';
        });
        external_commander_["on"]('option:response', () => {
            process.env.BW_RESPONSE = 'true';
        });
        external_commander_["on"]('option:nointeraction', () => {
            process.env.BW_NOINTERACTION = 'true';
        });
        external_commander_["on"]('option:session', (key) => {
            process.env.BW_SESSION = key;
        });
        external_commander_["on"]('command:*', () => {
            writeLn(program_chalk.redBright('Invalid command: ' + external_commander_["args"].join(' ')), false, true);
            writeLn('See --help for a list of available commands.', true, true);
            process.exitCode = 1;
        });
        external_commander_["on"]('--help', () => {
            writeLn('\n  Examples:');
            writeLn('');
            writeLn('    bw login');
            writeLn('    bw lock');
            writeLn('    bw unlock myPassword321');
            writeLn('    bw list --help');
            writeLn('    bw list items --search google');
            writeLn('    bw get item 99ee88d2-6046-4ea7-92c2-acac464b1412');
            writeLn('    bw get password google.com');
            writeLn('    echo \'{"name":"My Folder"}\' | bw encode');
            writeLn('    bw create folder eyJuYW1lIjoiTXkgRm9sZGVyIn0K');
            writeLn('    bw edit folder c7c7b60b-9c61-40f2-8ccd-36c49595ed72 eyJuYW1lIjoiTXkgRm9sZGVyMiJ9Cg==');
            writeLn('    bw delete item 99ee88d2-6046-4ea7-92c2-acac464b1412');
            writeLn('    bw generate -lusn --length 18');
            writeLn('    bw config server https://bitwarden.example.com');
            writeLn('', true);
        });
        external_commander_["command"]('login [email] [password]')
            .description('Log into a user account.')
            .option('--method <method>', 'Two-step login method.')
            .option('--code <code>', 'Two-step login code.')
            .option('--check', 'Check login status.', () => program_awaiter(this, void 0, void 0, function* () {
            const authed = yield this.main.userService.isAuthenticated();
            if (authed) {
                const res = new MessageResponse('You are logged in!', null);
                this.processResponse(Response.success(res), true);
            }
            this.processResponse(Response.error('You are not logged in.'), true);
        }))
            .on('--help', () => {
            writeLn('\n  Notes:');
            writeLn('');
            writeLn('    See docs for valid `method` enum values.');
            writeLn('');
            writeLn('    Pass `--raw` option to only return the session key.');
            writeLn('');
            writeLn('  Examples:');
            writeLn('');
            writeLn('    bw login');
            writeLn('    bw login john@example.com myPassword321 --raw');
            writeLn('    bw login john@example.com myPassword321 --method 1 --code 249213');
            writeLn('', true);
        })
            .action((email, password, cmd) => program_awaiter(this, void 0, void 0, function* () {
            if (!cmd.check) {
                yield this.exitIfAuthed();
                const command = new commands_login_command_LoginCommand(this.main.authService, this.main.apiService, this.main.cryptoFunctionService, this.main.syncService, this.main.i18nService);
                const response = yield command.run(email, password, cmd);
                this.processResponse(response);
            }
        }));
        external_commander_["command"]('logout')
            .description('Log out of the current user account.')
            .on('--help', () => {
            writeLn('\n  Examples:');
            writeLn('');
            writeLn('    bw logout');
            writeLn('', true);
        })
            .action((cmd) => program_awaiter(this, void 0, void 0, function* () {
            yield this.exitIfNotAuthed();
            const command = new logout_command_LogoutCommand(this.main.authService, this.main.i18nService, () => program_awaiter(this, void 0, void 0, function* () { return yield this.main.logout(); }));
            const response = yield command.run(cmd);
            this.processResponse(response);
        }));
        external_commander_["command"]('lock')
            .description('Lock the vault and destroy active session keys.')
            .on('--help', () => {
            writeLn('\n  Examples:');
            writeLn('');
            writeLn('    bw lock');
            writeLn('', true);
        })
            .action((cmd) => program_awaiter(this, void 0, void 0, function* () {
            yield this.exitIfNotAuthed();
            const command = new lock_command_LockCommand(this.main.vaultTimeoutService);
            const response = yield command.run(cmd);
            this.processResponse(response);
        }));
        external_commander_["command"]('unlock [password]')
            .description('Unlock the vault and return a new session key.')
            .on('--help', () => {
            writeLn('\n  Notes:');
            writeLn('');
            writeLn('    After unlocking, any previous session keys will no longer be valid.');
            writeLn('');
            writeLn('    Pass `--raw` option to only return the session key.');
            writeLn('');
            writeLn('  Examples:');
            writeLn('');
            writeLn('    bw unlock');
            writeLn('    bw unlock myPassword321');
            writeLn('    bw unlock myPassword321 --raw');
            writeLn('', true);
        })
            .option('--check', 'Check lock status.', () => program_awaiter(this, void 0, void 0, function* () {
            const locked = yield this.main.vaultTimeoutService.isLocked();
            if (!locked) {
                const res = new MessageResponse('Vault is unlocked!', null);
                this.processResponse(Response.success(res), true);
            }
            this.processResponse(Response.error('Vault is locked.'), true);
        }))
            .action((password, cmd) => program_awaiter(this, void 0, void 0, function* () {
            if (!cmd.check) {
                yield this.exitIfNotAuthed();
                const command = new unlock_command_UnlockCommand(this.main.cryptoService, this.main.userService, this.main.cryptoFunctionService);
                const response = yield command.run(password, cmd);
                this.processResponse(response);
            }
        }));
        external_commander_["command"]('sync')
            .description('Pull the latest vault data from server.')
            .option('-f, --force', 'Force a full sync.')
            .option('--last', 'Get the last sync date.')
            .on('--help', () => {
            writeLn('\n  Examples:');
            writeLn('');
            writeLn('    bw sync');
            writeLn('    bw sync -f');
            writeLn('    bw sync --last');
            writeLn('', true);
        })
            .action((cmd) => program_awaiter(this, void 0, void 0, function* () {
            yield this.exitIfLocked();
            const command = new sync_command_SyncCommand(this.main.syncService);
            const response = yield command.run(cmd);
            this.processResponse(response);
        }));
        external_commander_["command"]('list <object>')
            .description('List an array of objects from the vault.')
            .option('--search <search>', 'Perform a search on the listed objects.')
            .option('--url <url>', 'Filter items of type login with a url-match search.')
            .option('--folderid <folderid>', 'Filter items by folder id.')
            .option('--collectionid <collectionid>', 'Filter items by collection id.')
            .option('--organizationid <organizationid>', 'Filter items or collections by organization id.')
            .option('--trash', 'Filter items that are deleted and in the trash.')
            .on('--help', () => {
            writeLn('\n  Objects:');
            writeLn('');
            writeLn('    items');
            writeLn('    folders');
            writeLn('    collections');
            writeLn('    organizations');
            writeLn('    org-collections');
            writeLn('    org-members');
            writeLn('');
            writeLn('  Notes:');
            writeLn('');
            writeLn('    Combining search with a filter performs a logical AND operation.');
            writeLn('');
            writeLn('    Combining multiple filters performs a logical OR operation.');
            writeLn('');
            writeLn('  Examples:');
            writeLn('');
            writeLn('    bw list items');
            writeLn('    bw list items --folderid 60556c31-e649-4b5d-8daf-fc1c391a1bf2');
            writeLn('    bw list items --search google --folderid 60556c31-e649-4b5d-8daf-fc1c391a1bf2');
            writeLn('    bw list items --url https://google.com');
            writeLn('    bw list items --folderid null');
            writeLn('    bw list items --organizationid notnull');
            writeLn('    bw list items --folderid 60556c31-e649-4b5d-8daf-fc1c391a1bf2 --organizationid notnull');
            writeLn('    bw list items --trash');
            writeLn('    bw list folders --search email');
            writeLn('    bw list org-members --organizationid 60556c31-e649-4b5d-8daf-fc1c391a1bf2');
            writeLn('', true);
        })
            .action((object, cmd) => program_awaiter(this, void 0, void 0, function* () {
            yield this.exitIfLocked();
            const command = new list_command_ListCommand(this.main.cipherService, this.main.folderService, this.main.collectionService, this.main.userService, this.main.searchService, this.main.apiService);
            const response = yield command.run(object, cmd);
            this.processResponse(response);
        }));
        external_commander_["command"]('get <object> <id>')
            .description('Get an object from the vault.')
            .option('--itemid <itemid>', 'Attachment\'s item id.')
            .option('--output <output>', 'Output directory or filename for attachment.')
            .option('--organizationid <organizationid>', 'Organization id for an organization object.')
            .on('--help', () => {
            writeLn('\n  Objects:');
            writeLn('');
            writeLn('    item');
            writeLn('    username');
            writeLn('    password');
            writeLn('    uri');
            writeLn('    totp');
            writeLn('    exposed');
            writeLn('    attachment');
            writeLn('    folder');
            writeLn('    collection');
            writeLn('    org-collection');
            writeLn('    organization');
            writeLn('    template');
            writeLn('    fingerprint');
            writeLn('');
            writeLn('  Id:');
            writeLn('');
            writeLn('    Search term or object\'s globally unique `id`.');
            writeLn('');
            writeLn('  Examples:');
            writeLn('');
            writeLn('    bw get item 99ee88d2-6046-4ea7-92c2-acac464b1412');
            writeLn('    bw get password https://google.com');
            writeLn('    bw get totp google.com');
            writeLn('    bw get exposed yahoo.com');
            writeLn('    bw get attachment b857igwl1dzrs2 --itemid 99ee88d2-6046-4ea7-92c2-acac464b1412 ' +
                '--output ./photo.jpg');
            writeLn('    bw get attachment photo.jpg --itemid 99ee88d2-6046-4ea7-92c2-acac464b1412 --raw');
            writeLn('    bw get folder email');
            writeLn('    bw get template folder');
            writeLn('', true);
        })
            .action((object, id, cmd) => program_awaiter(this, void 0, void 0, function* () {
            yield this.exitIfLocked();
            const command = new get_command_GetCommand(this.main.cipherService, this.main.folderService, this.main.collectionService, this.main.totpService, this.main.auditService, this.main.cryptoService, this.main.userService, this.main.searchService, this.main.apiService);
            const response = yield command.run(object, id, cmd);
            this.processResponse(response);
        }));
        external_commander_["command"]('create <object> [encodedJson]')
            .option('--file <file>', 'Path to file for attachment.')
            .option('--itemid <itemid>', 'Attachment\'s item id.')
            .option('--organizationid <organizationid>', 'Organization id for an organization object.')
            .description('Create an object in the vault.')
            .on('--help', () => {
            writeLn('\n  Objects:');
            writeLn('');
            writeLn('    item');
            writeLn('    attachment');
            writeLn('    folder');
            writeLn('    org-collection');
            writeLn('');
            writeLn('  Notes:');
            writeLn('');
            writeLn('    `encodedJson` can also be piped into stdin.');
            writeLn('');
            writeLn('  Examples:');
            writeLn('');
            writeLn('    bw create folder eyJuYW1lIjoiTXkgRm9sZGVyIn0K');
            writeLn('    echo \'eyJuYW1lIjoiTXkgRm9sZGVyIn0K\' | bw create folder');
            writeLn('    bw create attachment --file ./myfile.csv ' +
                '--itemid 16b15b89-65b3-4639-ad2a-95052a6d8f66');
            writeLn('', true);
        })
            .action((object, encodedJson, cmd) => program_awaiter(this, void 0, void 0, function* () {
            yield this.exitIfLocked();
            const command = new create_command_CreateCommand(this.main.cipherService, this.main.folderService, this.main.userService, this.main.cryptoService, this.main.apiService);
            const response = yield command.run(object, encodedJson, cmd);
            this.processResponse(response);
        }));
        external_commander_["command"]('edit <object> <id> [encodedJson]')
            .option('--organizationid <organizationid>', 'Organization id for an organization object.')
            .description('Edit an object from the vault.')
            .on('--help', () => {
            writeLn('\n  Objects:');
            writeLn('');
            writeLn('    item');
            writeLn('    item-collections');
            writeLn('    folder');
            writeLn('    org-collection');
            writeLn('');
            writeLn('  Id:');
            writeLn('');
            writeLn('    Object\'s globally unique `id`.');
            writeLn('');
            writeLn('  Notes:');
            writeLn('');
            writeLn('    `encodedJson` can also be piped into stdin.');
            writeLn('');
            writeLn('  Examples:');
            writeLn('');
            writeLn('    bw edit folder 5cdfbd80-d99f-409b-915b-f4c5d0241b02 eyJuYW1lIjoiTXkgRm9sZGVyMiJ9Cg==');
            writeLn('    echo \'eyJuYW1lIjoiTXkgRm9sZGVyMiJ9Cg==\' | ' +
                'bw edit folder 5cdfbd80-d99f-409b-915b-f4c5d0241b02');
            writeLn('    bw edit item-collections 78307355-fd25-416b-88b8-b33fd0e88c82 ' +
                'WyI5NzQwNTNkMC0zYjMzLTRiOTgtODg2ZS1mZWNmNWM4ZGJhOTYiXQ==');
            writeLn('', true);
        })
            .action((object, id, encodedJson, cmd) => program_awaiter(this, void 0, void 0, function* () {
            yield this.exitIfLocked();
            const command = new edit_command_EditCommand(this.main.cipherService, this.main.folderService, this.main.cryptoService, this.main.apiService);
            const response = yield command.run(object, id, encodedJson, cmd);
            this.processResponse(response);
        }));
        external_commander_["command"]('delete <object> <id>')
            .option('--itemid <itemid>', 'Attachment\'s item id.')
            .option('--organizationid <organizationid>', 'Organization id for an organization object.')
            .option('-p, --permanent', 'Permanently deletes the item instead of soft-deleting it (item only).')
            .description('Delete an object from the vault.')
            .on('--help', () => {
            writeLn('\n  Objects:');
            writeLn('');
            writeLn('    item');
            writeLn('    attachment');
            writeLn('    folder');
            writeLn('    org-collection');
            writeLn('');
            writeLn('  Id:');
            writeLn('');
            writeLn('    Object\'s globally unique `id`.');
            writeLn('');
            writeLn('  Examples:');
            writeLn('');
            writeLn('    bw delete item 7063feab-4b10-472e-b64c-785e2b870b92');
            writeLn('    bw delete item 89c21cd2-fab0-4f69-8c6e-ab8a0168f69a --permanent');
            writeLn('    bw delete folder 5cdfbd80-d99f-409b-915b-f4c5d0241b02');
            writeLn('    bw delete attachment b857igwl1dzrs2 --itemid 310d5ffd-e9a2-4451-af87-ea054dce0f78');
            writeLn('', true);
        })
            .action((object, id, cmd) => program_awaiter(this, void 0, void 0, function* () {
            yield this.exitIfLocked();
            const command = new delete_command_DeleteCommand(this.main.cipherService, this.main.folderService, this.main.userService, this.main.apiService);
            const response = yield command.run(object, id, cmd);
            this.processResponse(response);
        }));
        external_commander_["command"]('restore <object> <id>')
            .description('Restores an object from the trash.')
            .on('--help', () => {
            writeLn('\n  Objects:');
            writeLn('');
            writeLn('    item');
            writeLn('');
            writeLn('  Id:');
            writeLn('');
            writeLn('    Object\'s globally unique `id`.');
            writeLn('');
            writeLn('  Examples:');
            writeLn('');
            writeLn('    bw restore item 7063feab-4b10-472e-b64c-785e2b870b92');
            writeLn('', true);
        })
            .action((object, id, cmd) => program_awaiter(this, void 0, void 0, function* () {
            yield this.exitIfLocked();
            const command = new restore_command_RestoreCommand(this.main.cipherService);
            const response = yield command.run(object, id, cmd);
            this.processResponse(response);
        }));
        external_commander_["command"]('share <id> <organizationId> [encodedJson]')
            .description('Share an item to an organization.')
            .on('--help', () => {
            writeLn('\n  Id:');
            writeLn('');
            writeLn('    Item\'s globally unique `id`.');
            writeLn('');
            writeLn('  Organization Id:');
            writeLn('');
            writeLn('    Organization\'s globally unique `id`.');
            writeLn('');
            writeLn('  Notes:');
            writeLn('');
            writeLn('    `encodedJson` can also be piped into stdin. `encodedJson` contains ' +
                'an array of collection ids.');
            writeLn('');
            writeLn('  Examples:');
            writeLn('');
            writeLn('    bw share 4af958ce-96a7-45d9-beed-1e70fabaa27a 6d82949b-b44d-468a-adae-3f3bacb0ea32 ' +
                'WyI5NzQwNTNkMC0zYjMzLTRiOTgtODg2ZS1mZWNmNWM4ZGJhOTYiXQ==');
            writeLn('    echo \'["974053d0-3b33-4b98-886e-fecf5c8dba96"]\' | bw encode | ' +
                'bw share 4af958ce-96a7-45d9-beed-1e70fabaa27a 6d82949b-b44d-468a-adae-3f3bacb0ea32');
            writeLn('', true);
        })
            .action((id, organizationId, encodedJson, cmd) => program_awaiter(this, void 0, void 0, function* () {
            yield this.exitIfLocked();
            const command = new share_command_ShareCommand(this.main.cipherService);
            const response = yield command.run(id, organizationId, encodedJson, cmd);
            this.processResponse(response);
        }));
        external_commander_["command"]('confirm <object> <id>')
            .option('--organizationid <organizationid>', 'Organization id for an organization object.')
            .description('Confirm an object to the organization.')
            .on('--help', () => {
            writeLn('\n  Objects:');
            writeLn('');
            writeLn('    org-member');
            writeLn('');
            writeLn('  Id:');
            writeLn('');
            writeLn('    Object\'s globally unique `id`.');
            writeLn('');
            writeLn('  Examples:');
            writeLn('');
            writeLn('    bw confirm org-member 7063feab-4b10-472e-b64c-785e2b870b92 ' +
                '--organizationid 310d5ffd-e9a2-4451-af87-ea054dce0f78');
            writeLn('', true);
        })
            .action((object, id, cmd) => program_awaiter(this, void 0, void 0, function* () {
            yield this.exitIfLocked();
            const command = new confirm_command_ConfirmCommand(this.main.apiService, this.main.cryptoService);
            const response = yield command.run(object, id, cmd);
            this.processResponse(response);
        }));
        external_commander_["command"]('import [format] [input]')
            .description('Import vault data from a file.')
            .option('--formats', 'List formats')
            .on('--help', () => {
            writeLn('\n Examples:');
            writeLn('');
            writeLn('    bw import --formats');
            writeLn('    bw import bitwardencsv ./from/source.csv');
            writeLn('    bw import keepass2xml keepass_backup.xml');
        })
            .action((format, filepath, cmd) => program_awaiter(this, void 0, void 0, function* () {
            yield this.exitIfLocked();
            const command = new import_command_ImportCommand(this.main.importService);
            const response = yield command.run(format, filepath, cmd);
            this.processResponse(response);
        }));
        external_commander_["command"]('export [password]')
            .description('Export vault data to a CSV or JSON file.')
            .option('--output <output>', 'Output directory or filename.')
            .option('--format <format>', 'Export file format.')
            .option('--organizationid <organizationid>', 'Organization id for an organization.')
            .on('--help', () => {
            writeLn('\n  Notes:');
            writeLn('');
            writeLn('    Valid formats are `csv` and `json`. Default format is `csv`.');
            writeLn('');
            writeLn('  Examples:');
            writeLn('');
            writeLn('    bw export');
            writeLn('    bw export myPassword321');
            writeLn('    bw export myPassword321 --format json');
            writeLn('    bw export --output ./exp/bw.csv');
            writeLn('    bw export myPassword321 --output bw.json --format json');
            writeLn('    bw export myPassword321 --organizationid 7063feab-4b10-472e-b64c-785e2b870b92');
            writeLn('', true);
        })
            .action((password, cmd) => program_awaiter(this, void 0, void 0, function* () {
            yield this.exitIfLocked();
            const command = new export_command_ExportCommand(this.main.cryptoService, this.main.exportService);
            const response = yield command.run(password, cmd);
            this.processResponse(response);
        }));
        external_commander_["command"]('generate')
            .description('Generate a password/passphrase.')
            .option('-u, --uppercase', 'Include uppercase characters.')
            .option('-l, --lowercase', 'Include lowercase characters.')
            .option('-n, --number', 'Include numeric characters.')
            .option('-s, --special', 'Include special characters.')
            .option('-p, --passphrase', 'Generate a passphrase.')
            .option('--length <length>', 'Length of the password.')
            .option('--words <words>', 'Number of words.')
            .option('--separator <separator>', 'Word separator.')
            .on('--help', () => {
            writeLn('\n  Notes:');
            writeLn('');
            writeLn('    Default options are `-uln --length 14`.');
            writeLn('');
            writeLn('    Minimum `length` is 5.');
            writeLn('');
            writeLn('    Minimum `words` is 3.');
            writeLn('');
            writeLn('  Examples:');
            writeLn('');
            writeLn('    bw generate');
            writeLn('    bw generate -u -l --length 18');
            writeLn('    bw generate -ulns --length 25');
            writeLn('    bw generate -ul');
            writeLn('    bw generate -p --separator _');
            writeLn('    bw generate -p --words 5 --separator space');
            writeLn('', true);
        })
            .action((cmd) => program_awaiter(this, void 0, void 0, function* () {
            const command = new generate_command_GenerateCommand(this.main.passwordGenerationService);
            const response = yield command.run(cmd);
            this.processResponse(response);
        }));
        external_commander_["command"]('encode')
            .description('Base 64 encode stdin.')
            .on('--help', () => {
            writeLn('\n  Notes:');
            writeLn('');
            writeLn('    Use to create `encodedJson` for `create` and `edit` commands.');
            writeLn('');
            writeLn('  Examples:');
            writeLn('');
            writeLn('    echo \'{"name":"My Folder"}\' | bw encode');
            writeLn('', true);
        })
            .action((object, id, cmd) => program_awaiter(this, void 0, void 0, function* () {
            const command = new encode_command_EncodeCommand();
            const response = yield command.run(cmd);
            this.processResponse(response);
        }));
        external_commander_["command"]('config <setting> [value]')
            .description('Configure CLI settings.')
            .option('--web-vault <url>', 'Provides a custom web vault URL that differs from the base URL.')
            .option('--api <url>', 'Provides a custom API URL that differs from the base URL.')
            .option('--identity <url>', 'Provides a custom identity URL that differs from the base URL.')
            .option('--icons <url>', 'Provides a custom icons service URL that differs from the base URL.')
            .option('--notifications <url>', 'Provides a custom notifications URL that differs from the base URL.')
            .option('--events <url>', 'Provides a custom events URL that differs from the base URL.')
            .on('--help', () => {
            writeLn('\n  Settings:');
            writeLn('');
            writeLn('    server - On-premises hosted installation URL.');
            writeLn('');
            writeLn('  Examples:');
            writeLn('');
            writeLn('    bw config server');
            writeLn('    bw config server https://bw.company.com');
            writeLn('    bw config server bitwarden.com');
            writeLn('    bw config server --api http://localhost:4000 --identity http://localhost:33656');
            writeLn('', true);
        })
            .action((setting, value, cmd) => program_awaiter(this, void 0, void 0, function* () {
            const command = new config_command_ConfigCommand(this.main.environmentService);
            const response = yield command.run(setting, value, cmd);
            this.processResponse(response);
        }));
        external_commander_["command"]('update')
            .description('Check for updates.')
            .on('--help', () => {
            writeLn('\n  Notes:');
            writeLn('');
            writeLn('    Returns the URL to download the newest version of this CLI tool.');
            writeLn('');
            writeLn('    Use the `--raw` option to return only the download URL for the update.');
            writeLn('');
            writeLn('  Examples:');
            writeLn('');
            writeLn('    bw update');
            writeLn('    bw update --raw');
            writeLn('', true);
        })
            .action((cmd) => program_awaiter(this, void 0, void 0, function* () {
            const command = new update_command_UpdateCommand(this.main.platformUtilsService, this.main.i18nService, 'cli', 'bw', true);
            const response = yield command.run(cmd);
            this.processResponse(response);
        }));
        external_commander_["command"]('completion')
            .description('Generate shell completions.')
            .option('--shell <shell>', 'Shell to generate completions for.')
            .on('--help', () => {
            writeLn('\n  Notes:');
            writeLn('');
            writeLn('    Valid shells are `zsh`.');
            writeLn('');
            writeLn('  Examples:');
            writeLn('');
            writeLn('    bw completion --shell zsh');
            writeLn('', true);
        })
            .action((cmd) => program_awaiter(this, void 0, void 0, function* () {
            const command = new completion_command_CompletionCommand();
            const response = yield command.run(cmd);
            this.processResponse(response);
        }));
        external_commander_["parse"](process.argv);
        if (process.argv.slice(2).length === 0) {
            external_commander_["outputHelp"]();
        }
    }
    processResponse(response, exitImmediately = false) {
        super.processResponse(response, exitImmediately, () => {
            if (response.data.object === 'template') {
                return this.getJson(response.data.template);
            }
            return null;
        });
    }
    exitIfLocked() {
        return program_awaiter(this, void 0, void 0, function* () {
            yield this.exitIfNotAuthed();
            const hasKey = yield this.main.cryptoService.hasKey();
            if (!hasKey) {
                const canInteract = process.env.BW_NOINTERACTION !== 'true';
                if (canInteract) {
                    const command = new unlock_command_UnlockCommand(this.main.cryptoService, this.main.userService, this.main.cryptoFunctionService);
                    const response = yield command.run(null, null);
                    if (!response.success) {
                        this.processResponse(response, true);
                    }
                }
                else {
                    this.processResponse(Response.error('Vault is locked.'), true);
                }
            }
        });
    }
}

// CONCATENATED MODULE: ./src/bw.ts
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Main", function() { return bw_Main; });
var bw_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
































// Polyfills
global.DOMParser = new external_jsdom_["JSDOM"]().window.DOMParser;
// tslint:disable-next-line
const packageJson = __webpack_require__(20);
class bw_Main {
    constructor() {
        let p = null;
        const relativeDataDir = external_path_["join"](external_path_["dirname"](process.execPath), 'bw-data');
        if (external_fs_["existsSync"](relativeDataDir)) {
            p = relativeDataDir;
        }
        else if (process.env.BITWARDENCLI_APPDATA_DIR) {
            p = external_path_["resolve"](process.env.BITWARDENCLI_APPDATA_DIR);
        }
        else if (process.platform === 'darwin') {
            p = external_path_["join"](process.env.HOME, 'Library/Application Support/Bitwarden CLI');
        }
        else if (process.platform === 'win32') {
            p = external_path_["join"](process.env.APPDATA, 'Bitwarden CLI');
        }
        else if (process.env.XDG_CONFIG_HOME) {
            p = external_path_["join"](process.env.XDG_CONFIG_HOME, 'Bitwarden CLI');
        }
        else {
            p = external_path_["join"](process.env.HOME, '.config/Bitwarden CLI');
        }
        this.i18nService = new services_i18n_service_I18nService('en', './locales');
        this.platformUtilsService = new cliPlatformUtils_service_CliPlatformUtilsService('cli', packageJson);
        this.cryptoFunctionService = new nodeCryptoFunction_service_NodeCryptoFunctionService();
        this.storageService = new lowdbStorage_service_LowdbStorageService(null, p, true);
        this.secureStorageService = new nodeEnvSecureStorage_service_NodeEnvSecureStorageService(this.storageService, () => this.cryptoService);
        this.cryptoService = new crypto_service_CryptoService(this.storageService, this.secureStorageService, this.cryptoFunctionService);
        this.appIdService = new appId_service_AppIdService(this.storageService);
        this.tokenService = new token_service_TokenService(this.storageService);
        this.messagingService = new NoopMessagingService();
        this.apiService = new nodeApi_service_NodeApiService(this.tokenService, this.platformUtilsService, (expired) => bw_awaiter(this, void 0, void 0, function* () { return yield this.logout(); }), 'Bitwarden_CLI/' + this.platformUtilsService.getApplicationVersion() +
            ' (' + this.platformUtilsService.getDeviceString().toUpperCase() + ')');
        this.environmentService = new environment_service_EnvironmentService(this.apiService, this.storageService, null);
        this.userService = new user_service_UserService(this.tokenService, this.storageService);
        this.containerService = new ContainerService(this.cryptoService);
        this.settingsService = new SettingsService(this.userService, this.storageService);
        this.cipherService = new cipher_service_CipherService(this.cryptoService, this.userService, this.settingsService, this.apiService, this.storageService, this.i18nService, null);
        this.folderService = new folder_service_FolderService(this.cryptoService, this.userService, this.apiService, this.storageService, this.i18nService, this.cipherService);
        this.collectionService = new collection_service_CollectionService(this.cryptoService, this.userService, this.storageService, this.i18nService);
        this.searchService = new search_service_SearchService(this.cipherService, this.platformUtilsService);
        this.policyService = new policy_service_PolicyService(this.userService, this.storageService);
        this.vaultTimeoutService = new vaultTimeout_service_VaultTimeoutService(this.cipherService, this.folderService, this.collectionService, this.cryptoService, this.platformUtilsService, this.storageService, this.messagingService, this.searchService, this.userService, this.tokenService, null, null);
        this.syncService = new sync_service_SyncService(this.userService, this.apiService, this.settingsService, this.folderService, this.cipherService, this.cryptoService, this.collectionService, this.storageService, this.messagingService, this.policyService, (expired) => bw_awaiter(this, void 0, void 0, function* () { return yield this.logout(); }));
        this.passwordGenerationService = new passwordGeneration_service_PasswordGenerationService(this.cryptoService, this.storageService, this.policyService);
        this.totpService = new totp_service_TotpService(this.storageService, this.cryptoFunctionService);
        this.importService = new import_service_ImportService(this.cipherService, this.folderService, this.apiService, this.i18nService, this.collectionService);
        this.exportService = new export_service_ExportService(this.folderService, this.cipherService, this.apiService);
        this.authService = new auth_service_AuthService(this.cryptoService, this.apiService, this.userService, this.tokenService, this.appIdService, this.i18nService, this.platformUtilsService, this.messagingService, true);
        this.auditService = new audit_service_AuditService(this.cryptoFunctionService, this.apiService);
        this.program = new program_Program(this);
    }
    run() {
        return bw_awaiter(this, void 0, void 0, function* () {
            yield this.init();
            this.program.run();
        });
    }
    logout() {
        return bw_awaiter(this, void 0, void 0, function* () {
            const userId = yield this.userService.getUserId();
            yield Promise.all([
                this.syncService.setLastSync(new Date(0)),
                this.tokenService.clearToken(),
                this.cryptoService.clearKeys(),
                this.userService.clear(),
                this.settingsService.clear(userId),
                this.cipherService.clear(userId),
                this.folderService.clear(userId),
                this.collectionService.clear(userId),
                this.policyService.clear(userId),
                this.passwordGenerationService.clear(),
            ]);
            process.env.BW_SESSION = null;
        });
    }
    init() {
        return bw_awaiter(this, void 0, void 0, function* () {
            this.storageService.init();
            this.containerService.attachToWindow(global);
            yield this.environmentService.setUrlsFromStorage();
            // Dev Server URLs. Comment out the line above.
            // this.apiService.setUrls({
            //     base: null,
            //     api: 'http://localhost:4000',
            //     identity: 'http://localhost:33656',
            // });
            const locale = yield this.storageService.get(ConstantsService.localeKey);
            yield this.i18nService.init(locale);
            this.authService.init();
            const installedVersion = yield this.storageService.get(ConstantsService.installedVersionKey);
            const currentVersion = this.platformUtilsService.getApplicationVersion();
            if (installedVersion == null || installedVersion !== currentVersion) {
                yield this.storageService.save(ConstantsService.installedVersionKey, currentVersion);
            }
        });
    }
}
const main = new bw_Main();
main.run();


/***/ })
/******/ ]);
//# sourceMappingURL=bw.js.map